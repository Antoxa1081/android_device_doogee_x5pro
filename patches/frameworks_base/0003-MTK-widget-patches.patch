From 621e1a8ecae6ebc63aa3d2575572024a6102e715 Mon Sep 17 00:00:00 2001
From: Yuri Konotopov <ykonotopov@gmail.com>
Date: Sun, 10 Jul 2016 21:11:05 +0300
Subject: [PATCH 3/3] MTK widget patches

Change-Id: Ic68d300baa105a4e5d14e9ea43a643c975ee7afa
---
 core/java/android/widget/AlphaLinearLayout.java    |  106 +
 core/java/android/widget/AnalogClockWidget.java    |  180 ++
 core/java/android/widget/BounceCoverFlow.java      |  187 ++
 core/java/android/widget/BounceGallery.java        | 2082 ++++++++++++++++++++
 core/java/android/widget/ClocksWgtAnalogClock.java |  539 +++++
 core/java/android/widget/GestureImageView.java     |  161 ++
 .../widget/MTKMultiAutoCompleteTextView.java       |   74 +
 .../android/widget/ScreenStateChangeListener.java  |   63 +
 core/java/android/widget/Utils.java                |  177 ++
 core/java/android/widget/WeatherAnimateView.java   |  171 ++
 10 files changed, 3740 insertions(+)
 create mode 100644 core/java/android/widget/AlphaLinearLayout.java
 create mode 100644 core/java/android/widget/AnalogClockWidget.java
 create mode 100644 core/java/android/widget/BounceCoverFlow.java
 create mode 100644 core/java/android/widget/BounceGallery.java
 create mode 100644 core/java/android/widget/ClocksWgtAnalogClock.java
 create mode 100644 core/java/android/widget/GestureImageView.java
 create mode 100644 core/java/android/widget/MTKMultiAutoCompleteTextView.java
 create mode 100644 core/java/android/widget/ScreenStateChangeListener.java
 create mode 100644 core/java/android/widget/Utils.java
 create mode 100644 core/java/android/widget/WeatherAnimateView.java

diff --git a/core/java/android/widget/AlphaLinearLayout.java b/core/java/android/widget/AlphaLinearLayout.java
new file mode 100644
index 0000000..5a1a30e
--- /dev/null
+++ b/core/java/android/widget/AlphaLinearLayout.java
@@ -0,0 +1,106 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package android.widget;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.animation.AlphaAnimation;
+import android.view.animation.Animation;
+import android.widget.RemoteViews.RemoteView;
+
+
+/**
+ * @hide
+ */
+@RemoteView
+public class AlphaLinearLayout extends LinearLayout {
+
+    // private static final Animation ANIMATION0 = new AlphaAnimation(0, 0.2f);
+    // private static final Animation ANIMATION1 = new AlphaAnimation(0.2f,
+    // 0.4f);
+    // private static final Animation ANIMATION2 = new AlphaAnimation(0.4f,
+    // 0.6f);
+    // private static final Animation ANIMATION3 = new AlphaAnimation(0.6f,
+    // 0.8f);
+    // private static final Animation ANIMATION4 = new AlphaAnimation(0.8f, 1f);
+
+    private static final Animation ANIMATION = new AlphaAnimation(0.2f, 1f);
+
+    public AlphaLinearLayout(Context context) {
+        super(context);
+        init();
+    }
+
+    public AlphaLinearLayout(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    @android.view.RemotableViewMethod
+    public void startAlpha(int alph) {
+        // switch(alph){
+        // case 0: startAnimation(ANIMATION0);break;
+        // case 1: startAnimation(ANIMATION1);break;
+        // case 2: startAnimation(ANIMATION2);break;
+        // case 3: startAnimation(ANIMATION3);break;
+        // case 4: startAnimation(ANIMATION4);break;
+        // default:
+        // break;
+        // }
+        startAnimation(ANIMATION);
+    }
+
+    private void init() {
+        // Util.check();
+        // ANIMATION0.setDuration(200);
+        // ANIMATION1.setDuration(200);
+        // ANIMATION2.setDuration(200);
+        // ANIMATION3.setDuration(200);
+        // ANIMATION4.setDuration(200);
+        // ANIMATION0.setFillAfter(true);
+        // ANIMATION1.setFillAfter(true);
+        // ANIMATION2.setFillAfter(true);
+        // ANIMATION3.setFillAfter(true);
+        // ANIMATION4.setFillAfter(true);
+        // ANIMATION0.setFillBefore(true);
+        // ANIMATION1.setFillBefore(true);
+        // ANIMATION2.setFillBefore(true);
+        // ANIMATION3.setFillBefore(true);
+        // ANIMATION4.setFillBefore(true);
+        ANIMATION.setDuration(800);
+    }
+
+}
diff --git a/core/java/android/widget/AnalogClockWidget.java b/core/java/android/widget/AnalogClockWidget.java
new file mode 100644
index 0000000..9297f4f
--- /dev/null
+++ b/core/java/android/widget/AnalogClockWidget.java
@@ -0,0 +1,180 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package android.widget;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.BroadcastReceiver;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.os.Handler;
+import android.text.format.DateUtils;
+import android.text.format.Time;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.RemoteViews.RemoteView;
+
+import java.util.TimeZone;
+
+/**
+ * @hide
+ */
+@RemoteView
+public class AnalogClockWidget extends View {
+
+    private final float mDensity;
+    private final Paint mPaint = new Paint();
+    private static final float STROKE_WIDTH = 4f;
+    private static final float STROKE_WIDTH_MS = 3f;
+    private static final float HOUR_RADIUS_SCALE = 0.5f;
+    private static final float MINUTE_RADIUS_SCALE = 0.8f;
+    private static final float OFFSET_RADIUS_SCALE = 0.1f;
+    private static final float RADIUS_SCALE = 0.9f;
+
+    private Time mCalendar;
+    private float mMinutes;
+    private float mHour;
+
+    private boolean mAttached;
+    private final Handler mHandler = new Handler();
+
+    public AnalogClockWidget(Context context) {
+        this(context, null);
+    }
+
+    public AnalogClockWidget(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public AnalogClockWidget(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        mDensity = context.getResources().getDisplayMetrics().density;
+        mCalendar = new Time();
+        mPaint.setStyle(Style.STROKE);
+        mPaint.setStrokeWidth(STROKE_WIDTH * mDensity);
+        mPaint.setColor(Color.WHITE);
+        mPaint.setAntiAlias(true);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        int x = (mRight - mLeft) / 2;
+        int y = (mBottom - mTop) / 2;
+        float radius = Math.min(x, y) * RADIUS_SCALE;
+
+        mPaint.setStrokeWidth(STROKE_WIDTH * mDensity);
+        canvas.drawCircle(x, y, radius, mPaint);
+
+        mPaint.setStrokeWidth(STROKE_WIDTH_MS * mDensity);
+        canvas.save();
+        canvas.rotate(mHour / 12.0f * 360.0f, x, y);
+        canvas.drawLine(x, y + (radius * OFFSET_RADIUS_SCALE),
+                x, y - (radius * HOUR_RADIUS_SCALE), mPaint);
+        canvas.restore();
+
+        canvas.save();
+        canvas.rotate(mMinutes / 60.0f * 360.0f, x, y);
+        canvas.drawLine(x, y + (radius * OFFSET_RADIUS_SCALE),
+                x, y - (radius * MINUTE_RADIUS_SCALE), mPaint);
+        canvas.restore();
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        if (!mAttached) {
+            mAttached = true;
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_TIME_TICK);
+            filter.addAction(Intent.ACTION_TIME_CHANGED);
+            filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+            getContext().registerReceiverAsUser(mIntentReceiver,
+                    android.os.Process.myUserHandle(), filter, null, mHandler);
+        }
+
+        mCalendar = new Time();
+        onTimeChanged();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        if (mAttached) {
+            getContext().unregisterReceiver(mIntentReceiver);
+            mAttached = false;
+        }
+    }
+
+    private void onTimeChanged() {
+        mCalendar.setToNow();
+
+        int hour = mCalendar.hour;
+        int minute = mCalendar.minute;
+        int second = mCalendar.second;
+
+        mMinutes = minute + second / 60.0f;
+        mHour = hour + mMinutes / 60.0f;
+
+        updateContentDescription(mCalendar);
+    }
+
+    private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction().equals(Intent.ACTION_TIMEZONE_CHANGED)) {
+                String tz = intent.getStringExtra("time-zone");
+                mCalendar = new Time(TimeZone.getTimeZone(tz).getID());
+            }
+
+            onTimeChanged();
+            invalidate();
+        }
+    };
+
+    private void updateContentDescription(Time time) {
+        final int flags = DateUtils.FORMAT_SHOW_TIME | DateUtils.FORMAT_24HOUR;
+        String contentDescription = DateUtils.formatDateTime(mContext,
+                time.toMillis(false), flags);
+        setContentDescription(contentDescription);
+    }
+}
diff --git a/core/java/android/widget/BounceCoverFlow.java b/core/java/android/widget/BounceCoverFlow.java
new file mode 100644
index 0000000..4b64e56
--- /dev/null
+++ b/core/java/android/widget/BounceCoverFlow.java
@@ -0,0 +1,187 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package android.widget;
+
+import android.annotation.Widget;
+import android.content.Context;
+import android.graphics.Camera;
+import android.graphics.Matrix;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.animation.Transformation;
+
+import com.mediatek.xlog.Xlog;
+
+/**
+ * New added class for new common control BookmarkView.
+ *
+ * A view that shows items in a center-locked, and transform each image base on
+ * the distance between the center of child image view and center of the view,
+ * farther distance with smaller view.
+ *
+ * @hide
+ */
+@Widget
+public class BounceCoverFlow extends BounceGallery {
+    private static final String TAG = "BounceCoverFlow";
+    private static final boolean DBG = false;
+
+    private static int DEFAULT_MAX_ROTATION = 60;
+    private static float DEFAULT_MAX_ZOOM = 400.0f;
+
+    private int mMaxRotationAngle = DEFAULT_MAX_ROTATION;
+    private float mMaxZoom = DEFAULT_MAX_ZOOM;
+
+    private final Camera mCamera = new Camera();
+
+    public BounceCoverFlow(Context context) {
+        this(context, null);
+    }
+
+    public BounceCoverFlow(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public BounceCoverFlow(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        setStaticTransformationsEnabled(true);
+    }
+
+    /**
+     * Get center of the cover flow.
+     *
+     * @return
+     */
+    private int getCenterOfCoverflow() {
+        return ((getMeasuredWidth() - mPaddingLeft - mPaddingRight) >> 1) + mPaddingLeft;
+    }
+
+    /**
+     * Set max zoom out value.
+     *
+     * @param maxZoom controls the maximum zoom of the central image
+     */
+    public void setMaxZoomOut(final float maxZoom) {
+        mMaxZoom = maxZoom;
+    }
+
+    /**
+     * Set max rotation angle, it must be bigger than 0.
+     *
+     * @param maxAngle
+     */
+    public void setMaxRotationAngle(final int maxAngle) {
+        mMaxRotationAngle = maxAngle;
+    }
+
+    @Override
+    protected boolean getChildStaticTransformation(View child, Transformation t) {
+        final int childCenter = getCenterOfChildWithScroll(child);
+        final int childWidth = child.getWidth();
+        int rotationAngle = 0;
+
+        t.clear();
+        t.setTransformationType(Transformation.TYPE_MATRIX);
+
+        if (childCenter == getCenterOfCoverflow()) {
+            transformImageBitmap(child, t, 0);
+        } else { // other images
+            int distToCenter = getCenterOfCoverflow() - childCenter;
+            rotationAngle = (int) Math.abs((((float) distToCenter / childWidth) * mMaxRotationAngle));
+            if (DBG) {
+                Xlog.d(TAG, "getChildStaticTransformation: distToCenter = " + distToCenter
+                        + ",childCenter = " + childCenter + ",center cover flow = "
+                        + getCenterOfCoverflow() + ",rotationAngle = " + rotationAngle
+                        + ",mScrollX = " + mScrollX + ",child = " + child);
+            }
+            if (rotationAngle > mMaxRotationAngle) {
+                rotationAngle = mMaxRotationAngle;
+            }
+            transformImageBitmap(child, t, rotationAngle);
+        }
+
+        return true;
+    }
+
+    /**
+     * Transform image bitmap, zoom the child, first move the center of the
+     * child to (0, 0), then translate the child in Z-axis, restore the center
+     * of child to (width/2, height/2) at last.
+     *
+     * @param child the transformed child.
+     * @param t
+     * @param rotation the coefficient of rotate angle.
+     */
+    private void transformImageBitmap(final View child, final Transformation t, final int rotationAngle) {
+        if (DBG) {
+            Xlog.d(TAG, "transformImageBitmap: rotation " + rotationAngle);
+        }
+
+        mCamera.save();
+
+        final Matrix imageMatrix = t.getMatrix();
+        final int imageHeight = child.getHeight();
+        final int imageWidth = child.getWidth();
+
+        final float zoomAmount = rotationAngle * Math.abs((float) mMaxZoom / mMaxRotationAngle);
+        if (DBG) {
+            Xlog.d(TAG, "transformImageBitmap: zoomAmount " + zoomAmount + ",rotationAngle = "
+                    + rotationAngle + ",child = " + child);
+        }
+
+        mCamera.translate(0.0f, 0.0f, zoomAmount);
+        mCamera.getMatrix(imageMatrix);
+
+        imageMatrix.preTranslate(-((imageWidth) / 2), -(imageHeight / 2));
+        imageMatrix.postTranslate(((imageWidth) / 2), (imageHeight / 2));
+
+        mCamera.restore();
+    }
+
+    /**
+     * Utility to keep mNextSelectedPosition and mNextSelectedRowId in sync
+     *
+     * @param position Intended value for mSelectedPosition the next time we go
+     * through layout
+     *
+     * @hide
+     */
+    public void setNextSelectedPositionInt(int position) {
+        super.setNextSelectedPositionInt(position);
+    }
+}
diff --git a/core/java/android/widget/BounceGallery.java b/core/java/android/widget/BounceGallery.java
new file mode 100644
index 0000000..4d9dbca
--- /dev/null
+++ b/core/java/android/widget/BounceGallery.java
@@ -0,0 +1,2082 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.widget;
+
+import android.annotation.Widget;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Rect;
+import android.os.Handler;
+import android.util.AttributeSet;
+import android.view.Gravity;
+import android.view.HapticFeedbackConstants;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.VelocityTracker;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.SoundEffectConstants;
+import android.view.ContextMenu.ContextMenuInfo;
+import android.view.animation.Transformation;
+import android.view.WindowManager;
+
+import com.android.internal.R;
+
+import com.mediatek.xlog.Xlog;
+
+/**
+ * New added class for new common control BookmarkView.
+ *
+ * A view the same as Gallery except adding overscroll effect when moving it, not change
+ * code in the origin gallery because CTS issue, remove multi touch and long press related code.
+ *
+ * @hide
+ */
+@Widget
+public class BounceGallery extends AbsSpinner {
+    private static final String TAG = "BounceGallery";
+    private static final boolean DBG = true;
+    private static final boolean DBG_MOTION = true;
+    private static final boolean DBG_KEY = true;
+    private static final boolean DBG_LAYOUT = true;
+
+    private static final int OVER_DIST_SCALED_RAT = 3;
+    private static final float DEFAULT_UNSELECTED_ALPHA = 0.5f;
+
+    /**
+     * Indicates that we are not in the middle of a touch gesture
+     */
+    private static final int TOUCH_MODE_REST = -1;
+
+    /**
+     * Indicates we just received the touch event and we are waiting to see if the it is a tap or a
+     * scroll gesture.
+     */
+    private static final int TOUCH_MODE_DOWN = 0;
+
+    /**
+     * Indicates the touch gesture is a scroll
+     */
+    private static final int TOUCH_MODE_SCROLL = 1;
+
+    /**
+     * Indicates the view is in the process of being flung
+     */
+    private static final int TOUCH_MODE_FLING = 2;
+
+    /**
+     * Indicates the touch gesture is an overscroll - a scroll beyond the beginning or end.
+     */
+    private static final int TOUCH_MODE_OVERSCROLL = 3;
+
+    /**
+     * Indicates the view is being flung outside of normal content bounds
+     * and will spring back.
+     */
+    private static final int TOUCH_MODE_OVERFLING = 4;
+
+    private int mTouchMode = TOUCH_MODE_REST;
+
+    /**
+     * Horizontal spacing between items.
+     */
+    private int mSpacing;
+
+    /**
+     * How long the transition animation should run when a child view changes
+     * position, measured in milliseconds.
+     */
+    private int mAnimationDuration = 400;
+
+    /**
+     * The alpha of items that are not selected.
+     */
+    private float mUnselectedAlpha;
+
+    /**
+     * Left most edge of a child seen so far during layout.
+     */
+    private int mLeftMost;
+
+    /**
+     * Right most edge of a child seen so far during layout.
+     */
+    private int mRightMost;
+
+    private int mGravity;
+
+    /**
+     * The position of the item that received the user's down touch.
+     */
+    private int mDownTouchPosition;
+
+    /**
+     * The view of the item that received the user's down touch.
+     */
+    private View mDownTouchView;
+
+    /**
+     * The last CheckForLongPress runnable we posted, if any
+     */
+    private CheckForLongPress mPendingCheckForLongPress;
+
+    /**
+     * The last CheckForTap runnable we posted, if any
+     */
+    private Runnable mPendingCheckForTap;
+
+    private AdapterContextMenuInfo mContextMenuInfo;
+
+    /**
+     * When fling runnable runs, it resets this to false. Any method along the
+     * path until the end of its run() can set this to true to abort any
+     * remaining fling. For example, if we've reached either the leftmost or
+     * rightmost item, we will set this to true.
+     */
+    private boolean mShouldStopFling;
+
+    /**
+     * The currently selected item's child.
+     */
+    private View mSelectedChild;
+
+    /**
+     * Whether to continuously callback on the item selected listener during a
+     * fling.
+     */
+    private boolean mShouldCallbackDuringFling = true;
+
+    /**
+     * Whether to callback when an item that is not selected is clicked.
+     */
+    private boolean mShouldCallbackOnUnselectedItemClick = true;
+
+    /**
+     * If true, do not callback to item selected listener.
+     */
+    private boolean mSuppressSelectionChanged;
+
+    /**
+     * If true, we have received the "invoke" (center or enter buttons) key
+     * down. This is checked before we action on the "invoke" key up, and is
+     * subsequently cleared.
+     */
+    private boolean mReceivedInvokeKeyDown;
+
+    /**
+     * The x coord of the last motion event.
+     */
+    private int mLastMotionX;
+
+    private int mTouchSlop;
+    private int mMinimumVelocity;
+    private int mMaximumVelocity;
+    /**
+     * Maximum distance to overscroll by during edge effects
+     */
+    private int mOverscrollDistance;
+
+    /**
+     * Maximum distance to overfling during edge effects
+     */
+    private int mOverflingDistance;
+
+    private int mDistanceLeft;
+    private boolean mNeedOverscroll;
+    /**
+     * Used for determining when to cancel out of overscroll.
+     */
+    private int mDirection;
+
+    /**
+     * Determines speed during touch scrolling
+     */
+    private VelocityTracker mVelocityTracker;
+
+    private OnSelectionChangeListener mSelectionChangeListener;
+
+    /**
+     * Executes the delta scrolls from a fling or scroll movement.
+     */
+    private FlingRunnable mFlingRunnable = new FlingRunnable();
+
+    /**
+     * Sets mSuppressSelectionChanged = false. This is used to set it to false
+     * in the future. It will also trigger a selection changed.
+     */
+    private Runnable mDisableSuppressSelectionChangedRunnable = new Runnable() {
+        public void run() {
+            mSuppressSelectionChanged = false;
+            selectionChanged();
+        }
+    };
+
+    public BounceGallery(Context context) {
+        this(context, null);
+    }
+
+    public BounceGallery(Context context, AttributeSet attrs) {
+        this(context, attrs, R.attr.galleryStyle);
+    }
+
+    public BounceGallery(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+        WindowManager windowManager = (WindowManager) mContext.getSystemService(
+                Context.WINDOW_SERVICE);
+
+        final ViewConfiguration viewConfig = ViewConfiguration.get(context);
+        mOverscrollDistance = viewConfig.getScaledOverscrollDistance() / OVER_DIST_SCALED_RAT;
+        mOverflingDistance = viewConfig.getScaledOverflingDistance() / OVER_DIST_SCALED_RAT;
+
+        mTouchSlop = viewConfig.getScaledTouchSlop();
+        mMinimumVelocity = viewConfig.getScaledMinimumFlingVelocity();
+        mMaximumVelocity = viewConfig.getScaledMaximumFlingVelocity();
+        setHorizontalScrollBarEnabled(false);
+
+        // Obtain attributes set from View and use it to initialize scroll bars.
+        TypedArray a = context.obtainStyledAttributes(R.styleable.View);
+        initializeScrollbars(a);
+        a.recycle();
+
+        // Obtain attributes set from Gallery.
+        a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Gallery,
+                defStyle, 0);
+
+        int index = a.getInt(com.android.internal.R.styleable.Gallery_gravity, -1);
+        if (index >= 0) {
+            setGravity(index);
+        }
+
+        int animationDuration = a.getInt(
+                com.android.internal.R.styleable.Gallery_animationDuration, -1);
+        if (animationDuration > 0) {
+            setAnimationDuration(animationDuration);
+        }
+
+        int spacing = a.getDimensionPixelOffset(
+                com.android.internal.R.styleable.Gallery_spacing, 0);
+        setSpacing(spacing);
+
+        float unselectedAlpha = a.getFloat(
+                com.android.internal.R.styleable.Gallery_unselectedAlpha,
+                DEFAULT_UNSELECTED_ALPHA);
+        setUnselectedAlpha(unselectedAlpha);
+
+        a.recycle();
+
+        // We draw the selected item last (because otherwise the item to the right overlaps it)
+        mGroupFlags |= FLAG_USE_CHILD_DRAWING_ORDER;
+        mGroupFlags |= FLAG_SUPPORT_STATIC_TRANSFORMATIONS;
+    }
+
+    /**
+     * Whether or not to callback on any {@link #getOnItemSelectedListener()}
+     * while the items are being flinged. If false, only the final selected item
+     * will cause the callback. If true, all items between the first and the
+     * final will cause callbacks.
+     *
+     * @param shouldCallback Whether or not to callback on the listener while
+     *            the items are being flinged.
+     */
+    public void setCallbackDuringFling(boolean shouldCallback) {
+        mShouldCallbackDuringFling = shouldCallback;
+    }
+
+    /**
+     * Whether or not to callback when an item that is not selected is clicked.
+     * If false, the item will become selected (and re-centered). If true, the
+     * {@link #getOnItemClickListener()} will get the callback.
+     *
+     * @param shouldCallback Whether or not to callback on the listener when a
+     *            item that is not selected is clicked.
+     * @hide
+     */
+    public void setCallbackOnUnselectedItemClick(boolean shouldCallback) {
+        mShouldCallbackOnUnselectedItemClick = shouldCallback;
+    }
+
+    /**
+     * Sets how long the transition animation should run when a child view
+     * changes position. Only relevant if animation is turned on.
+     *
+     * @param animationDurationMillis The duration of the transition, in
+     *        milliseconds.
+     *
+     * @attr ref android.R.styleable#Gallery_animationDuration
+     */
+    public void setAnimationDuration(int animationDurationMillis) {
+        mAnimationDuration = animationDurationMillis;
+    }
+
+    /**
+     * Sets the spacing between items in a BounceGallery.
+     *
+     * @param spacing The spacing in pixels between items in the BounceGallery.
+     */
+    public void setSpacing(int spacing) {
+        mSpacing = spacing;
+    }
+
+    /**
+     * Sets the alpha of items that are not selected in the BounceGallery.
+     *
+     * @param unselectedAlpha the alpha for the items that are not selected.
+     *
+     * @attr ref android.R.styleable#Gallery_unselectedAlpha
+     */
+    public void setUnselectedAlpha(float unselectedAlpha) {
+        mUnselectedAlpha = unselectedAlpha;
+    }
+
+    @Override
+    protected boolean getChildStaticTransformation(View child, Transformation t) {
+        t.clear();
+        t.setAlpha(child == mSelectedChild ? 1.0f : mUnselectedAlpha);
+        return true;
+    }
+
+    @Override
+    protected int computeHorizontalScrollExtent() {
+        /* Only 1 item is considered to be selected. */
+        return 1;
+    }
+
+    @Override
+    protected int computeHorizontalScrollOffset() {
+        /* Current scroll position is the same as the selected position. */
+        return mSelectedPosition;
+    }
+
+    @Override
+    protected int computeHorizontalScrollRange() {
+        /* Scroll range is the same as the item count. */
+        return mItemCount;
+    }
+
+    @Override
+    protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
+        return p instanceof Gallery.LayoutParams;
+    }
+
+    @Override
+    protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
+        return new Gallery.LayoutParams(p);
+    }
+
+    @Override
+    public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
+        return new Gallery.LayoutParams(getContext(), attrs);
+    }
+
+    @Override
+    protected ViewGroup.LayoutParams generateDefaultLayoutParams() {
+        /*
+         * BounceGallery expects Gallery.LayoutParams.
+         */
+        return new Gallery.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
+                ViewGroup.LayoutParams.WRAP_CONTENT);
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        super.onLayout(changed, l, t, r, b);
+
+        /*
+         * Remember that we are in layout to prevent more layout request from
+         * being generated.
+         */
+        mInLayout = true;
+        layout(0, false);
+        mInLayout = false;
+    }
+
+    @Override
+    int getChildHeight(View child) {
+        return child.getMeasuredHeight();
+    }
+
+    /**
+     * Tracks a motion scroll. In reality, this is used to do just about any
+     * movement to items (touch scroll, arrow-key scroll, set an item as selected).
+     *
+     * @param deltaX Change in X from the previous event.
+     */
+    void trackMotionScroll(int deltaX) {
+        if (getChildCount() == 0) {
+            Xlog.d(TAG, "trackMotionScroll with no children.");
+            return;
+        }
+
+        boolean toLeft = deltaX < 0;
+
+        int limitedDeltaX = getLimitedMotionScrollAmount(toLeft, deltaX);
+        if (limitedDeltaX != deltaX) {
+            /* The above call returned a limited amount, so stop any scrolls/flings. */
+            if (mTouchMode == TOUCH_MODE_FLING) {
+                mNeedOverscroll = true;
+                mDistanceLeft = deltaX - limitedDeltaX;
+            }
+
+            if (DBG_MOTION) {
+                Xlog.d(TAG, "trackMotionScroll: may need over scroll, mTouchMode = " + mTouchMode +
+                        ",deltaX = " + deltaX + ",limitedDeltaX = " + limitedDeltaX +
+                        ",mDistanceLeft = " + mDistanceLeft + ",mFirstPosition = " + mFirstPosition);
+            }
+        }
+
+        offsetChildrenLeftAndRight(limitedDeltaX);
+
+        detachOffScreenChildren(toLeft);
+
+        if (toLeft) {
+            /* If moved left, there will be empty space on the right. */
+            fillToGalleryRight();
+        } else {
+            /* Similarly, empty space on the left. */
+            fillToGalleryLeft();
+        }
+
+        /* Clear unused views. */
+        mRecycler.clear();
+        setSelectionToCenterChild();
+        invalidate();
+    }
+
+    int getLimitedMotionScrollAmount(boolean motionToLeft, int deltaX) {
+        int extremeItemPosition = !motionToLeft ? (isRtL() ? mItemCount - 1 : 0) : (isRtL() ? 0 : mItemCount - 1);
+
+        View extremeChild = getChildAt(extremeItemPosition - mFirstPosition);
+
+        if (extremeChild == null) {
+            return deltaX;
+        }
+
+        int extremeChildCenter = getCenterOfView(extremeChild);
+        int galleryCenter = getCenterOfGallery();
+
+        if (motionToLeft) {
+            if (extremeChildCenter <= galleryCenter) {
+
+                /* The extreme child is past his boundary point! */
+                return 0;
+            }
+        } else {
+            if (extremeChildCenter >= galleryCenter) {
+
+                /* The extreme child is past his boundary point! */
+                return 0;
+            }
+        }
+
+        int centerDifference = galleryCenter - extremeChildCenter;
+
+        return motionToLeft
+                ? Math.max(centerDifference, deltaX)
+                : Math.min(centerDifference, deltaX);
+    }
+
+    /**
+     * Offset the horizontal location of all children of this view by the
+     * specified number of pixels.
+     *
+     * @param offset the number of pixels to offset
+     */
+    private void offsetChildrenLeftAndRight(int offset) {
+        for (int i = getChildCount() - 1; i >= 0; i--) {
+            getChildAt(i).offsetLeftAndRight(offset);
+        }
+    }
+
+    /**
+     * @return The center of this BounceGallery.
+     */
+    private int getCenterOfGallery() {
+        return (getWidth() - mPaddingLeft - mPaddingRight) / 2 + mPaddingLeft;
+    }
+
+    /**
+     * @return The center of the given view.
+     */
+    private static int getCenterOfView(View view) {
+        return view.getLeft() + view.getWidth() / 2;
+    }
+
+    /**
+     * Get center of the child view.
+     *
+     * @param child the child view.
+     * @return the center of the child plus the horizontal scroll value.
+     */
+    protected int getCenterOfChildWithScroll(View child) {
+        return (getCenterOfView(child) - mScrollX);
+    }
+
+    /**
+     * Detaches children that are off the screen (i.e.: Gallery bounds).
+     *
+     * @param toLeft Whether to detach children to the left of the BounceGallery, or
+     *            to the right.
+     */
+    private void detachOffScreenChildren(boolean toLeft) {
+        int numChildren = getChildCount();
+        int firstPosition = mFirstPosition;
+        int start = 0;
+        int count = 0;
+
+        if (toLeft) {
+            final int galleryLeft = mPaddingLeft;
+            View child = null;
+            for (int i = 0; i < numChildren; i++) {
+                child = getChildAt(i);
+                if (child.getRight() >= galleryLeft) {
+                    break;
+                } else {
+                    count++;
+                    mRecycler.put(firstPosition + i, child);
+                }
+            }
+        } else {
+            final int galleryRight = getWidth() - mPaddingRight;
+            View child = null;
+            for (int i = numChildren - 1; i >= 0; i--) {
+                child = getChildAt(i);
+                if (child.getLeft() <= galleryRight) {
+                    break;
+                } else {
+                    start = i;
+                    count++;
+                    mRecycler.put(firstPosition + i, child);
+                }
+            }
+        }
+
+        detachViewsFromParent(start, count);
+
+        if (toLeft) {
+            mFirstPosition += count;
+        }
+    }
+
+    /**
+     * Scrolls the items so that the selected item is in its 'slot' (its center
+     * is the gallery's center).
+     */
+    private void scrollIntoSlots() {
+        if (getChildCount() == 0 || mSelectedChild == null) return;
+
+        int selectedCenter = getCenterOfChildWithScroll(mSelectedChild);
+        int targetCenter = getCenterOfGallery();
+
+        int scrollAmount = targetCenter - selectedCenter;
+        if (DBG_MOTION) {
+            Xlog.d(TAG, "scrollIntoSlots:mSelectedChild = " + mSelectedChild + ",selectedCenter = "
+                    + selectedCenter + ",targetCenter = " + targetCenter + ",scrollAmount = " + scrollAmount);
+        }
+        if (scrollAmount != 0) {
+            mFlingRunnable.startUsingDistance(scrollAmount);
+        } else {
+            onFinishedMovement();
+        }
+    }
+
+    private void onFinishedMovement() {
+        if (DBG_MOTION) {
+            Xlog.d(TAG, "onFinishedMovement: mSelectedPosition = " + mSelectedPosition);
+        }
+        if (mSuppressSelectionChanged) {
+            mSuppressSelectionChanged = false;
+
+            /* We haven't been callbacking during the fling, so do it now. */
+            super.selectionChanged();
+        }
+
+        invalidate();
+    }
+
+    @Override
+    void selectionChanged() {
+        if (!mSuppressSelectionChanged) {
+            super.selectionChanged();
+        }
+
+        if (mSelectionChangeListener != null) {
+            mSelectionChangeListener.onSelectionChanged();
+        }
+        if (DBG_MOTION) {
+            Xlog.d(TAG, "selectionChanged mSelectedPosition = " + mSelectedPosition);
+        }
+    }
+
+    /**
+     * Looks for the child that is closest to the center and sets it as the
+     * selected child.
+     */
+    private void setSelectionToCenterChild() {
+        View selView = mSelectedChild;
+        if (mSelectedChild == null) return;
+
+        int galleryCenter = getCenterOfGallery();
+
+        // Common case where the current selected position is correct.
+        if (selView.getLeft() <= galleryCenter && selView.getRight() >= galleryCenter) {
+            return;
+        }
+
+        int closestEdgeDistance = Integer.MAX_VALUE;
+        int newSelectedChildIndex = 0;
+        for (int i = getChildCount() - 1; i >= 0; i--) {
+            View child = getChildAt(i);
+            if (child.getLeft() <= galleryCenter && child.getRight() >= galleryCenter) {
+                // This child is in the center.
+                newSelectedChildIndex = i;
+                break;
+            }
+
+            int childClosestEdgeDistance = Math.min(Math.abs(child.getLeft() - galleryCenter),
+                    Math.abs(child.getRight() - galleryCenter));
+            if (childClosestEdgeDistance < closestEdgeDistance) {
+                closestEdgeDistance = childClosestEdgeDistance;
+                newSelectedChildIndex = i;
+            }
+        }
+
+        int newPos = mFirstPosition + newSelectedChildIndex;
+        if (DBG_MOTION) {
+            Xlog.d(TAG, "setSelectionToCenterChild: newPos = " + newPos + ",newSelectedChildIndex = " +
+                    newSelectedChildIndex + ",mSelectedPosition = " + mSelectedPosition);
+        }
+
+        if (newPos != mSelectedPosition) {
+            setSelectedPositionInt(newPos);
+            setNextSelectedPositionInt(newPos);
+            checkSelectionChanged();
+        }
+    }
+
+    /**
+     * Creates and positions all views for this BounceGallery.
+     * <p>
+     * We layout rarely, most of the time {@link #trackMotionScroll(int)} takes
+     * care of repositioning, adding, and removing children.
+     *
+     * @param delta Change in the selected position. +1 means the selection is
+     *            moving to the right, so views are scrolling to the left. -1
+     *            means the selection is moving to the left.
+     */
+    @Override
+    void layout(int delta, boolean animate) {
+        int childrenLeft = mSpinnerPadding.left;
+        int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
+
+        if (mDataChanged) {
+            handleDataChanged();
+        }
+
+        /* Handle an empty bounce gallery by removing all views. */
+        if (mItemCount == 0) {
+            resetList();
+            return;
+        }
+
+        /* Update to the new selected position. */
+        if (mNextSelectedPosition >= 0) {
+            setSelectedPositionInt(mNextSelectedPosition);
+        }
+
+        /* All views go in recycler while we are in layout. */
+        recycleAllViews();
+
+        /* Clear out old views. */
+        detachAllViewsFromParent();
+
+        /*
+         * These will be used to give initial positions to views entering the
+         * bounce gallery as we scroll.
+         */
+        mRightMost = 0;
+        mLeftMost = 0;
+
+        /* Make selected view and center it. */
+
+        /*
+         * mFirstPosition will be decreased as we add views to the left later
+         * on. The 0 for x will be offset in a couple lines down.
+         */
+        mFirstPosition = mSelectedPosition;
+        View sel = makeAndAddView(mSelectedPosition, 0, 0, true);
+
+        /* Put the selected child in the center. */
+        int selectedOffset = childrenLeft + (childrenWidth / 2) - (sel.getWidth() / 2);
+        sel.offsetLeftAndRight(selectedOffset);
+
+        fillToGalleryRight();
+        fillToGalleryLeft();
+
+        /* Flush any cached views that did not get reused above. */
+        mRecycler.clear();
+
+        invalidate();
+        checkSelectionChanged();
+
+        mDataChanged = false;
+        mNeedSync = false;
+        setNextSelectedPositionInt(mSelectedPosition);
+
+        updateSelectedItemMetadata();
+    }
+
+    /**
+     * @return true if layout is RtL
+     */
+    private boolean isRtL() {
+        return getLayoutDirection() == LAYOUT_DIRECTION_RTL;
+    }
+
+    /**
+     * Fill the left space of bounce gallery with children.
+     */
+    private void fillToGalleryLeft() {
+        int itemSpacing = mSpacing;
+        int galleryLeft = mPaddingLeft;
+
+        /* Set state for initial iteration. */
+        int numChildren = getChildCount();
+        View prevIterationView = getChildAt(isRtL() ? numChildren - 1 : 0);
+        int numItems = mItemCount;
+        int curPosition = 0;
+        int curRightEdge = 0;
+
+        if (prevIterationView != null) {
+            curPosition = isRtL() ? mFirstPosition + numChildren : mFirstPosition - 1;
+            curRightEdge = prevIterationView.getLeft() - itemSpacing;
+        } else {
+            /* No children available! */
+            curPosition = isRtL() ? mItemCount - 1 : 0;
+            curRightEdge = mRight - mLeft - mPaddingRight;
+            mShouldStopFling = true;
+        }
+
+        if (DBG_LAYOUT) {
+            Xlog.d(TAG, "fillToGalleryLeft:curRightEdge = " + curRightEdge + ",galleryLeft = "
+                    + galleryLeft + ",curPosition = " + curPosition + ",mSelectedPosition = "
+                    + mSelectedPosition + ",mFirstPosition = " + mFirstPosition);
+        }
+
+        while (curRightEdge > galleryLeft && (isRtL() ? (curPosition < numItems) : (curPosition >= 0))) {
+            prevIterationView = makeAndAddView(curPosition, curPosition - mSelectedPosition,
+                    curRightEdge, false);
+
+            /* Remember some state. */
+            if (!isRtL()) mFirstPosition = curPosition;
+
+            /* Set state for next iteration. */
+            curRightEdge = prevIterationView.getLeft() - itemSpacing;
+            if (isRtL()) {
+                curPosition++;
+            } else {
+                curPosition--;
+            }
+        }
+    }
+
+    private void fillToGalleryRight() {
+        int itemSpacing = mSpacing;
+        int galleryRight = mRight - mLeft - mPaddingRight;
+        int numChildren = getChildCount();
+        int numItems = mItemCount;
+
+        if (numChildren == 0) {
+            Xlog.d(TAG, "No child when fill gallery right!");
+            return;
+        }
+        /* Set state for initial iteration. */
+        View prevIterationView = getChildAt(isRtL() ? 0 : numChildren - 1);
+
+        int curPosition = 0;
+        int curLeftEdge = 0;
+
+        if (prevIterationView != null) {
+            curPosition = isRtL() ? mFirstPosition - 1 : mFirstPosition + numChildren;
+            curLeftEdge = prevIterationView.getRight() + itemSpacing;
+        } else {
+            if (isRtL())
+                curPosition = 0;
+            else
+                mFirstPosition = curPosition = mItemCount - 1;
+
+            curLeftEdge = mPaddingLeft;
+            mShouldStopFling = true;
+        }
+
+        if (DBG_LAYOUT) {
+            Xlog.d(TAG, "fillToGalleryRight: curLeftEdge = " + curLeftEdge + ",galleryRight = "
+                    + galleryRight + ",curPosition = " + curPosition + ",mSelectedPosition = "
+                    + mSelectedPosition + ",mFirstPosition = " + mFirstPosition + ",numItems = "
+                    + numItems);
+        }
+
+        while (curLeftEdge < galleryRight && (isRtL() ? (curPosition >= 0) : (curPosition < numItems))) {
+            prevIterationView = makeAndAddView(curPosition, curPosition - mSelectedPosition,
+                    curLeftEdge, true);
+
+            if (isRtL()) mFirstPosition = curPosition;
+
+            /* Set state for next iteration. */
+            curLeftEdge = prevIterationView.getRight() + itemSpacing;
+            if (isRtL()) {
+                curPosition--;
+            } else {
+                curPosition++;
+            }
+        }
+    }
+
+    /**
+     * Obtain a view, either by pulling an existing view from the recycler or by
+     * getting a new one from the adapter. If we are animating, make sure there
+     * is enough information in the view's layout parameters to animate from the
+     * old to new positions.
+     *
+     * @param position Position in the gallery for the view to obtain
+     * @param offset Offset from the selected position
+     * @param x X-coordintate indicating where this view should be placed. This
+     *            will either be the left or right edge of the view, depending
+     *            on the fromLeft paramter
+     * @param fromLeft Are we posiitoning views based on the left edge? (i.e.,
+     *            building from left to right)?
+     * @return A view that has been added to the gallery
+     */
+    private View makeAndAddView(int position, int offset, int x, boolean fromLeft) {
+        View child = null;
+
+        if (!mDataChanged) {
+            child = mRecycler.get(position);
+            if (child != null) {
+                /* Can reuse an existing view. */
+                int childLeft = child.getLeft();
+
+                /*
+                 * Remember left and right edges of where views have been placed.
+                 */
+                mRightMost = Math.max(mRightMost, childLeft + child.getMeasuredWidth());
+                mLeftMost = Math.min(mLeftMost, childLeft);
+
+                /* Position the view. */
+                setUpChild(child, offset, x, fromLeft);
+
+                return child;
+            }
+        }
+
+        /* Nothing found in the recycler -- ask the adapter for a view. */
+        child = mAdapter.getView(position, null, this);
+
+        /* Position the view. */
+        setUpChild(child, offset, x, fromLeft);
+
+        return child;
+    }
+
+    /**
+     * Helper for makeAndAddView to set the position of a view and fill out its
+     * layout paramters.
+     *
+     * @param child The view to position
+     * @param offset Offset from the selected position
+     * @param x X-coordintate indicating where this view should be placed. This
+     *            will either be the left or right edge of the view, depending
+     *            on the fromLeft paramter
+     * @param fromLeft Are we posiitoning views based on the left edge? (i.e.,
+     *            building from left to right)?
+     */
+    private void setUpChild(View child, int offset, int x, boolean fromLeft) {
+        /*
+         * Respect layout params that are already in the view. Otherwise make
+         * some up....
+         */
+        Gallery.LayoutParams lp = (Gallery.LayoutParams) child.getLayoutParams();
+        if (lp == null) {
+            lp = (Gallery.LayoutParams) generateDefaultLayoutParams();
+        }
+
+        addViewInLayout(child, fromLeft ? (isRtL() ? 0 : -1) : (isRtL() ? -1 : 0), lp);
+
+        child.setSelected(offset == 0);
+
+        int childHeightSpec = ViewGroup.getChildMeasureSpec(mHeightMeasureSpec, mSpinnerPadding.top
+                + mSpinnerPadding.bottom, lp.height);
+        int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, mSpinnerPadding.left
+                + mSpinnerPadding.right, lp.width);
+
+        child.measure(childWidthSpec, childHeightSpec);
+
+        /* Position vertically based on gravity setting. */
+        int childTop = calculateTop(child, true);
+        int childBottom = childTop + child.getMeasuredHeight();
+
+        int childLeft = 0;
+        int childRight = 0;
+        int width = child.getMeasuredWidth();
+        if (fromLeft) {
+            childLeft = x;
+            childRight = childLeft + width;
+        } else {
+            childLeft = x - width;
+            childRight = x;
+        }
+
+        child.layout(childLeft, childTop, childRight, childBottom);
+    }
+
+    /**
+     * Figure out vertical placement based on mGravity
+     *
+     * @param child Child to place
+     * @return Where the top of the child should be
+     */
+    private int calculateTop(View child, boolean duringLayout) {
+        int myHeight = duringLayout ? getMeasuredHeight() : getHeight();
+        int childHeight = duringLayout ? child.getMeasuredHeight() : child.getHeight();
+
+        int childTop = 0;
+
+        switch (mGravity) {
+            case Gravity.TOP:
+                childTop = mSpinnerPadding.top;
+                break;
+            case Gravity.CENTER_VERTICAL:
+            int availableSpace = myHeight - mSpinnerPadding.bottom
+                    - mSpinnerPadding.top - childHeight;
+                childTop = mSpinnerPadding.top + (availableSpace / 2);
+                break;
+            case Gravity.BOTTOM:
+                childTop = myHeight - mSpinnerPadding.bottom - childHeight;
+                break;
+            default:
+                break;
+        }
+        return childTop;
+    }
+
+    /**
+     * Called when a touch event's action is MotionEvent.ACTION_UP or
+     * MotionEvent.ACTION_CANCEL.
+     */
+    void onUpOrCancel() {
+        if (DBG_MOTION) {
+            Xlog.d(TAG, "onUpOrCancel: finished = " + mFlingRunnable.mScroller.isFinished()
+                    + ",mSelectedPosition = " + mSelectedPosition + ",mVelocityTracker = "
+                    + mVelocityTracker);
+        }
+
+        removeRunnables(mPendingCheckForTap);
+        removeRunnables(mPendingCheckForLongPress);
+
+        if (mFlingRunnable.mScroller.isFinished()) {
+            scrollIntoSlots();
+        }
+
+        dispatchUnpress();
+
+        if (mVelocityTracker != null) {
+            mVelocityTracker.recycle();
+            mVelocityTracker = null;
+        }
+    }
+
+    private void dispatchPress(View child) {
+        if (child != null) {
+            child.setPressed(true);
+        }
+
+        setPressed(true);
+    }
+
+    private void dispatchUnpress() {
+        for (int i = getChildCount() - 1; i >= 0; i--) {
+            getChildAt(i).setPressed(false);
+        }
+
+        setPressed(false);
+    }
+
+    @Override
+    public void dispatchSetSelected(boolean selected) {
+        /*
+         * We don't want to pass the selected state given from its parent to its
+         * children since this widget itself has a selected state to give to its
+         * children.
+         */
+    }
+
+    @Override
+    protected void dispatchSetPressed(boolean pressed) {
+        /* Show the pressed state on the selected child. */
+        if (mSelectedChild != null) {
+            mSelectedChild.setPressed(pressed);
+        }
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        // Gallery steals all key events
+        return event.dispatch(this, null, null);
+    }
+
+    /**
+     * Handles left, right, and clicking.
+     *
+     * @see android.view.View#onKeyDown
+     */
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_DPAD_LEFT:
+                if (movePrevious()) {
+                    playSoundEffect(SoundEffectConstants.NAVIGATION_LEFT);
+                }
+                return true;
+
+            case KeyEvent.KEYCODE_DPAD_RIGHT:
+                if (moveNext()) {
+                    playSoundEffect(SoundEffectConstants.NAVIGATION_RIGHT);
+                }
+                return true;
+
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+            case KeyEvent.KEYCODE_ENTER:
+                mReceivedInvokeKeyDown = true;
+
+            // Fall through...
+            default:
+                break;
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
+    @Override
+    public boolean onKeyUp(int keyCode, KeyEvent event) {
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+            case KeyEvent.KEYCODE_ENTER:
+                if (mReceivedInvokeKeyDown && mItemCount > 0) {
+                    dispatchPress(mSelectedChild);
+                    postDelayed(new Runnable() {
+                        public void run() {
+                            dispatchUnpress();
+                        }
+                    }, ViewConfiguration.getPressedStateDuration());
+
+                    int selectedIndex = mSelectedPosition - mFirstPosition;
+                    performItemClick(getChildAt(selectedIndex), mSelectedPosition, mAdapter
+                            .getItemId(mSelectedPosition));
+                }
+
+                // Clear the flag.
+                mReceivedInvokeKeyDown = false;
+                return true;
+
+            default:
+                break;
+        }
+
+        return super.onKeyUp(keyCode, event);
+    }
+
+    private boolean movePrevious() {
+        if (mItemCount > 0 && mSelectedPosition > 0) {
+            scrollToChild(mSelectedPosition - mFirstPosition - 1);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean moveNext() {
+        if (mItemCount > 0 && mSelectedPosition < mItemCount - 1) {
+            scrollToChild(mSelectedPosition - mFirstPosition + 1);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean scrollToChild(int childPosition) {
+        View child = getChildAt(childPosition);
+        if (DBG_MOTION || DBG_KEY) {
+            Xlog.d(TAG, "scrollToChild: childPosition = " + childPosition + ",mSelectedPosition = "
+                    + mSelectedPosition + ",mFirstPosition = " + mFirstPosition + ",mScrollX = "
+                    + mScrollX + ",child = " + child);
+        }
+        if (child != null) {
+            int distance = getCenterOfGallery() - getCenterOfView(child);
+            if (DBG_MOTION || DBG_KEY) {
+                Xlog.d(TAG, "scrollToChild: childPosition = " + childPosition + ",centerGallery = "
+                        + getCenterOfGallery() + ",center view = " + getCenterOfView(child)
+                        + ",distance = " + distance);
+            }
+            mFlingRunnable.startUsingDistance(distance);
+            return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    void setSelectedPositionInt(int position) {
+        super.setSelectedPositionInt(position);
+
+        /* Updates any metadata we keep about the selected item. */
+        updateSelectedItemMetadata();
+    }
+
+    private void updateSelectedItemMetadata() {
+        View oldSelectedChild = mSelectedChild;
+
+        View child = getChildAt(mSelectedPosition - mFirstPosition);
+        if (child == null) {
+            return;
+        }
+
+        mSelectedChild = child;
+        child.setSelected(true);
+        child.setFocusable(true);
+
+        if (hasFocus()) {
+            child.requestFocus();
+        }
+
+        /*
+         * We unfocus the old child down here so the above hasFocus check
+         * returns true.
+         */
+        if (oldSelectedChild != null) {
+            /* Make sure its drawable state doesn't contain 'selected'. */
+            oldSelectedChild.setSelected(false);
+            /*
+             * Make sure it is not focusable anymore, since otherwise arrow keys
+             * can make this one be focused
+             */
+            oldSelectedChild.setFocusable(false);
+        }
+    }
+
+    /**
+     * Describes how the child views are aligned.
+     *
+     * @param gravity
+     * @attr ref android.R.styleable#Gallery_gravity
+     */
+    public void setGravity(int gravity) {
+        if (mGravity != gravity) {
+            mGravity = gravity;
+            requestLayout();
+        }
+    }
+
+    @Override
+    protected int getChildDrawingOrder(int childCount, int i) {
+        int ret = i;
+        /*
+         * Adjust the drawing order of children, like if there are 5 children
+         * 0,1,2,3,4, and 2 is the Selected, make the drawing order to be 0, 4,
+         * 1, 3, 2.
+         */
+        int selectedIndex = mSelectedPosition - mFirstPosition;
+        /* Just to be safe. */
+        if (selectedIndex < 0) return ret;
+
+        int notSymmNum = 2 * selectedIndex - childCount + 1;
+        if (notSymmNum == 0) { /* 0, 1, 2, 3, 4, and 2 is selected. */
+            ret = getSemmChildDrawingOrder(childCount, i, selectedIndex);
+        } else if (notSymmNum < 0) { /* 0, 1, 2, 3, 4, and 0 or 1 is selected, assume 1 is selected. */
+            if (i > 2 * selectedIndex) { /* 3 and 4. */
+                ret = childCount - 1 - i;
+            } else {
+                ret = getSemmChildDrawingOrder(childCount, i, selectedIndex);
+            }
+        } else { /* 0, 1, 2, 3, 4, and 3 or 4 is selected, assume 3 is selected. */
+            if (i < notSymmNum) { /* 0 and 1. */
+                ret = i;
+            } else {
+                ret = getSemmChildDrawingOrder(childCount, i, selectedIndex);
+            }
+        }
+
+        return ret;
+    }
+
+    /**
+     * Adjust the drawing order of a symmetry bounce gallery.
+     *
+     * @param childCount
+     * @param i
+     * @param selectedIndex
+     * @return
+     */
+    private int getSemmChildDrawingOrder(int childCount, int i, int selectedIndex) {
+        if (i == selectedIndex) { /* 2. */
+            return childCount - 1;
+        } else if (i >= selectedIndex) { /* 3 and 4. */
+            return childCount - ((i - selectedIndex) * 2);
+        } else { /* 0 and 1. */
+            return childCount - 1 - ((selectedIndex - i) * 2);
+        }
+    }
+
+    @Override
+    protected void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect) {
+        super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
+
+        /*
+         * The gallery shows focus by focusing the selected item. So, give focus
+         * to our selected item instead. We steal keys from our selected item
+         * elsewhere.
+         */
+        if (gainFocus && mSelectedChild != null) {
+            mSelectedChild.requestFocus(direction);
+        }
+    }
+
+    @Override
+    protected ContextMenuInfo getContextMenuInfo() {
+        return mContextMenuInfo;
+    }
+
+    @Override
+    public boolean showContextMenuForChild(View originalView) {
+        final int longPressPosition = getPositionForView(originalView);
+        if (longPressPosition < 0) {
+            return false;
+        }
+
+        final long longPressId = mAdapter.getItemId(longPressPosition);
+        return performLongPress(originalView, longPressPosition, longPressId);
+    }
+
+    @Override
+    public boolean showContextMenu() {
+        if (isPressed() && mSelectedPosition >= 0) {
+            int index = mSelectedPosition - mFirstPosition;
+            View v = getChildAt(index);
+            return performLongPress(v, mSelectedPosition, mSelectedRowId);
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+        final int action = ev.getAction();
+        final int y = (int) ev.getY();
+        final int x = (int) ev.getX();
+
+        // Do not handle data changed.
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+            Xlog.d(TAG, "onTouchEvent new mVelocityTracker = " + mVelocityTracker);
+        }
+        mVelocityTracker.addMovement(ev);
+
+        boolean handled = false;
+        int deltaX = 0;
+
+        switch (action & MotionEvent.ACTION_MASK) {
+            case MotionEvent.ACTION_DOWN: {
+                if (DBG_MOTION) {
+                    Xlog.d(TAG, "Touch down: mTouchMode = " + mTouchMode + ",x = " + x
+                            + ",mLastMotionX = " + mLastMotionX + ",mDownTouchPosition = "
+                            + mDownTouchPosition + ",mVelocityTracker = " + mVelocityTracker);
+                }
+                mLastMotionX = x;
+                handleTouchDown(x, y);
+                handled = true;
+                break;
+            }
+
+            case MotionEvent.ACTION_MOVE: {
+                deltaX = x - mLastMotionX;
+                handleTouchMove(x, y, deltaX);
+                handled = true;
+                break;
+            }
+
+            case MotionEvent.ACTION_UP: {
+                if (DBG_MOTION) {
+                    Xlog.d(TAG, "Touch up: mTouchMode = " + mTouchMode + ",mLastMotionX = "
+                            + mLastMotionX + ",x = " + x + ",deltaX = " + deltaX + ",mScrollX = "
+                            + mScrollX + ",mDownTouchPosition = " + mDownTouchPosition);
+                }
+                handleTouchUp();
+                if (mVelocityTracker != null) {
+                    mVelocityTracker.recycle();
+                    mVelocityTracker = null;
+                }
+                handled = true;
+                break;
+            }
+
+            case MotionEvent.ACTION_CANCEL: {
+                // Abnormal case, print log to record.
+                Xlog.d(TAG, "Touch cancel: mTouchMode = " + mTouchMode + ",mDownTouchView = "
+                        + mDownTouchView);
+
+                mTouchMode = TOUCH_MODE_REST;
+                if (mDownTouchView != null && mDownTouchView.isPressed()) {
+                    mDownTouchView.setPressed(false);
+                }
+                onUpOrCancel();
+                handled = true;
+                break;
+            }
+        }
+        return handled;
+    }
+
+    /**
+     * Check if we have moved far enough that it looks more like a scroll than a
+     * tap.
+     *
+     * @param deltaX
+     * @return true if it is a scroll, else false.
+     */
+    private boolean startScrollIfNeeded(int deltaX) {
+        final int distance = Math.abs(deltaX);
+        final boolean overscroll = mScrollX != 0;
+        if (DBG_MOTION) {
+            Xlog.d(TAG, "startScrollIfNeeded: distance = " + distance + ",mScrollX = " + mScrollX
+                    + ",mTouchSlop = " + mTouchSlop + ",mPendingCheckForLongPress = "
+                    + mPendingCheckForLongPress);
+        }
+        if (overscroll || distance > mTouchSlop) {
+            mTouchMode = overscroll ? TOUCH_MODE_OVERSCROLL : TOUCH_MODE_SCROLL;
+            removeRunnables(mPendingCheckForLongPress);
+            setPressed(false);
+            final View motionView = getChildAt(mDownTouchPosition - mFirstPosition);
+            if (motionView != null) {
+                motionView.setPressed(false);
+            }
+            requestDisallowInterceptTouchEvent(true);
+            return true;
+        }
+        return false;
+    }
+
+    private void handleTouchDown(final int x, final int y) {
+        switch (mTouchMode) {
+            case TOUCH_MODE_OVERFLING: {
+                mFlingRunnable.stop(false);
+                if (mScrollX == 0) {
+                    mTouchMode = TOUCH_MODE_SCROLL;
+                } else {
+                    mTouchMode = TOUCH_MODE_OVERSCROLL;
+                }
+                break;
+            }
+
+            case TOUCH_MODE_FLING: {
+                mTouchMode = TOUCH_MODE_SCROLL;
+                /* Get the item's view that was touched. */
+                mDownTouchPosition = pointToPosition((int) x, (int) y);
+                if (mDownTouchPosition >= 0) {
+                    mDownTouchView = getChildAt(mDownTouchPosition - mFirstPosition);
+                    mDownTouchView.setPressed(true);
+                }
+                break;
+            }
+
+            default: {
+                /* Reset the multiple-scroll tracking state. */
+                mTouchMode = TOUCH_MODE_DOWN;
+
+                /* Get the item's view that was touched. */
+                mDownTouchPosition = pointToPosition((int) x, (int) y);
+                if (mDownTouchPosition >= 0) {
+                    mDownTouchView = getChildAt(mDownTouchPosition - mFirstPosition);
+                    mDownTouchView.setPressed(true);
+                }
+
+                if (mPendingCheckForTap == null) {
+                    mPendingCheckForTap = new CheckForTap();
+                }
+                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
+                break;
+            }
+        }
+    }
+
+    private void handleTouchMove(final int x, final int y, int deltaX) {
+        switch (mTouchMode) {
+            case TOUCH_MODE_DOWN: {
+                if (DBG_MOTION) {
+                    Xlog.d(TAG, "Touch move from touch down: mLastMotionX = " + mLastMotionX
+                            + ",x = " + x + ",mDownTouchPosition = " + mDownTouchPosition
+                            + ",deltaX = " + deltaX + ",mVelocityTracker = " + mVelocityTracker);
+                }
+                /*
+                 * Check if we have moved far enough that it looks more like a
+                 * scroll than a tap.
+                 */
+                startScrollIfNeeded(deltaX);
+                break;
+            }
+
+            case TOUCH_MODE_SCROLL: {
+                if (x != mLastMotionX) {
+                    trackMotionScroll((int) deltaX);
+
+                    int firstPosition = mFirstPosition;
+                    int lastPosition = firstPosition + getChildCount();
+                    /*
+                     * If the gallery has fling to the edge when scrolling, set
+                     * touch mode to overscroll mode.
+                     */
+
+                    if (isRtL()) {
+                         if (deltaX < 0 && firstPosition == 0
+                                && getCenterOfView(getChildAt(0)) <= getCenterOfGallery()) {
+                            mTouchMode = TOUCH_MODE_OVERSCROLL;
+                          } else if (deltaX > 0
+                                && lastPosition == mItemCount
+                                && getCenterOfView(getChildAt(getChildCount() - 1)) >= getCenterOfGallery()) {
+                            mTouchMode = TOUCH_MODE_OVERSCROLL;
+                        }
+                    } else {
+                        if (deltaX > 0 && firstPosition == 0
+                                && getCenterOfView(getChildAt(0)) >= getCenterOfGallery()) {
+                            mTouchMode = TOUCH_MODE_OVERSCROLL;
+                        } else if (deltaX < 0
+                          && lastPosition == mItemCount
+                          && getCenterOfView(getChildAt(getChildCount() - 1)) <= getCenterOfGallery()) {
+                            mTouchMode = TOUCH_MODE_OVERSCROLL;
+                        }
+                    }
+
+                    if (DBG_MOTION) {
+                        Xlog.d(TAG, "Touch move from scroll: mTouchMode = " + mTouchMode
+                                + ",mLastMotionX = " + mLastMotionX + ",x = " + x
+                                + ",mDownTouchPosition = " + mDownTouchPosition + ",deltaX = "
+                                + deltaX + ",mFirstPosition = " + mFirstPosition
+                                + ",mVelocityTracker = " + mVelocityTracker);
+                    }
+
+                    mLastMotionX = x;
+                }
+                break;
+            }
+
+            case TOUCH_MODE_OVERSCROLL: {
+                final int oldScroll = mScrollX;
+                final int newScroll = oldScroll - deltaX;
+                int newDirection = (int) Math.signum(mScrollX);
+                boolean scrollDirectionWillChange = (oldScroll * newScroll < 0);
+
+                if (DBG_MOTION) {
+                    Xlog.d(TAG, "Touch move from over scroll: mScrollX = " + mScrollX
+                            + ",mLastMotionX = " + mLastMotionX + ",x = " + x + ",deltaX = "
+                            + deltaX + ",mDownTouchPosition = " + mDownTouchPosition
+                            + ",newScroll = " + newScroll + ",mFirstPosition = " + mFirstPosition
+                            + ", mDirection = " + mDirection + ",mVelocityTracker = "
+                            + mVelocityTracker);
+                }
+
+                if (mDirection == 0) {
+                    mDirection = newDirection;
+                }
+
+                if (mDirection != newDirection || scrollDirectionWillChange) {
+                    /*
+                     * Deal with moving left when in overscroll mode and then
+                     * moving right, first set the scroll x to zero, and then
+                     * change the touch mode to normal scroll mode.
+                     */
+                    deltaX = -newScroll;
+                    mScrollX = 0;
+
+                    /*
+                     * No need to do all this work if we're not going to move
+                     * anyway.
+                     */
+                    if (deltaX != 0) {
+                        trackMotionScroll((int) deltaX);
+                    }
+                    mTouchMode = TOUCH_MODE_SCROLL;
+                } else {
+                    /* Still in over scroll mode. */
+                    overScrollBy(-deltaX, 0, mScrollX, 0, 0, 0, mOverscrollDistance, 0, true);
+                    invalidate();
+                }
+
+                mDirection = newDirection;
+                mLastMotionX = x;
+                break;
+            }
+        }
+    }
+
+    private void handleTouchUp() {
+        switch (mTouchMode) {
+            case TOUCH_MODE_DOWN: {
+                if (mDownTouchPosition >= 0) {
+                    final View child = getChildAt(mDownTouchPosition - mFirstPosition);
+                    if (child != null && !child.hasFocusable() && child.isPressed()) {
+                        child.setPressed(false);
+                    }
+
+                    /*
+                     * An item tap should make it selected, so scroll to this
+                     * child.
+                     */
+                    scrollToChild(mDownTouchPosition - mFirstPosition);
+
+                    /*
+                     * Also pass the click so the client knows, if it wants to.
+                     */
+                    if (mShouldCallbackOnUnselectedItemClick
+                            || mDownTouchPosition == mSelectedPosition) {
+                        performItemClick(mDownTouchView, mDownTouchPosition, mAdapter
+                                .getItemId(mDownTouchPosition));
+                    }
+                }
+                break;
+            }
+
+            case TOUCH_MODE_SCROLL: {
+                if (!mShouldCallbackDuringFling) {
+                    /*
+                     * We want to suppress selection changes, so remove any
+                     * future code to set mSuppressSelectionChanged = false.
+                     */
+                    removeCallbacks(mDisableSuppressSelectionChangedRunnable);
+
+                    /* This will get reset once we scroll into slots. */
+                    if (!mSuppressSelectionChanged)
+                        mSuppressSelectionChanged = true;
+                }
+
+                final VelocityTracker flingVelocityTracker = mVelocityTracker;
+                flingVelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
+                final int velocityX = (int) flingVelocityTracker.getXVelocity(0);
+                if (DBG_MOTION) {
+                    Xlog.d(TAG, "Touch up from scroll: velocityX = " + velocityX
+                            + ",mMinimumVelocity = " + mMinimumVelocity + ",mVelocityTracker = "
+                            + mVelocityTracker);
+                }
+                /* Fling the bounce gallery. */
+                if (Math.abs(velocityX) > mMinimumVelocity) {
+                    if (mFlingRunnable == null) {
+                        mFlingRunnable = new FlingRunnable();
+                    }
+                    mFlingRunnable.startUsingVelocity((int) -velocityX);
+                } else {
+                    mTouchMode = TOUCH_MODE_REST;
+                    onUpOrCancel();
+                }
+                break;
+            }
+
+            case TOUCH_MODE_OVERSCROLL: {
+                if (mFlingRunnable == null) {
+                    mFlingRunnable = new FlingRunnable();
+                }
+
+                final VelocityTracker velocityTracker = mVelocityTracker;
+                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
+                final int initialVelocity = (int) velocityTracker.getXVelocity();
+
+                if (Math.abs(initialVelocity) > mMinimumVelocity) {
+                    mFlingRunnable.startOverfling(-initialVelocity);
+                } else {
+                    mFlingRunnable.startSpringback();
+                }
+                break;
+            }
+
+            case TOUCH_MODE_REST: {
+                /*
+                 * When touch the list item and press the key, touch mode will
+                 * change to TOUCH_MODE_REST.
+                 */
+                Xlog.d(TAG, "Touch up from TOUCH_MODE_REST: mDownTouchView = " + mDownTouchView);
+                if (mDownTouchView != null && mDownTouchView.isPressed()) {
+                    mDownTouchView.setPressed(false);
+                }
+                break;
+            }
+        }
+    }
+
+    @Override
+    protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY) {
+        if (DBG_MOTION) {
+            Xlog.d(TAG, "onOverScrolled: scrollX = " + scrollX + ",clampedX = " + clampedX
+                    + ",mScrollX = " + mScrollX);
+        }
+        if (mScrollX != scrollX) {
+            mScrollX = scrollX;
+            invalidateParentIfNeeded();
+
+            awakenScrollBars();
+        }
+    }
+
+    /**
+     * Set the distance that can be over scrolled.
+     *
+     * @param overscrollDistance the over scroll distance, should be positive value.
+     */
+    public void setOverscrollDistance(int overscrollDistance) {
+        mOverscrollDistance = overscrollDistance;
+    }
+
+    /**
+     * Set the distance that can be over fling.
+     *
+     * @param overflingDistance the over fling distance, should be positive value.
+     */
+    public void setOverflingDistance(int overflingDistance) {
+        mOverflingDistance = overflingDistance;
+    }
+
+    /**
+     * Set listener called when gallery selection changes.
+     *
+     * @param listener
+     */
+    public void setOnSelectionChangeListener(OnSelectionChangeListener listener) {
+        mSelectionChangeListener = listener;
+    }
+
+    /**
+     * Remove runnable from message queue.
+     *
+     * @param runnable
+     */
+    private void removeRunnables(Runnable runnable) {
+        final Handler handler = getHandler();
+        if (DBG) {
+            Xlog.d(TAG, "removeRunnables runnable = " + runnable + ",handler = " + handler);
+        }
+        if (handler != null) {
+            handler.removeCallbacks(runnable);
+        }
+    }
+
+    /**
+     * Set overscroll and overfling distance.
+     *
+     * @param distance
+     */
+    public void setOverScrollDistance(final int distance) {
+        mOverscrollDistance = distance;
+        mOverflingDistance = distance;
+    }
+
+    private boolean performLongPress(View view, int position, long id) {
+        boolean handled = false;
+
+        if (mOnItemLongClickListener != null) {
+            handled = mOnItemLongClickListener.onItemLongClick(this, mDownTouchView,
+                    mDownTouchPosition, id);
+        }
+
+        if (!handled) {
+            mContextMenuInfo = new AdapterContextMenuInfo(view, position, id);
+            handled = super.showContextMenuForChild(this);
+        }
+
+        if (handled) {
+            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
+        }
+
+        return handled;
+    }
+
+    final class CheckForTap implements Runnable {
+        public void run() {
+            if (DBG) {
+                Xlog.d(TAG, "CheckForTap: mTouchMode = " + mTouchMode + ",mFirstPosition = "
+                        + mFirstPosition + ",mDataChanged = " + mDataChanged
+                        + ",mDownTouchPosition = " + mDownTouchPosition + ",this = " + this);
+            }
+
+            if (mTouchMode == TOUCH_MODE_DOWN) {
+                final View child = getChildAt(mDownTouchPosition - mFirstPosition);
+                if (DBG) {
+                    Xlog.d(TAG, "CheckForTap: child = " + child + ",this = " + this);
+                }
+
+                if (child != null && !mDataChanged) {
+                    child.setPressed(true);
+                    setPressed(true);
+
+                    final int longPressTimeout = ViewConfiguration.getLongPressTimeout();
+                    final boolean longClickable = isLongClickable();
+                    if (DBG) {
+                        Xlog.d(TAG, "CheckForTap longClickable = " + longClickable
+                                + ",mFirstPosition = " + mFirstPosition + ",mDownTouchPosition = "
+                                + mDownTouchPosition + ",this = " + this);
+                    }
+
+                    if (longClickable) {
+                        if (mPendingCheckForLongPress == null) {
+                            mPendingCheckForLongPress = new CheckForLongPress();
+                        }
+                        mPendingCheckForLongPress.rememberWindowAttachCount();
+                        postDelayed(mPendingCheckForLongPress, longPressTimeout);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * A base class for Runnables that will check that their view is still
+     * attached to the original window as when the Runnable was created.
+     */
+    private class WindowRunnnable {
+        private int mOriginalAttachCount;
+
+        public void rememberWindowAttachCount() {
+            mOriginalAttachCount = getWindowAttachCount();
+        }
+
+        public boolean sameWindow() {
+            return hasWindowFocus() && getWindowAttachCount() == mOriginalAttachCount;
+        }
+    }
+
+    private class CheckForLongPress extends WindowRunnnable implements Runnable {
+        public void run() {
+            final int motionPosition = mDownTouchPosition;
+            final View child = getChildAt(motionPosition - mFirstPosition);
+            if (DBG) {
+                Xlog.d(TAG, "CheckForLongPress mTouchMode = " + mTouchMode + ",mFirstPosition = "
+                        + mFirstPosition + ",mDataChanged = " + mDataChanged
+                        + ",mDownTouchPosition = " + mDownTouchPosition + ",this = " + this);
+            }
+
+            if (child != null) {
+                final int longPressPosition = mDownTouchPosition;
+                final long longPressId = mAdapter.getItemId(mDownTouchPosition);
+
+                boolean handled = false;
+                if (sameWindow() && !mDataChanged) {
+                    handled = performLongPress(child, longPressPosition, longPressId);
+                }
+                if (handled) {
+                    mTouchMode = TOUCH_MODE_REST;
+                    setPressed(false);
+                    child.setPressed(false);
+                }
+            }
+        }
+    }
+
+    /**
+     * Responsible for fling behavior. Use {@link #startUsingVelocity(int)} to
+     * initiate a fling. Each frame of the fling is handled in {@link #run()}. A
+     * FlingRunnable will keep re-posting itself until the fling is done.
+     */
+    private class FlingRunnable implements Runnable {
+        /**
+         * Tracks the decay of a fling scroll
+         */
+        private OverScroller mScroller;
+
+        /**
+         * X value reported by mScroller on the previous fling
+         */
+        private int mLastFlingX;
+
+        private boolean mUsingDistance;
+
+        public FlingRunnable() {
+            mScroller = new OverScroller(getContext());
+        }
+
+        private void startCommon() {
+            // Remove any pending flings
+            removeCallbacks(this);
+        }
+
+        public void startUsingVelocity(int initialVelocity) {
+            mUsingDistance = false;
+            if (initialVelocity == 0) return;
+
+            startCommon();
+            if (DBG_MOTION) {
+                Xlog.d(TAG, "startUsingVelocity: initialVelocity = " + initialVelocity);
+            }
+
+            int initialX = initialVelocity < 0 ? Integer.MAX_VALUE : 0;
+            mLastFlingX = initialX;
+            mTouchMode = TOUCH_MODE_FLING;
+            mScroller.fling(initialX, 0, initialVelocity, 0,
+                    0, Integer.MAX_VALUE, 0, Integer.MAX_VALUE);
+            post(this);
+        }
+
+        public void startUsingDistance(int distance) {
+            mUsingDistance = true;
+            if (distance == 0) return;
+
+            startCommon();
+
+            if (DBG_MOTION) {
+                Xlog.d(TAG, "startUsingDistance: distance = " + distance + ",mScrollX = " + mScrollX);
+            }
+            mLastFlingX = 0;
+            mScroller.startScroll(0, 0, -distance, 0, mAnimationDuration);
+            mTouchMode = TOUCH_MODE_FLING;
+            post(this);
+        }
+
+        void startSpringback() {
+            mUsingDistance = false;
+            if (mScroller.springBack(mScrollX, 0, 0, 0, 0, 0)) {
+                mTouchMode = TOUCH_MODE_OVERFLING;
+                invalidate();
+                post(this);
+            } else {
+                mTouchMode = TOUCH_MODE_REST;
+            }
+        }
+
+        void startOverfling(int initialVelocity) {
+            mUsingDistance = false;
+            final int min = mScrollX > 0 ? Integer.MIN_VALUE : 0;
+            final int max = mScrollX > 0 ? 0 : Integer.MAX_VALUE;
+            mScroller.fling(mScrollX, 0, initialVelocity, 0, min, max, 0, 0, getWidth(), 0);
+            mTouchMode = TOUCH_MODE_OVERFLING;
+            if (DBG_MOTION) {
+                Xlog.d(TAG, "startOverfling: mScrollX = " + mScrollX + ",initialVelocity = "
+                        + initialVelocity + ", min = " + min + ",max = " + max + ",mTouchMode = "
+                        + mTouchMode);
+            }
+
+            invalidate();
+            post(this);
+        }
+
+        public void stop(boolean scrollIntoSlots) {
+            removeCallbacks(this);
+            endFling(scrollIntoSlots);
+        }
+
+        private void endFling(boolean scrollIntoSlots) {
+            if (DBG_MOTION) {
+                Xlog.d(TAG, "endFling: scrollIntoSlots = " + scrollIntoSlots + ",mTouchMode = "
+                        + mTouchMode + ",mScrollX = " + mScrollX + ",mVelocityTracker = "
+                        + mVelocityTracker);
+            }
+            /*
+             * Force the scroller's status to finished (without setting its
+             * position to the end)
+             */
+            mScroller.forceFinished(true);
+            mUsingDistance = false;
+
+            if (scrollIntoSlots) {
+                mTouchMode = TOUCH_MODE_REST;
+                scrollIntoSlots();
+            }
+        }
+
+        public void run() {
+            if (mItemCount == 0 || getChildCount() == 0) {
+                endFling(true);
+                return;
+            }
+
+            mShouldStopFling = false;
+
+            switch (mTouchMode) {
+                case TOUCH_MODE_FLING: {
+                    final OverScroller scroller = mScroller;
+                    boolean more = scroller.computeScrollOffset();
+                    final int x = scroller.getCurrX();
+
+                    /*
+                     * Flip sign to convert finger direction to list items
+                     * direction (e.g. finger moving down means list is moving
+                     * towards the top)
+                     */
+                    int delta = mLastFlingX - x;
+
+                    if (DBG_MOTION) {
+                        Xlog.d(TAG, "Before Fling run: mLastFlingX = " + mLastFlingX + ",x = " + x
+                                + ",delta = " + delta + ",more = " + more + ",mFirstPosition = "
+                                + mFirstPosition + ",current vel = " + mScroller.getCurrVelocity());
+                    }
+
+                    /*
+                     * Pretend that each frame of a fling scroll is a touch
+                     * scroll.
+                     */
+                    if (delta > 0) {
+                        /*
+                         * Moving towards the left. Use first view as
+                         * mDownTouchPosition.
+                         */
+                        mDownTouchPosition = mFirstPosition;
+
+                        /* Don't fling more than 1 screen. */
+                        delta = Math.min(getWidth() - mPaddingLeft - mPaddingRight - 1, delta);
+                    } else {
+                        /*
+                         * Moving towards the right. Use last view as
+                         * mDownTouchPosition.
+                         */
+                        int offsetToLast = getChildCount() - 1;
+                        mDownTouchPosition = mFirstPosition + offsetToLast;
+
+                        /* Don't fling more than 1 screen. */
+                        delta = Math.max(-(getWidth() - mPaddingRight - mPaddingLeft - 1), delta);
+                    }
+
+                    trackMotionScroll(delta);
+
+                    if (DBG_MOTION) {
+                        Xlog.d(TAG, "Flinging: mScrollX = " + mScrollX + ",mLastFlingX = "
+                                + mLastFlingX + ",x = " + x + ",mFirstPosition = " + mFirstPosition
+                                + ",mDownTouchPosition = " + mDownTouchPosition + ",delta = "
+                                + delta + ",mDistanceLeft = " + mDistanceLeft
+                                + ", mNeedOverscroll = " + mNeedOverscroll + ",mUsingDistance = "
+                                + mUsingDistance);
+                    }
+
+                    if (mNeedOverscroll && !mUsingDistance) {
+                        overScrollBy(-mDistanceLeft, 0, mScrollX, 0, 0, 0,
+                                mOverflingDistance, 0, false);
+                        mNeedOverscroll = false;
+                        if (more) {
+                            mScroller.notifyHorizontalEdgeReached(mScrollX, 0, mOverflingDistance);
+                            mTouchMode = TOUCH_MODE_OVERFLING;
+                            if (DBG_MOTION) {
+                                Xlog.d(TAG, "Flinging after overscroll: mScrollX = " + mScrollX
+                                        + ",mLastFlingX = " + mLastFlingX
+                                        + ",mScroller.getCurrVelocity() = "
+                                        + mScroller.getCurrVelocity());
+                            }
+                            invalidate();
+                            post(this);
+                        }
+                        break;
+                    }
+
+                    if (DBG_MOTION) {
+                        Xlog.d(TAG, "Flinging: mScrollX = " + mScrollX + ",mLastFlingX = "
+                                + mLastFlingX + ",x = " + x + ",mShouldStopFling = "
+                                + mShouldStopFling + ",more = " + more + ", mNeedOverscroll = "
+                                + mNeedOverscroll);
+                    }
+                    if (more && !mShouldStopFling) {
+                        mLastFlingX = x;
+                        post(this);
+                    } else {
+                        endFling(true);
+                    }
+                    break;
+                }
+
+                case TOUCH_MODE_OVERFLING: {
+                    final OverScroller scroller = mScroller;
+
+                    if (scroller.computeScrollOffset()) {
+                        final int scrollX = mScrollX;
+                        final int deltaX = scroller.getCurrX() - scrollX;
+                        if (DBG_MOTION) {
+                            Xlog.d(TAG, "OverFlinging: mScrollX = " + mScrollX + ",mLastFlingX = "
+                                    + mLastFlingX + ",curx = " + scroller.getCurrX()
+                                    + ",mFirstPosition = " + mFirstPosition
+                                    + ",mDownTouchPosition = " + mDownTouchPosition + ",deltaX = "
+                                    + deltaX);
+                        }
+
+                        if (overScrollBy(deltaX, 0, scrollX, 0, 0, 0, mOverflingDistance, 0, false)) {
+                            Xlog.d(TAG, "OverFlinging: startSpringback: mScrollX = " + mScrollX);
+                            startSpringback();
+                        } else {
+                            invalidate();
+                            post(this);
+                        }
+                    } else {
+                        Xlog.d(TAG, "Over fling end here, so we finish the movement: mScrollX = "
+                                + mScrollX);
+                        endFling(true);
+                    }
+                    break;
+                }
+
+                default:
+                    return;
+            }
+        }
+    }
+
+    /**
+     * Interface definition for a callback to be invoked when the selection of
+     * gallery changes.
+     */
+    public static interface OnSelectionChangeListener {
+        /**
+         * Called when the selection changes.
+         */
+        void onSelectionChanged();
+    }
+}
diff --git a/core/java/android/widget/ClocksWgtAnalogClock.java b/core/java/android/widget/ClocksWgtAnalogClock.java
new file mode 100644
index 0000000..12a7c47
--- /dev/null
+++ b/core/java/android/widget/ClocksWgtAnalogClock.java
@@ -0,0 +1,539 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package android.widget;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.BroadcastReceiver;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.RemoteViews.RemoteView;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.TimeZone;
+
+
+/**
+ * @hide
+ */
+@RemoteView
+public class ClocksWgtAnalogClock extends View implements ScreenStateChangeListener {
+
+    private Drawable mHourHand;
+
+    private Drawable mMinuteHand;
+
+    private Drawable mDial;
+
+    private Drawable mHat;
+
+    private int mDialWidth;
+
+    private int mDialHeight;
+
+    private boolean mAttached;
+
+    private final Handler mHandler = new Handler();
+
+    private float mMinutes;
+
+    private float mHour;
+
+    private boolean mChanged;
+
+    private String mTimeZone;
+
+    private Drawable mDayDial;
+
+    private Drawable mNightDial;
+
+    private Drawable mDayHourHand;
+
+    private Drawable mNightHourHand;
+
+    private Drawable mDayMinuteHand;
+
+    private Drawable mNightMinuteHand;
+
+    private Drawable mDayHat;
+
+    private Drawable mNightHat;
+
+    private static final String WEEK_FORMAT = "E";
+
+    private static final String TAG = "ClocksWgtAnalogClock";
+
+    private float mDateFontSize;
+
+    private String mDateFormatString;
+
+    private boolean mIsScreenEnter = true;
+
+    private Runnable mTicker;
+
+    public ClocksWgtAnalogClock(Context context) {
+        this(context, null);
+    }
+
+    public ClocksWgtAnalogClock(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public ClocksWgtAnalogClock(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+       // Util.check();
+
+        Resources r = mContext.getResources();
+        TypedArray a = context.obtainStyledAttributes(attrs,
+                com.android.internal.R.styleable.AnalogClock, defStyle, 0);
+
+        mDial = a.getDrawable(com.android.internal.R.styleable.AnalogClock_dial);
+        if (mDial == null) {
+            mDial = r.getDrawable(com.android.internal.R.drawable.clock_dial);
+        }
+
+        mHourHand = a.getDrawable(com.android.internal.R.styleable.AnalogClock_hand_hour);
+        if (mHourHand == null) {
+            mHourHand = r.getDrawable(com.android.internal.R.drawable.clock_hand_hour);
+        }
+
+        mMinuteHand = a.getDrawable(com.android.internal.R.styleable.AnalogClock_hand_minute);
+        if (mMinuteHand == null) {
+            mMinuteHand = r.getDrawable(com.android.internal.R.drawable.clock_hand_minute);
+        }
+        mDialWidth = mDial.getIntrinsicWidth();
+        mDialHeight = mDial.getIntrinsicHeight();
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (!mAttached) {
+            mAttached = true;
+            IntentFilter filter = new IntentFilter();
+
+            filter.addAction(Intent.ACTION_TIME_TICK);
+            filter.addAction(Intent.ACTION_TIME_CHANGED);
+            filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+            filter.addAction(Intent.ACTION_SCREEN_ON);
+
+            getContext().registerReceiver(mIntentReceiver, filter, null, mHandler);
+        }
+        onTimeChanged();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        if (mAttached) {
+            getContext().unregisterReceiver(mIntentReceiver);
+            mAttached = false;
+        }
+        Utils.onDetachedFromWindowClearUp(this);
+    }
+
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+
+        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
+        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
+
+        float hScale = 1.0f;
+        float vScale = 1.0f;
+
+        if (widthMode != MeasureSpec.UNSPECIFIED && widthSize < mDialWidth) {
+            hScale = (float) widthSize / (float) mDialWidth;
+        }
+
+        if (heightMode != MeasureSpec.UNSPECIFIED && heightSize < mDialHeight) {
+            vScale = (float) heightSize / (float) mDialHeight;
+        }
+
+        float scale = Math.min(hScale, vScale);
+
+        setMeasuredDimension(resolveSize((int) (mDialWidth * scale), widthMeasureSpec),
+                resolveSize((int) (mDialHeight * scale), heightMeasureSpec));
+    }
+
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        mChanged = true;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        boolean changed = mChanged;
+        if (changed) {
+            mChanged = false;
+        }
+
+        int availableWidth = mRight - mLeft;
+        int availableHeight = mBottom - mTop;
+
+        int x = availableWidth / 2;
+        int y = availableHeight / 2;
+
+        final Drawable dial = mDial;
+        final Drawable hat = mHat;
+        int w = dial.getIntrinsicWidth();
+        int h = dial.getIntrinsicHeight();
+        int wHat = 0;
+        int hHat = 0;
+        if (null != hat) {
+            wHat = hat.getIntrinsicWidth();
+            hHat = hat.getIntrinsicHeight();
+        }
+
+        boolean scaled = false;
+
+        if (availableWidth < w || availableHeight < h) {
+            scaled = true;
+            float scale = Math.min((float) availableWidth / (float) w, (float) availableHeight
+                    / (float) h);
+            canvas.save();
+            canvas.scale(scale, scale, x, y);
+        }
+
+        if (changed) {
+            dial.setBounds(x - (w / 2), y - (h / 2), x + (w / 2), y + (h / 2));
+        }
+        dial.draw(canvas);
+
+        drawDate(canvas, x, y);
+        if (null != mDayHat) {
+            drawWeekDay(canvas, x, y);
+        }
+
+        canvas.save();
+        canvas.rotate(mHour / 12.0f * 360.0f, x, y);
+
+        final Drawable hourHand = mHourHand;
+        if (changed) {
+            w = hourHand.getIntrinsicWidth();
+            h = hourHand.getIntrinsicHeight();
+            hourHand.setBounds(x - (w / 2), y - (h / 2), x + (w / 2), y + (h / 2));
+        }
+        hourHand.draw(canvas);
+        hourHand.setAlpha(225);
+        canvas.restore();
+
+        canvas.save();
+        canvas.rotate(mMinutes / 60.0f * 360.0f, x, y);
+
+        final Drawable minuteHand = mMinuteHand;
+        if (changed) {
+            w = minuteHand.getIntrinsicWidth();
+            h = minuteHand.getIntrinsicHeight();
+            minuteHand.setBounds(x - (w / 2), y - (h / 2), x + (w / 2), y + (h / 2));
+        }
+        minuteHand.draw(canvas);
+        minuteHand.setAlpha(225);
+        canvas.restore();
+
+        if (scaled) {
+            canvas.restore();
+        }
+
+        if (availableWidth < wHat || availableHeight < hHat) {
+            scaled = true;
+            float scale = Math.min((float) availableWidth / (float) wHat, (float) availableHeight
+                    / (float) hHat);
+            canvas.save();
+            canvas.scale(scale, scale, x, y);
+        }
+
+        if (changed) {
+            if (null != hat) {
+                hat.setBounds(x - (wHat / 2), y - (hHat / 2), x + (wHat / 2), y + (hHat / 2));
+            }
+
+        }
+        if (null != hat) {
+            hat.draw(canvas);
+        }
+
+    }
+
+    /**
+     * Draw date string on dial
+     *
+     * @param canvas the canvas.
+     * @param halfWidth half of available width of the view.
+     * @param HalfHeight half of available height of the view.
+     */
+    private void drawDate(Canvas canvas, int halfWidth, int HalfHeight) {
+        Paint paint = new Paint();
+        paint.setTextSize(mDateFontSize);
+        paint.setAntiAlias(true);
+        int hour = Integer.valueOf(getFormatStr("k"));
+        if (hour > 5 && hour < 18) {
+            paint.setColor(Color.BLACK);
+        } else {
+            paint.setColor(Color.WHITE);
+        }
+        Rect rect = new Rect();
+        String string = null;
+        string = this.getFormatStr(mDateFormatString);
+        if (string != null) {
+            paint.getTextBounds(string, 0, string.length(), rect);
+            canvas.drawText(string, (float) (halfWidth - rect.width() / 2.0),
+                    (float) (HalfHeight - rect.height() / 2.0) + (HalfHeight * 2.0f / 4.0f), paint);
+        }
+    }
+
+    /**
+     * Draw weekday string on dial
+     *
+     * @param canvas the canvas.
+     * @param halfWidth half of available width of the view.
+     * @param HalfHeight half of available height of the view.
+     */
+    private void drawWeekDay(Canvas canvas, int halfWidth, int HalfHeight) {
+        Paint paint = new Paint();
+        paint.setTextSize(mDateFontSize);
+        paint.setAntiAlias(true);
+        int hour = Integer.valueOf(getFormatStr("k"));
+        if (hour > 5 && hour < 18) {
+            paint.setColor(Color.BLACK);
+        } else {
+            paint.setColor(Color.WHITE);
+        }
+        Rect rect = new Rect();
+        String string = null;
+        string = this.getFormatStr(WEEK_FORMAT);
+        if (string != null) {
+            paint.getTextBounds(string, 0, string.length(), rect);
+            canvas.drawText(string,
+                    (float) (halfWidth - rect.width() / 2.0f - halfWidth * 1.6f / 4.0f),
+                    (float) (HalfHeight) + rect.height() / 2.0f, paint);
+        }
+    }
+
+    /**
+     * Get a time string according to the formatter and timezone.
+     *
+     * @param format format string.
+     * @return a timezone's time string when the mTimeZone is not null, else
+     *         return current timezone's time string.
+     */
+    private String getFormatStr(String format) {
+        if (mTimeZone != null) {
+            if (format != null) {
+                java.text.SimpleDateFormat sdf = new SimpleDateFormat(format);
+                sdf.setTimeZone(TimeZone.getTimeZone(mTimeZone));
+                return sdf.format(new Date());
+            }
+        } else {
+            if (format != null) {
+                java.text.SimpleDateFormat sdf = new SimpleDateFormat(format);
+                return sdf.format(new Date());
+            }
+        }
+        return null;
+    }
+
+    /**
+     * When time is changed,we can call this method to refresh data.
+     */
+    private void onTimeChanged() {
+        int hour = Integer.valueOf(getFormatStr("h"));
+        int minute = Integer.valueOf(getFormatStr("m"));
+        int second = Integer.valueOf(getFormatStr("s"));
+        mMinutes = minute + second / 60.0f;
+        mHour = hour + mMinutes / 60.0f;
+
+        if (null == mDayHat) {
+            mChanged = true;
+            return;
+        }
+
+        int hour24 = Integer.valueOf(getFormatStr("k"));
+        if (hour24 > 5 && hour24 < 18) {
+            if (null != mDayDial) {
+                mDial = mDayDial;
+            }
+
+            if (null != mDayHourHand) {
+                mHourHand = mDayHourHand;
+            }
+
+            if (null != mDayMinuteHand) {
+                mMinuteHand = mDayMinuteHand;
+            }
+            if (null != mDayHat) {
+                mHat = mDayHat;
+            }
+
+        } else {
+            if (null != mNightDial) {
+                mDial = mNightDial;
+            }
+
+            if (null != mNightHourHand) {
+                mHourHand = mNightHourHand;
+            }
+
+            if (null != mNightMinuteHand) {
+                mMinuteHand = mNightMinuteHand;
+            }
+
+            if (null != mNightHat) {
+                mHat = mNightHat;
+            }
+
+        }
+
+        mChanged = true;
+    }
+
+    /**
+     * A receiver to listening to the change of time and screen on,then
+     * invalidate the view.
+     */
+    private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            if (!mIsScreenEnter) {
+                return;
+            }
+            onTimeChanged();
+            invalidate();
+        }
+    };
+
+    @android.view.RemotableViewMethod
+    public void setTimeZone(String zoneStr) {
+        mTimeZone = zoneStr;
+        onTimeChanged();
+    }
+
+    @android.view.RemotableViewMethod
+    public void setDayDialResource(int resid) {
+        Resources r = getResources();
+        mDayDial = r.getDrawable(resid);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setNightDialResource(int resid) {
+        Resources r = getResources();
+        mNightDial = r.getDrawable(resid);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setDayHourResource(int resid) {
+        Resources r = getResources();
+        mDayHourHand = r.getDrawable(resid);
+
+    }
+
+    @android.view.RemotableViewMethod
+    public void setNightHourResource(int resid) {
+        Resources r = getResources();
+        mNightHourHand = r.getDrawable(resid);
+
+    }
+
+    @android.view.RemotableViewMethod
+    public void setDayMinuteResource(int resid) {
+        Resources r = getResources();
+        mDayMinuteHand = r.getDrawable(resid);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setNightMinuteResource(int resid) {
+        Resources r = getResources();
+        mNightMinuteHand = r.getDrawable(resid);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setDayHatResource(int resid) {
+        Resources r = getResources();
+        mDayHat = r.getDrawable(resid);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setNightHatResource(int resid) {
+        Resources r = getResources();
+        mNightHat = r.getDrawable(resid);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setDateFontSize(int i) {
+        mDateFontSize = this.getResources().getDimension(i);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setDateHeight(int i) {
+        // mDateHeight = this.getResources().getDimension(i);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setDateFormatString(int i) {
+        mDateFormatString = getContext().getString(i);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setOnTimeChanged(int i) {
+        onTimeChanged();
+    }
+
+    public void onScreenStateChanged(int screen, int state) {
+        if (ScreenStateChangeListener.SCREEN_ENTER == state) {
+            mIsScreenEnter = true;
+            mTicker = new Runnable() {
+                public void run() {
+                    onTimeChanged();
+                    invalidate();
+                }
+            };
+            mHandler.post(mTicker);
+        } else {
+            mIsScreenEnter = false;
+        }
+    }
+}
diff --git a/core/java/android/widget/GestureImageView.java b/core/java/android/widget/GestureImageView.java
new file mode 100644
index 0000000..26c41bb
--- /dev/null
+++ b/core/java/android/widget/GestureImageView.java
@@ -0,0 +1,161 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package android.widget;
+
+import android.content.Context;
+import android.content.Intent;
+import android.util.AttributeSet;
+import android.view.GestureDetector;
+import android.view.MotionEvent;
+import android.widget.RemoteViews.RemoteView;
+import android.appwidget.AppWidgetManager;
+import android.os.SystemClock;
+
+
+/**
+ * @hide
+ */
+@RemoteView
+public class GestureImageView extends ImageView implements
+        GestureDetector.OnGestureListener {
+
+    private static final String TAG = "GestureImageView";
+    private GestureDetector gestureDetector;
+    private int mAppWidgetId;
+    private static final String ACTION_SCROLL = "com.weather.action.SCROLL";
+    private static final String ACTION_WEATHER_SETTING = "com.weather.action.SETTING";
+    private static final String DIRECTION = "Dircetion";
+    private static final String DIRECTION_NEXT = "direction_next";
+    private static final String DIRECTION_PREVIOUS = "direction_previous";
+    private long sendTime;
+
+    public GestureImageView(Context context) {
+        super(context);
+        init(context);
+    }
+
+    public GestureImageView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context);
+    }
+
+    public GestureImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(context);
+    }
+
+    @android.view.RemotableViewMethod
+    public void setWidgetId(int widgetId) {
+        mAppWidgetId = widgetId;
+    }
+
+    private void init(Context context) {
+        gestureDetector = new GestureDetector(context, this);
+
+    }
+
+    public boolean onTouchEvent(MotionEvent event) {
+        return gestureDetector.onTouchEvent(event);
+
+    }
+
+    public boolean onDown(MotionEvent e) {
+        return true;
+    }
+
+    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
+            float velocityY) {
+        if (SystemClock.elapsedRealtime() - sendTime < 1000) {
+            return true;
+        }
+        Intent intent = new Intent(ACTION_SCROLL);
+        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
+        if (velocityY > 0) {
+            intent.putExtra(DIRECTION, DIRECTION_NEXT);
+        } else {
+            intent.putExtra(DIRECTION, DIRECTION_PREVIOUS);
+        }
+        getContext().sendBroadcast(intent);
+        sendTime = SystemClock.elapsedRealtime();
+        return true;
+    }
+
+    public void onLongPress(MotionEvent e) {
+
+    }
+
+    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,
+            float distanceY) {
+
+        if (SystemClock.elapsedRealtime() - sendTime < 1000) {
+            return true;
+        }
+        float x = Math.abs(distanceX);
+        float y = Math.abs(distanceY);
+        if (x > y) {
+            return true;
+        }
+        getParent().requestDisallowInterceptTouchEvent(true);
+        if (x > 5 && y > 7) {
+            Intent intent = new Intent(ACTION_SCROLL);
+            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
+            if (distanceY < 0) {
+                intent.putExtra(DIRECTION, DIRECTION_NEXT);
+            } else {
+                intent.putExtra(DIRECTION, DIRECTION_PREVIOUS);
+            }
+            getContext().sendBroadcast(intent);
+            sendTime = SystemClock.elapsedRealtime();
+            return true;
+        }
+        return false;
+    }
+
+    public void onShowPress(MotionEvent e) {
+
+    }
+
+    public boolean onSingleTapUp(MotionEvent e) {
+        //Add for WeatherClockWidget
+        Intent intent = new Intent(ACTION_WEATHER_SETTING);
+        intent.addCategory(Intent.CATEGORY_DEFAULT);
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        getContext().startActivity(intent);
+
+        return false;
+    }
+
+}
+
diff --git a/core/java/android/widget/MTKMultiAutoCompleteTextView.java b/core/java/android/widget/MTKMultiAutoCompleteTextView.java
new file mode 100644
index 0000000..b343cf6
--- /dev/null
+++ b/core/java/android/widget/MTKMultiAutoCompleteTextView.java
@@ -0,0 +1,74 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package android.widget;
+
+import android.content.Context;
+import android.util.AttributeSet;
+
+/**
+ * An editable text view, extending {@link MultiAutoCompleteTextView}, that
+ * can show completion suggestions for the substring of the text where
+ * the user is typing instead of necessarily for the entire thing.
+ *
+ * Main objective of this class is to let class out of android.widget package
+ * can call APIs in TextView which didn't publish.
+ *
+ * @hide
+ */
+
+public class MTKMultiAutoCompleteTextView extends MultiAutoCompleteTextView {
+
+    public MTKMultiAutoCompleteTextView(Context context) {
+        super(context);
+    }
+
+    public MTKMultiAutoCompleteTextView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public MTKMultiAutoCompleteTextView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+    }
+
+    public final void mtkSetShowSoftInputOnFocus(boolean show) {
+        super.setShowSoftInputOnFocus(show);
+    }
+
+    public int mtkGetMaxLines() {
+        return super.getMaxLines();
+    }
+}
+
diff --git a/core/java/android/widget/ScreenStateChangeListener.java b/core/java/android/widget/ScreenStateChangeListener.java
new file mode 100644
index 0000000..8fe1901
--- /dev/null
+++ b/core/java/android/widget/ScreenStateChangeListener.java
@@ -0,0 +1,63 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package android.widget;
+
+import android.view.View;
+
+/**
+ * Screen state change events' callback.
+ *
+ * @author Xin Gang Sun
+ * @hide
+ */
+public interface ScreenStateChangeListener {
+    /** Enter the screen. */
+    int SCREEN_ENTER = View.VISIBLE;
+    /** Leave the screen. */
+    int SCREEN_LEAVE = View.INVISIBLE;
+    /** Pass the screen when distance switch. */
+    @Deprecated
+    int SCREEN_PASS = View.GONE;
+
+    /**
+     * Calls when the state of screen which the view in changed.
+     *
+     * @param screen the screen number, from 0 to count - 1.
+     * @param state the state value, MUST be SCREEN_ENTER, SCREEN_LEAVE
+     *              or SCREEN_PASS.
+     */
+    void onScreenStateChanged(int screen, int state);
+}
diff --git a/core/java/android/widget/Utils.java b/core/java/android/widget/Utils.java
new file mode 100644
index 0000000..fe72987
--- /dev/null
+++ b/core/java/android/widget/Utils.java
@@ -0,0 +1,177 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package android.widget;
+
+import android.appwidget.AppWidgetHostView;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Message;
+import com.mediatek.xlog.Xlog;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewParent;
+
+
+/**
+ * @hide
+ */
+public class Utils {
+
+    private static final String TAG = "Utils";
+
+    // private static final ITelephony mITelephony =
+    // ITelephony.Stub.asInterface(ServiceManager.checkService("phone"));
+
+    /**
+     * Kick off an intent to initiate a call.
+     */
+    public static void initiateCall(Context context, CharSequence phoneNumber) {
+        Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED, Uri.fromParts("tel", phoneNumber
+                .toString(), null));
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // new add
+        context.startActivity(intent);
+    }
+
+    /**
+     * Kick off an intent to initiate an Sms/Mms message.
+     */
+    public static void initiateSms(Context context, CharSequence phoneNumber) {
+        Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.fromParts("sms", phoneNumber
+                .toString(), null));
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // new add
+        context.startActivity(intent);
+    }
+
+    /*
+     * @param context
+     * @param phone the phone number.
+     * @param sim in the dual SIM system sim == 0 or sim == 1, in the single SIM
+     * system sim == -1
+     */
+    public static void callPassSim(Context context, String phone, int sim) {
+        /*
+         * if((mITelephony != null) && ((sim == 0) || (sim == 1))){ try{
+         * mITelephony.dial(phone); }catch(Exception e){
+         * Xlog.e("MAppWidgetProvider", "callPassSm Error"); } }
+         */
+        Uri uri = Uri.fromParts("tel", phone, null);
+       // Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED, uri);
+        Intent intent = new Intent(Intent.ACTION_DIAL, uri);
+       /* if (sim != -1) {
+            if (sim == 0) {
+                intent.putExtra(Phone.GEMINI_SIM_ID_KEY, Phone.GEMINI_SIM_1);
+            } else if (sim == 1) {
+                intent.putExtra(Phone.GEMINI_SIM_ID_KEY, Phone.GEMINI_SIM_2);
+            }
+        }*/
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        context.startActivity(intent);
+    }
+    static Handler mClearBitmapHandle;
+
+    public static void onDetachedFromWindowClearUp(View view) {
+        if (mClearBitmapHandle == null) {
+            mClearBitmapHandle = new Handler() {
+                public void handleMessage(Message message) {
+                    Xlog.d(TAG, "message = " + message);
+                    if (message.obj instanceof View) {
+                        View onDetachedView = (View) message.obj;
+                        if (!hasInLancher(onDetachedView)) {
+                            ViewGroup viewParent = getWidgetHostView(onDetachedView);
+                            clearView(viewParent);
+                            Xlog.d(TAG, "clearView imageView");
+                        } else {
+                            Xlog.d(TAG, "no Remove imageView");
+                        }
+                    }
+                    //message.recycle();
+                }
+            };
+        }
+        mClearBitmapHandle.sendMessageDelayed(mClearBitmapHandle.obtainMessage(
+                0, view), 100);
+    }
+
+    public static boolean hasInLancher(View view) {
+        if (view == null) {
+            return false;
+        }
+        ViewParent viewParent = view.getParent();
+        if (viewParent == null || !(viewParent instanceof View)) {
+            return false;
+        }
+        if (viewParent.getClass().toString().indexOf("Workspace") >= 0) {
+            return true;
+        }
+        return hasInLancher((View) viewParent);
+    }
+
+    public static void clearView(View view) {
+        if (view == null) {
+            return;
+        }
+//      view.setBackgroundDrawable(null);
+        if (view instanceof ImageView) {
+//          ((ImageView)view).setImageDrawable(null);
+            return;
+        }
+        if (view instanceof ViewGroup) {
+            ViewGroup group = (ViewGroup) view;
+            for (int i = 0; i < group.getChildCount(); i++) {
+                clearView(group.getChildAt(i));
+            }
+        }
+    }
+
+    public static ViewGroup getWidgetHostView(View view) {
+        if (view == null || view.getParent() == null) {
+            return null;
+        }
+        ViewParent viewParent = view.getParent();
+        if (viewParent == null || !(viewParent instanceof View)) {
+            return null;
+        }
+        if (viewParent instanceof AppWidgetHostView) {
+            return (ViewGroup) view;
+        }
+        return getWidgetHostView((View) viewParent);
+    }
+
+
+
+}
diff --git a/core/java/android/widget/WeatherAnimateView.java b/core/java/android/widget/WeatherAnimateView.java
new file mode 100644
index 0000000..def1b7b
--- /dev/null
+++ b/core/java/android/widget/WeatherAnimateView.java
@@ -0,0 +1,171 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package android.widget;
+
+import android.animation.Animator;
+import android.animation.ObjectAnimator;
+import android.animation.Animator.AnimatorListener;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.RemoteViews.RemoteView;
+import com.mediatek.xlog.Xlog;
+
+
+/**
+ * @hide
+ */
+@RemoteView
+public class WeatherAnimateView extends RelativeLayout {
+
+    private static final String TAG = "WeatherAnimationView";
+
+    /**
+     * The property for setting the increment/decrement button alpha.
+     */
+    private static final String PROPERTY_IMAGEVIEW_ALPHA = "alpha";
+
+    /**
+     * The alpha for the increment/decrement ImageView when it is transparent.
+     */
+    private static final int IMAGEVIEW_ALPHA_TRANSPARENT = 0;
+
+    /**
+     * The alpha for the increment/decrement ImageView when it is opaque.
+     */
+    private static final int IMAGEVIEW_ALPHA_OPAQUE = 1;
+
+    private static final int ANIM_DURATION = 800;
+
+    private ImageView mOutView;
+
+    private ImageView mInView;
+
+    private Bitmap mLastRes = null;
+
+    private Animator mFadeInAnimator;
+
+    private Animator mFadeOutAnimator;
+
+    public WeatherAnimateView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        initAnimation();
+    }
+
+    public WeatherAnimateView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initAnimation();
+    }
+
+    public WeatherAnimateView(Context context) {
+        super(context);
+    }
+
+    private void initAnimation() {
+        mFadeInAnimator = ObjectAnimator.ofFloat(mInView, PROPERTY_IMAGEVIEW_ALPHA,
+                IMAGEVIEW_ALPHA_TRANSPARENT, IMAGEVIEW_ALPHA_OPAQUE);
+        mFadeInAnimator.setDuration(ANIM_DURATION);
+        mFadeOutAnimator = ObjectAnimator.ofFloat(mOutView, PROPERTY_IMAGEVIEW_ALPHA,
+                IMAGEVIEW_ALPHA_OPAQUE, IMAGEVIEW_ALPHA_TRANSPARENT);
+        mFadeOutAnimator.setDuration(ANIM_DURATION);
+    }
+
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+        Xlog.d(TAG, "onFinishInflate");
+        mOutView = (ImageView) findViewWithTag("tag_weather_out_view");
+        mInView = (ImageView) findViewWithTag("tag_weather_in_view");
+        initAnimation();
+    }
+
+    @android.view.RemotableViewMethod
+    public void setImageViewBitmap(final Bitmap res) {
+        Xlog.d(TAG, "setImageViewBitmap mLastResId = " + mLastRes + ", new res=" + res);
+        if (mLastRes == null) {
+            mLastRes = res;
+            mOutView.setVisibility(View.INVISIBLE);
+            mInView.setImageBitmap(res);
+            mInView.setVisibility(View.VISIBLE);
+            mFadeInAnimator.setTarget(mInView);
+            mFadeInAnimator.start();
+        } else {
+            ImageView tmpImageView = mOutView;
+            mOutView = mInView;
+            mInView = tmpImageView;
+            tmpImageView = null;
+            // Remove listener to avoid memory leak
+            mFadeOutAnimator.removeAllListeners();
+            mFadeOutAnimator.addListener(new AnimatorListener() {
+
+                @Override
+                public void onAnimationCancel(Animator animation) {
+                    Xlog.d(TAG, "onAnimationCancel");
+                }
+
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    Xlog.d(TAG, "onAnimationEnd");
+                    mOutView.setVisibility(View.INVISIBLE);
+                    mLastRes = res;
+                    mInView.setImageBitmap(res);
+                    mInView.setVisibility(View.VISIBLE);
+                    mFadeInAnimator.setTarget(mInView);
+                    mFadeInAnimator.start();
+                }
+
+                @Override
+                public void onAnimationRepeat(Animator animation) {
+                }
+
+                @Override
+                public void onAnimationStart(Animator animation) {
+                }
+            });
+            mOutView.setImageBitmap(mLastRes);
+            mOutView.setVisibility(View.VISIBLE);
+            mFadeOutAnimator.setTarget(mOutView);
+            mFadeOutAnimator.start();
+        }
+    }
+
+    @android.view.RemotableViewMethod
+    public void setLastRes(Bitmap res) {
+        mLastRes = res;
+    }
+}
-- 
2.9.0

