From 9d7f31e41deed944e06bfaddcf03a8bcb562e824 Mon Sep 17 00:00:00 2001
From: Yuri Konotopov <ykonotopov@gmail.com>
Date: Sun, 10 Jul 2016 22:17:58 +0300
Subject: [PATCH 2/3] MTK camera patches

Change-Id: I9d8d0c131f9b3026259a6e2f73fb4249f8f1fe32
---
 Android.mk                                         |   12 +
 core/java/android/content/Context.java             |   87 +
 core/java/android/hardware/Camera.java             | 5308 ++++++++++++++------
 .../mediatek/common/mom/BootReceiverPolicy.java    |   67 +
 .../common/mom/ICallInterceptionListener.aidl      |   54 +
 .../common/mom/IMessageInterceptListener.aidl      |   58 +
 .../common/mom/IMobileConnectionCallback.aidl      |   62 +
 .../com/mediatek/common/mom/IMobileManager.java    |  435 ++
 .../mediatek/common/mom/IMobileManagerService.aidl |  190 +
 .../mediatek/common/mom/INotificationListener.aidl |   58 +
 .../common/mom/IPackageInstallCallback.aidl        |   55 +
 .../mediatek/common/mom/IPermissionListener.aidl   |   82 +
 .../common/mom/IRequestedPermissionCallback.aidl   |   59 +
 .../com/mediatek/common/mom/MobileManager.java     |  351 ++
 .../mediatek/common/mom/MobileManagerUtils.java    |  157 +
 .../common/mom/NotificationCacheRecord.aidl        |   41 +
 .../common/mom/NotificationCacheRecord.java        |  111 +
 core/java/com/mediatek/common/mom/Permission.aidl  |   41 +
 core/java/com/mediatek/common/mom/Permission.java  |  179 +
 .../com/mediatek/common/mom/PermissionRecord.aidl  |   41 +
 .../com/mediatek/common/mom/PermissionRecord.java  |  144 +
 .../com/mediatek/common/mom/ReceiverRecord.aidl    |   41 +
 .../com/mediatek/common/mom/ReceiverRecord.java    |  121 +
 .../com/mediatek/common/mom/SubPermissions.java    |   54 +
 .../mediatek/common/mom/UserSecurityException.java |   50 +
 core/java/com/mediatek/hdmi/HdmiDef.java           |  229 +
 core/java/com/mediatek/hdmi/IMtkHdmiManager.aidl   |   56 +
 .../com/mediatek/perfservice/IPerfService.aidl     |   37 +
 .../mediatek/perfservice/IPerfServiceManager.java  |  118 +
 .../mediatek/perfservice/IPerfServiceWrapper.java  |   80 +
 .../mediatek/perfservice/PerfServiceWrapper.java   |  383 ++
 31 files changed, 7304 insertions(+), 1457 deletions(-)
 create mode 100755 core/java/com/mediatek/common/mom/BootReceiverPolicy.java
 create mode 100755 core/java/com/mediatek/common/mom/ICallInterceptionListener.aidl
 create mode 100755 core/java/com/mediatek/common/mom/IMessageInterceptListener.aidl
 create mode 100755 core/java/com/mediatek/common/mom/IMobileConnectionCallback.aidl
 create mode 100755 core/java/com/mediatek/common/mom/IMobileManager.java
 create mode 100755 core/java/com/mediatek/common/mom/IMobileManagerService.aidl
 create mode 100755 core/java/com/mediatek/common/mom/INotificationListener.aidl
 create mode 100755 core/java/com/mediatek/common/mom/IPackageInstallCallback.aidl
 create mode 100755 core/java/com/mediatek/common/mom/IPermissionListener.aidl
 create mode 100755 core/java/com/mediatek/common/mom/IRequestedPermissionCallback.aidl
 create mode 100755 core/java/com/mediatek/common/mom/MobileManager.java
 create mode 100755 core/java/com/mediatek/common/mom/MobileManagerUtils.java
 create mode 100755 core/java/com/mediatek/common/mom/NotificationCacheRecord.aidl
 create mode 100755 core/java/com/mediatek/common/mom/NotificationCacheRecord.java
 create mode 100755 core/java/com/mediatek/common/mom/Permission.aidl
 create mode 100755 core/java/com/mediatek/common/mom/Permission.java
 create mode 100755 core/java/com/mediatek/common/mom/PermissionRecord.aidl
 create mode 100755 core/java/com/mediatek/common/mom/PermissionRecord.java
 create mode 100755 core/java/com/mediatek/common/mom/ReceiverRecord.aidl
 create mode 100755 core/java/com/mediatek/common/mom/ReceiverRecord.java
 create mode 100755 core/java/com/mediatek/common/mom/SubPermissions.java
 create mode 100755 core/java/com/mediatek/common/mom/UserSecurityException.java
 create mode 100644 core/java/com/mediatek/hdmi/HdmiDef.java
 create mode 100755 core/java/com/mediatek/hdmi/IMtkHdmiManager.aidl
 create mode 100755 core/java/com/mediatek/perfservice/IPerfService.aidl
 create mode 100755 core/java/com/mediatek/perfservice/IPerfServiceManager.java
 create mode 100755 core/java/com/mediatek/perfservice/IPerfServiceWrapper.java
 create mode 100755 core/java/com/mediatek/perfservice/PerfServiceWrapper.java

diff --git a/Android.mk b/Android.mk
index 91b2a99..88be937 100755
--- a/Android.mk
+++ b/Android.mk
@@ -414,6 +414,18 @@ LOCAL_SRC_FILES += \
 	packages/services/Proxy/com/android/net/IProxyPortListener.aidl \
         telephony/java/com/android/ims/internal/IImsConfig.aidl \
 
+# AIDL files for Turnkey and BSP Package
+LOCAL_SRC_FILES += \
+    core/java/com/mediatek/common/mom/ICallInterceptionListener.aidl \
+    core/java/com/mediatek/common/mom/IMessageInterceptListener.aidl \
+    core/java/com/mediatek/common/mom/IMobileConnectionCallback.aidl \
+    core/java/com/mediatek/common/mom/IMobileManagerService.aidl \
+    core/java/com/mediatek/common/mom/INotificationListener.aidl \
+    core/java/com/mediatek/common/mom/IRequestedPermissionCallback.aidl \
+    core/java/com/mediatek/common/mom/IPackageInstallCallback.aidl \
+    core/java/com/mediatek/common/mom/IPermissionListener.aidl \
+    core/java/com/mediatek/hdmi/IMtkHdmiManager.aidl \
+    core/java/com/mediatek/perfservice/IPerfService.aidl
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
 LOCAL_AIDL_INCLUDES += $(FRAMEWORKS_BASE_JAVA_SRC_DIRS)
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index 5fdd9ee..2afa230 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -2264,6 +2264,20 @@ public abstract class Context {
      */
     public abstract Object getSystemService(@ServiceName @NonNull String name);
 
+    /**
+     * @hide
+     * M: comment @{ add AGPS service
+     */
+    public static final String MTK_AGPS_SERVICE = "mtk-agps";
+    /// @}
+
+    /// M: comment @{ add PerfService service
+    /**
+     * @hide
+     */
+    public static final String MTK_PERF_SERVICE = "mtk-perfservice";
+    /// @}
+
     /**
      * Use with {@link #getSystemService} to retrieve a
      * {@link android.os.PowerManager} for controlling power management,
@@ -2390,6 +2404,17 @@ public abstract class Context {
      */
     public static final String SEARCH_SERVICE = "search";
 
+    /**
+     * M: Use with {@link #getSystemService} to retrieve a {@link
+     * com.mediatek.search.SearchEngineManager} for handling searches.
+     *
+     * @see #getSystemService
+     * @see com.mediatek.search.SearchEngineManager
+     * @hide
+     * @internal
+     */
+    public static final String SEARCH_ENGINE_SERVICE = "search_engine";
+
     /**
      * Use with {@link #getSystemService} to retrieve a {@link
      * android.hardware.SensorManager} for accessing sensors.
@@ -2553,6 +2578,18 @@ public abstract class Context {
      */
     public static final String AUDIO_SERVICE = "audio";
 
+    /**
+     * M: Use with {@link #getSystemService} to retrieve a
+     * {@link com.mediatek.audioprofile.AudioProfileManager} for handling
+     * management of audioprofile.
+     *
+     * @see #getSystemService
+     * @see com.mediatek.audioprofile.AudioProfileManager
+     * @hide
+     * @internal
+     */
+    public static final String AUDIO_PROFILE_SERVICE = "audioprofile";
+
     /**
      * Use with {@link #getSystemService} to retrieve a
      * {@link android.service.fingerprint.FingerprintManager} for handling management
@@ -2564,6 +2601,32 @@ public abstract class Context {
      */
     public static final String FINGERPRINT_SERVICE = "fingerprint";
 
+    /**
+     * M: Use with {@link #getSystemService} to retrieve a Mobile Service
+     * for handling mobile security.
+     * @hide
+     * @internal
+     */
+    public static final String MOBILE_SERVICE = "mobile";
+
+    /**
+     * M: Use with ServiceManager.getService to retrieve a HDMI Service
+     * for handling management of HDMI.
+     *
+     * @hide
+     * @internal
+     */
+    public static final String HDMI_SERVICE = "mtkhdmi";
+    /**
+     * M: Use with Servicemanager.getService to retrieve a
+     * {@link com.mediatek.rns.RnsService} for handling
+     * management of radio network selection.
+     *
+     * @see com.mediatek.rns.RnsService
+     * @hide
+     */
+    public static final String RNS_SERVICE = "rns";
+
     /**
      * Use with {@link #getSystemService} to retrieve a
      * {@link android.media.MediaRouter} for controlling and managing
@@ -2603,6 +2666,18 @@ public abstract class Context {
      */
     public static final String TELEPHONY_SUBSCRIPTION_SERVICE = "telephony_subscription_service";
 
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.telephony.TelephonyManager} for handling management the
+     * telephony features of the device.
+     *
+     * @see #getSystemService
+     * @see android.telephony.TelephonyManagerEx
+     * @hide
+     * @internal
+     */
+    public static final String TELEPHONY_SERVICE_EX = "phoneEx";
+
     /**
      * Use with {@link #getSystemService} to retrieve a
      * {@link android.telecom.TelecomManager} to manage telecom-related features
@@ -2862,6 +2937,12 @@ public abstract class Context {
      */
     public static final String CONSUMER_IR_SERVICE = "consumer_ir";
 
+    /// M: MSG Logger Manager
+    /**
+     * @hide
+     * @internal
+     */
+    public static final String MESSAGE_MONITOR_SERVICE = "msgmonitorservice";
     /**
      * {@link android.app.trust.TrustManager} for managing trust agents.
      * @see #getSystemService
@@ -2907,6 +2988,12 @@ public abstract class Context {
      */
     public static final String JOB_SCHEDULER_SERVICE = "jobscheduler";
 
+    /**
+     * M: Use with {@link #getSystemService} to retrieve a RecoveryManagerService
+     * @hide
+     */
+    public static final String RECOVERY_SERVICE = "recovery";
+
     /**
      * Use with {@link #getSystemService} to retrieve a {@link
      * android.service.persistentdata.PersistentDataBlockManager} instance
diff --git a/core/java/android/hardware/Camera.java b/core/java/android/hardware/Camera.java
index adcfd62..6f13d6d 100644
--- a/core/java/android/hardware/Camera.java
+++ b/core/java/android/hardware/Camera.java
@@ -20,6 +20,7 @@ import android.app.ActivityThread;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.content.Context;
+import android.content.pm.PackageManager;
 import android.graphics.ImageFormat;
 import android.graphics.Point;
 import android.graphics.Rect;
@@ -32,6 +33,7 @@ import android.os.Looper;
 import android.os.Message;
 import android.os.RemoteException;
 import android.os.ServiceManager;
+import android.os.SystemProperties;
 import android.renderscript.Allocation;
 import android.renderscript.Element;
 import android.renderscript.RenderScript;
@@ -48,6 +50,21 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
+//!++
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStreamReader;
+import java.nio.ByteOrder;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+import com.mediatek.xlog.Xlog;
+import com.mediatek.common.mom.IMobileManagerService;
+import com.mediatek.common.mom.SubPermissions;
+import android.hardware.camera2.impl.CameraMetadataNative;
+import android.hardware.camera2.CaptureResult;
+import android.hardware.camera2.CameraCharacteristics;
+//!--
+
 
 /**
  * The Camera class is used to set image capture settings, start/stop preview,
@@ -159,6 +176,91 @@ public class Camera {
     private static final int CAMERA_MSG_STATS_DATA       = 0x1000;
     private static final int CAMERA_MSG_META_DATA        = 0x2000;
     /* ### QC ADD-ONS: END */
+    //!++
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY   = 0x40000000;  //  extended notify message
+    private static final int MTK_CAMERA_MSG_EXT_DATA     = 0x80000000;  //  extended data message
+    //!--
+    //!++
+    //
+    // Extended notify message (MTK_CAMERA_MSG_EXT_NOTIFY)
+    // These match the enums in mediatek/frameworks-ext/av/include/camera/MtkCamera.h
+    //
+    // Smile Detection
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_SMILE_DETECT     = 0x00000001;
+    //
+    // Auto Scene Detection
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_ASD              = 0x00000002;
+    //
+    // Multi Angle View
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_MAV              = 0x00000003;
+    //
+    // Burst Shutter Callback
+    //  ext2: 0:not the last one, 1:the last one
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER    = 0x00000004;
+    //
+    // End notify for Continuous shot
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END   = 0x00000006;
+    //
+    // Last preview frame showed when capture in ZSD mode
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_ZSD_PREVIEW_DONE = 0x00000007;
+    //
+    // Raw Dump mode Stopped
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED  = 0x00000012;
+    //
+    // Gesture Detection
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_GESTURE_DETECT  = 0x00000013;
+
+    // Stereo Feature: warning message
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_WARNING  = 0x00000014;
+
+    // Stereo Feature: distance value
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_DISTANCE = 0x00000015;
+
+    // Result & Static metadata
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_METADATA_DONE = 0x00000016;
+
+    //
+    //--------------------------------------------------------------------------
+    //
+    // Extended data message (MTK_CAMERA_MSG_EXT_DATA)
+    // These match the enums in mediatek/frameworks-ext/av/include/camera/MtkCamera.h
+    //
+    // Auto Panorama
+    //  int[0]: 0:mAutoRamaMoveCallback, 1:mAutoRamaCallback
+    //  int[1~]:depends on
+    private static final int MTK_CAMERA_MSG_EXT_DATA_AUTORAMA           = 0x00000001;
+    //
+    // AF Window Results
+    private static final int MTK_CAMERA_MSG_EXT_DATA_AF                 = 0x00000002;
+    //
+    // Burst Shot (EV Shot)
+    //  int[0]: the total shut count.
+    //  int[1]: count-down shut number; 0: the last one shut.
+    private static final int MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT         = 0x00000003;
+    private static final int MTK_CAMERA_MSG_EXT_DATA_OT                 = 0x00000005;
+
+    //
+    //
+    //FB
+    private static final int MTK_CAMERA_MSG_EXT_DATA_FACEBEAUTY         = 0x00000006;
+    //
+    //MAV
+    private static final int MTK_CAMERA_MSG_EXT_DATA_MAV                = 0x00000007;
+    //
+    //HDR
+    private static final int MTK_CAMERA_MSG_EXT_DATA_HDR                = 0x00000008;
+    //
+    //!--
+    private static final int MTK_CAMERA_MSG_EXT_DATA_MOTIONTRACK        = 0x00000009;
+    //Stereo Camera JPS
+    private static final int MTK_CAMERA_MSG_EXT_DATA_JPS                = 0x00000011;
+
+    //Stereo Debug Data
+    //int[0]: data type.
+    private static final int MTK_CAMERA_MSG_EXT_DATA_STEREO_DBG         = 0x00000012;
+
+    // raw16
+    private static final int MTK_CAMERA_MSG_EXT_DATA_RAW16              = 0x00000013;
 
     private long mNativeContext; // accessed by native methods
     private int mCameraId;
@@ -173,10 +275,51 @@ public class Camera {
     private AutoFocusMoveCallback mAutoFocusMoveCallback;
     private OnZoomChangeListener mZoomListener;
     private FaceDetectionListener mFaceListener;
+    private ObjectTrackingListener mObjectListener;
     private ErrorCallback mErrorCallback;
+    //!++
+    private SmileCallback mSmileCallback;
+    private GestureCallback mGestureCallback;
+    private MavCallback mMavCallback;
+    //auto panorama
+    private AutoRamaCallback mAutoRamaCallback;
+    private AutoRamaMoveCallback mAutoRamaMoveCallback;
+    //HDR
+    private HdrOriginalCallback mHdrOriginalCallback;
+
+    //Stereo Camera Jps
+    private StereoCameraJpsCallback mStereoCameraJpsCallback;
+    private StereoCameraWarningCallback mStereoCameraWarningCallback;
+    private DistanceInfoCallback mDistanceInfoCallback;
+    private StereoCameraMaskCallback mStereoCameraMaskCallback;
+    //FB
+    private FbOriginalCallback mFbOriginalCallback;
+    //ASD
+    private AsdCallback mAsdCallback;
+    //AF Data
+    private AFDataCallback mAFDataCallback;
+    private boolean mStereo3DModeForCamera = false;
+    // ZSD preview done
+    private ZSDPreviewDone mPreviewDoneCallback;
+    private PreviewRawDumpCallback mPreviewRawDumpCallback;
+    // Continuous shot done
+    private ContinuousShotCallback mCSDoneCallback;
+    //Motion Track Callback
+    private MotionTrackCallback mMotionTrackCallback;
+    // static & result metadata
+    private MetadataCallback mMetadataCallbacks;
+    // raw16
+    private PictureCallback mRaw16Callbacks;
+    // enable raw16
+    private boolean mEnableRaw16 = false;
+    //!--
+
     private boolean mOneShot;
     private boolean mWithBuffer;
     private boolean mFaceDetectionRunning = false;
+
+    private Face mObjectFace = new Face();
+    private Rect mObjectRect = new Rect();
     private final Object mAutoFocusCallbackLock = new Object();
 
     private static final int NO_ERROR = 0;
@@ -361,6 +504,9 @@ public class Camera {
      * @see android.app.admin.DevicePolicyManager#getCameraDisabled(android.content.ComponentName)
      */
     public static Camera open(int cameraId) {
+        if (!isPermissionGranted()) {
+            return null;
+        }
         return new Camera(cameraId);
     }
 
@@ -371,6 +517,9 @@ public class Camera {
      * @see #open(int)
      */
     public static Camera open() {
+        if (!isPermissionGranted()) {
+            return null;
+        }
         int numberOfCameras = getNumberOfCameras();
         CameraInfo cameraInfo = new CameraInfo();
         for (int i = 0; i < numberOfCameras; i++) {
@@ -471,6 +620,7 @@ public class Camera {
         mRawImageCallback = null;
         mJpegCallback = null;
         mPreviewCallback = null;
+        mPreviewRawDumpCallback = null;
         mPostviewCallback = null;
         mUsingPreviewAllocation = false;
         mZoomListener = null;
@@ -1220,6 +1370,272 @@ public class Camera {
                 }
                 return;
             /* ### QC ADD-ONS: END */
+            //!++
+            case MTK_CAMERA_MSG_EXT_NOTIFY:
+                switch(msg.arg1) {
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_SMILE_DETECT:
+                    if (mSmileCallback != null) {
+                        mSmileCallback.onSmile();
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_GESTURE_DETECT:
+                    if (mGestureCallback != null) {
+                        mGestureCallback.onGesture();
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_ASD:
+                    if (mAsdCallback != null) {
+                        mAsdCallback.onDetected(msg.arg2);
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_MAV:
+                    if (mMavCallback != null) {
+                        mMavCallback.onFrame(null);
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_NOTIFY_METADATA_DONE:
+                    if (mEnableRaw16) {
+                        CameraMetadataNative result_meta = new CameraMetadataNative();
+                        CameraMetadataNative characteristic_meta = new CameraMetadataNative();
+                        getMetadata(result_meta, characteristic_meta);
+                        //
+                        CaptureResult result = new CaptureResult(result_meta, 0);
+                        CameraCharacteristics characteristic = new CameraCharacteristics(characteristic_meta);
+                        //
+                        mMetadataCallbacks.onMetadataReceived(result, characteristic);
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END:
+                    if (mCSDoneCallback != null) {
+                        mCSDoneCallback.onConinuousShotDone(msg.arg2);
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_NOTIFY_ZSD_PREVIEW_DONE:
+                    if (mPreviewDoneCallback != null) {
+                        mPreviewDoneCallback.onPreviewDone();
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_WARNING:
+                    if (mStereoCameraWarningCallback != null) {
+                        int message = msg.arg2;
+                        // There are three warning messages info in arg2 with int32 type
+                        //            bit0:large lv diff;
+                        //            bit1:low light;
+                        //            bit2:close shot
+                        // we need to decode the message types
+                        int[] type = new int[3];
+                        int warnType = -1;
+                        for (int i = 0; i < 3; i++) {
+                            type[i] = (int) message & 1;
+                            message = message >> 1;
+                        }
+                        // we need to notify user by order bit0-->bit2-->bit1
+                        if (type[0] == 1) {
+                            warnType = 0;
+                        } else if (type[2] == 1) {
+                            warnType = 2;
+                        } else if (type[1] == 1) {
+                            warnType = 1;
+                        } else {
+                            warnType = 3;
+                        }
+                        if (warnType != -1) {
+                            Xlog.i(TAG, "Stereo Camera warning message type " + warnType);
+                            mStereoCameraWarningCallback.onWarning(warnType);
+                        }
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_DISTANCE:
+                    if (mDistanceInfoCallback != null) {
+                        String info = String.valueOf(msg.arg2);
+                        if (info != null) {
+                            Xlog.i(TAG, "Distance info: Info = " + info);
+                            mDistanceInfoCallback.onInfo(info);
+                        }
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED:
+                    if (mPreviewRawDumpCallback != null)
+                    {
+                        mPreviewRawDumpCallback.onNotify(MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED);
+                    }
+                default:
+                    Xlog.e(TAG, "Unknown MTK-extended notify message type " + msg.arg1);
+                    break;
+                }
+                return;
+
+            case MTK_CAMERA_MSG_EXT_DATA:
+                switch(msg.arg1) {
+
+                case MTK_CAMERA_MSG_EXT_DATA_AUTORAMA: {
+
+                        byte[] byteArray = (byte[]) msg.obj;
+                        byte[] byteHead = new byte[16];
+                        System.arraycopy(byteArray, 0, byteHead, 0, 16);
+                        Xlog.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_AUTORAMA: byteArray.length = " + byteArray.length);
+
+                        IntBuffer intBuf = ByteBuffer.wrap(byteHead).order(ByteOrder.nativeOrder()).asIntBuffer();
+                        if (0 == intBuf.get(0)) {
+                            if (mAutoRamaMoveCallback != null) {
+                                int x   = intBuf.get(1);
+                                int y   = intBuf.get(2);
+                                int dir = intBuf.get(3);
+                                int xy  = ((0x0000FFFF & x) << 16) + (0x0000FFFF & y);
+                                Xlog.i(TAG, "call mAutoRamaMoveCallback: " + mAutoRamaCallback + " dir:" + dir + " x:" + x + " y:" + y + " xy:" + xy);
+                                mAutoRamaMoveCallback.onFrame(xy, dir);
+                            }
+                        } else {
+                            Xlog.i(TAG, "call mAutoRamaCallback: " + mAutoRamaCallback);
+                            if (mAutoRamaCallback != null) {
+                                if (1 == intBuf.get(0)) {
+                                    Xlog.i(TAG, "capturing frame");
+                                    mAutoRamaCallback.onCapture(null);
+                                } else if (2 == intBuf.get(0)) {
+                                    Xlog.i(TAG, "image is merged over");
+                                    byte[] jpegData = new byte[byteArray.length - 4];
+                                    System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                                    mAutoRamaCallback.onCapture(jpegData);
+                                }
+
+                            }
+                        }
+                        byteHead = null;
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_MOTIONTRACK: {
+
+                    byte[] byteArray = (byte[]) msg.obj;
+                    if (byteArray == null) {
+                        Xlog.w(TAG, "MTK_CAMERA_MSG_EXT_DATA_MOTIONTRACK: byteArray is null,please check");
+                        return;
+                    }
+                    
+                    Xlog.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_MOTIONTRACK: byteArray.length = " + byteArray.length);
+                    if (mMotionTrackCallback != null) {
+                        mMotionTrackCallback.onDataCallback(byteArray);
+                    }
+                }
+                break;
+                
+                case MTK_CAMERA_MSG_EXT_DATA_AF: {
+
+                        byte[] byteArray = (byte[]) msg.obj;
+
+                        Xlog.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_AF: byteArray.length = " + byteArray.length);
+/*
+                        IntBuffer intBuf = ByteBuffer.wrap(byteArray).order(ByteOrder.nativeOrder()).asIntBuffer();
+                        Log.i(TAG, "intBuf.limit() = " + intBuf.limit());
+                        for (int i = 0; i < intBuf.limit(); i++)
+                        {
+                            Log.i(TAG, "intBuf " + i + " = " + intBuf.get(i));
+                        }
+*/
+                        if (mAFDataCallback != null) {
+                            AFDataCallback afDatacb = mAFDataCallback;
+                            afDatacb.onAFData((byte[]) msg.obj, mCamera);
+                        }
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_OT: {
+                    byte[] byteArray = (byte[]) msg.obj;
+
+                    Xlog.i(TAG,
+                            "MTK_CAMERA_MSG_EXT_DATA_OT: byteArray.length = "
+                                    + byteArray.length);
+
+                    IntBuffer intBuf = ByteBuffer.wrap(byteArray)
+                            .order(ByteOrder.nativeOrder()).asIntBuffer();
+                    if (mObjectListener != null) {
+                      Xlog.i(TAG, "OT callback0:" + intBuf.get(0));
+                        if (intBuf.get(0) == 1) {
+                            mObjectRect.left = intBuf.get(1);
+                            mObjectRect.top = intBuf.get(2);
+                            mObjectRect.right = intBuf.get(3);
+                            mObjectRect.bottom = intBuf.get(4);
+                            mObjectFace.rect = mObjectRect;
+                            mObjectFace.score = intBuf.get(5);
+                            mObjectListener.onObjectTracking(mObjectFace,
+                                    mCamera);
+                        } else {
+                            mObjectListener.onObjectTracking(null, mCamera);
+                        }
+                    }
+                }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_DATA_HDR:
+                    if (mHdrOriginalCallback != null) {
+                        Xlog.i(TAG, "HDR Original callback");
+                        byte[] byteArray = ((byte[]) msg.obj);
+                        byte[] jpegData = new byte[byteArray.length - 4];
+                        System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                        mHdrOriginalCallback.onCapture(jpegData);
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_FACEBEAUTY:
+                    if (mFbOriginalCallback != null) {
+                        byte[] byteArray = ((byte[]) msg.obj);
+                        byte[] jpegData = new byte[byteArray.length - 4];
+                        System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                        Xlog.i(TAG, "FB Original callback, VFB enable : "
+                                + (SystemProperties.getInt("ro.mtk_cam_vfb", 0) == 1 ? true : false));
+                        // becuase current msg =6 have change to FB callback
+                        if (SystemProperties.getInt("ro.mtk_cam_vfb", 0) == 1 && mJpegCallback != null) {
+                            Xlog.i(TAG,
+                                    "FB Original callback,will call mJpegCallback.onPictureTaken");
+                            mJpegCallback.onPictureTaken(jpegData, mCamera);
+                        } else {
+                            mFbOriginalCallback.onCapture(jpegData);
+                        }
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_MAV:
+                    if (mMavCallback != null) {
+                        byte[] byteArray = ((byte[]) msg.obj);
+                        byte[] jpegData = new byte[byteArray.length - 4];
+                        Xlog.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_MAV: byteArray.length = " + byteArray.length);
+                        System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                        mMavCallback.onFrame(jpegData);
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_JPS:
+                    if (mStereoCameraJpsCallback != null) {
+                        byte[] byteArray = ((byte[]) msg.obj);
+                        byte[] jpegData = new byte[byteArray.length - 4];
+                        Xlog.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_JPS: jpegData.length = " + jpegData.length);
+                        System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                        mStereoCameraJpsCallback.onCapture(jpegData);
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_DATA_STEREO_DBG:
+                    if (mStereoCameraMaskCallback != null) {
+                        byte[] byteArray = ((byte[]) msg.obj);
+                        byte[] jpegData = new byte[byteArray.length - 4];
+                        Xlog.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_STEREO_DBG: jpegData.length = " + jpegData.length);
+                        System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                        mStereoCameraMaskCallback.onCapture(jpegData);
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_RAW16:
+                    if (mEnableRaw16) {
+                        mRaw16Callbacks.onPictureTaken((byte[]) msg.obj, mCamera);
+                    }
+                    break;
+                default:
+                    Xlog.e(TAG, "Unknown MTK-extended data message type " + msg.arg1);
+                    break;
+                }
+                return;
+            //!--
             default:
                 Log.e(TAG, "Unknown message type " + msg.what);
                 return;
@@ -1502,6 +1918,44 @@ public class Camera {
         mFaceDetectionRunning = false;
     }
 
+    /**
+    * @hide
+    *
+    * set result metadata & characteristics metadata  & raw16 callback.
+    */
+    public final void setRaw16Callback(MetadataCallback meta, PictureCallback raw16)
+    {
+        Xlog.i(TAG, "setRaw16Callback");
+        mMetadataCallbacks = meta;
+        mRaw16Callbacks = raw16;
+    }
+
+    /**
+    * @hide
+    *
+    * enable result metadata & characteristics metadata  & raw16 callback.
+    */
+    public final void enableRaw16(boolean enable)
+    {
+        Xlog.i(TAG, "enableRaw16 " + enable);
+        mEnableRaw16 = enable;
+        enableRaw16Callback(mEnableRaw16);
+    }
+
+    /**
+    * @hide
+    *
+    * set result & characteristics metadata callback.
+    */
+    public native final void getMetadata(CameraMetadataNative result, CameraMetadataNative characteristic);
+
+    /**
+    * @hide
+    *
+    * set result & characteristics metadata callback.
+    */
+    public native final void enableRaw16Callback(boolean enable);
+
     /**
      * Zooms to the requested value smoothly. The driver will notify {@link
      * OnZoomChangeListener} of the zoom value and whether zoom is stopped at
@@ -1915,6 +2369,22 @@ public class Camera {
      */
     public static final int CAMERA_ERROR_SERVER_DIED = 100;
 
+    //!++
+    /**  Memory is not enough.
+     *   @see Camera.ErrorCallback
+     * @hide
+     * @internal
+     */
+    public static final int CAMERA_ERROR_NO_MEMORY = 1000;
+
+
+    /**  STOP current feature and reset. Unlock UI. Due to wrong happened accidently.
+     *   @see Camera.ErrorCallback
+     * @hide
+     * @internal
+     */
+    public static final int CAMERA_ERROR_RESET = 1001;
+    //!--
     /**
      * Callback interface for camera error notification.
      *
@@ -1935,6 +2405,12 @@ public class Camera {
          * </ul>
          * @param camera  the Camera service object
          */
+//!++
+        /*
+         *  CAMERA_ERROR_NO_MEMORY
+         *  CAMERA_ERROR_RESET  are newly added
+         */
+//!--
         void onError(int error, Camera camera);
     };
 
@@ -1949,6 +2425,9 @@ public class Camera {
 
     private native final void native_setParameters(String params);
     private native final String native_getParameters();
+    //!++
+    private native static String native_getProperty(String key, String def);
+    private native static void native_setProperty(String key, String val);
 
     /**
      * Changes the settings for this Camera service.
@@ -2008,2070 +2487,3861 @@ public class Camera {
     }
 
     /**
-     * Returns an empty {@link Parameters} for testing purpose.
-     *
-     * @return a Parameter object.
+     * @hide
      *
+     * Get the value for the given key.
+     * @return if the key isn't found, return def if it isn't null, or an empty string otherwise
+     */
+    public static String getProperty(String key, String def) {
+        return native_getProperty(key, def);
+    }
+
+    /**
      * @hide
+     * @internal
+     * @param key: the given key to set, val: the value set to the key
+     * Set the value for the given key.
      */
-    public static Parameters getEmptyParameters() {
-        Camera camera = new Camera();
-        return camera.new Parameters();
+    public static void setProperty(String key, String val) {
+        native_setProperty(key, val);
     }
 
-    /* ### QC ADD-ONS: START */
-    private static int byteToInt(byte[] b, int offset) {
-        int value = 0;
-        for (int i = 0; i < 4; i++) {
-            int shift = (4 - 1 - i) * 8;
-            value += (b[(3-i) + offset] & 0x000000FF) << shift;
-        }
-        return value;
+    //
+    /**
+     * @hide
+     * An interface which contains a callback for the detection of a smile
+     */
+    public interface SmileCallback
+    {
+        /**
+         * @internal
+         * Callback for smile detected
+         */
+        void onSmile();
     }
-    /** @hide
-     * Handles the callback for when Camera Data is available.
-     * data is read from the camera.
+
+    /**
+     * @hide
+     * An interface which contains a callback for the detection of a gesture
      */
-    public interface CameraDataCallback {
+    public interface GestureCallback
+    {
         /**
-         * Callback for when camera data is available.
-         *
-         * @param data   a int array of the camera data
-         * @param camera the Camera service object
+         * @internal
+         * Callback for gesture detected
+         * 
          */
-        void onCameraData(int[] data, Camera camera);
-    };
+        void onGesture();
+    }
 
-    /** @hide
-     * Set camera histogram mode and registers a callback function to run.
-     *  Only valid after startPreview() has been called.
+    /**
+     * @hide
+     * @internal
      *
+     * Registers a callback to be invoked when a smile face is detected
      * @param cb the callback to run
      */
-    public final void setHistogramMode(CameraDataCallback cb)
+    public final void setSmileCallback(SmileCallback cb)
     {
-        mCameraDataCallback = cb;
-        native_setHistogramMode(cb!=null);
+        mSmileCallback = cb;
     }
-    private native final void native_setHistogramMode(boolean mode);
 
-    /** @hide
-     * Set camera histogram command to send data.
-     *
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoked when a gesture is detected
+     * @param cb the callback to run
      */
-    public final void sendHistogramData()
+    public final void setGestureCallback(GestureCallback cb)
     {
-        native_sendHistogramData();
+        mGestureCallback = cb;
     }
-    private native final void native_sendHistogramData();
 
-    /** @hide
-     * Handles the callback for when Camera Meta Data is available.
-     * Meta data is read from the camera.
+    //
+
+    /**
+     * @hide
+     *
+     * Do panorama with number of images
      */
-    public interface CameraMetaDataCallback {
+    public native final void doPanorama(int num);
+
+    /**
+     * @hide
+     *
+     * Cancel panorama
+     */
+    public native void cancelPanorama();
+
+    /**
+     * @hide
+     * @internal
+     *
+     * Start the SD (smile detection) preview mode.
+     *
+     * During the SD preview mode, the applications can call stopSmileDetection to
+     * leave the SD preview mode and then to return to the normal preview mode.
+     *
+     * During the SD preview mode, it will return to the normal preview mode
+     * automatically if the applications call takePicture. In this case, a call
+     * to stopSmileDetection is not needed.
+     *
+     * During the SD preview mode, if any smile is detected, a callback to the
+     * applications will be invoked. And then the applications should call
+     * takePicture, which is illustrated as above.
+     *
+     * @throws RuntimeException if the method fails.
+     */
+    public void startSmileDetection() {
+        startSDPreview();
+    }
+    
+    private native void startSDPreview();
+
+    /**
+     * @hide
+     * @internal
+     *
+     * Cancel the SD (smile detection) preview mode.
+     *
+     * During the SD preview mode, the applications can call stopSmileDetection to
+     * leave the SD preview mode and then to return to the normal preview mode.
+     * Otherwise, do not call this method.
+     *
+     * @throws RuntimeException if the method fails.
+     */
+    public void stopSmileDetection() {
+        cancelSDPreview();
+    }
+    
+    private native void cancelSDPreview();
+
+    /**
+     * @hide
+     * @internal
+     * Start the GD (gesture detection) preview mode.
+     *
+     * During the GD preview mode, the applications can call stopGestureDetection to
+     * leave the GD preview mode and then to return to the normal preview mode.
+     *
+     * During the GD preview mode, it will return to the normal preview mode
+     * automatically if the applications call takePicture. In this case, a call
+     * to stopGestureDetection is not needed.
+     *
+     * During the GD preview mode, if any gesture is detected, a callback to the
+     * applications will be invoked. And then the applications should call
+     * takePicture, which is illustrated as above.
+     *
+     * @throws RuntimeException if the method fails.
+     */
+    public void startGestureDetection() {
+        startGDPreview();
+    }
+    
+    private native void startGDPreview();
+
+    /**
+     * @hide
+     * @internal
+     * Cancel the GD (gesture detection) preview mode.
+     *
+     * During the GD preview mode, the applications can call stopGestureDetection to
+     * leave the GD preview mode and then to return to the normal preview mode.
+     * Otherwise, do not call this method.
+     *
+     * @throws RuntimeException if the method fails.
+     */
+    public void stopGestureDetection() {
+        cancelGDPreview();
+    }
+    
+    private native void cancelGDPreview();
+
+    //
+    /**
+     * @hide
+     * An interface which contains a callback for the multi angle view
+     */
+    public interface MavCallback
+    {
         /**
-         * Callback for when camera meta data is available.
-         *
-         * @param data   a byte array of the camera meta data
-         * @param camera the Camera service object
+         * @internal
+         * Callback for multi angle view when a frame is done
          */
-        void onCameraMetaData(byte[] data, Camera camera);
-    };
+        void onFrame(byte[] jpegData);
+    }
 
-    /** @hide
-     * Set camera meta data and registers a callback function to run.
-     *  Only valid after startPreview() has been called.
+    /**
+     * @hide
+     * @internal
      *
+     * Registers a callback to be invoked when a frame of MAV is detected
      * @param cb the callback to run
      */
-    public final void setMetadataCb(CameraMetaDataCallback cb)
+    public final void setMavCallback(MavCallback cb)
     {
-        mCameraMetaDataCallback = cb;
-        native_setMetadataCb(cb!=null);
+        mMavCallback = cb;
     }
-    private native final void native_setMetadataCb(boolean mode);
 
-    /** @hide
-     * Set camera face detection command to send meta data.
-     */
-    public final void sendMetaData()
+    //ASD
+  /**
+    * @hide
+    * An interface which contains a callback for the auto scene detection
+    */
+    public interface AsdCallback
     {
-        native_sendMetaData();
+        /**
+          * @internal
+          * @param scene the scene detected
+          */
+        void onDetected(int scene);
     }
-    private native final void native_sendMetaData();
 
-    /** @hide
-     * Configure longshot mode. Available only in ZSL.
+    /**
+     * @hide
+     * @internal
      *
-     * @param enable enable/disable this mode
+     * Registers a callback to be invoked when auto scene is detected
+     * @param cb the callback to run
      */
-    public final void setLongshot(boolean enable)
+    public final void setAsdCallback(AsdCallback cb)
     {
-        native_setLongshot(enable);
+        mAsdCallback = cb;
     }
-    private native final void native_setLongshot(boolean enable);
 
-    /** @hide
-     * Stop longshot. Available only in ZSL.
+
+    /**
+     * Callback interface used to deliver focus data.
+     **
+     * @hide
      */
-    public final void stopLongshot()
+     public interface AFDataCallback
     {
-        native_stopLongshot();
+        void onAFData(byte[] data, Camera camera);
+    };
+
+    /**
+     * @hide
+     *
+     * Registers a callback to be invoked when in focus
+     * @param cb the callback to run
+     */
+    public final void setAFDataCallback(AFDataCallback cb) {
+        mAFDataCallback = cb;
     }
-    private native final void native_stopLongshot();
 
-     /** @hide
-     * Handles the Touch Co-ordinate.
+    // auto panorama
+    /**
+      * @hide
+      * An interface which contains a callback for the auto panorama
+      */
+    public interface AutoRamaCallback
+    {
+        /**
+          * @internal
+          * @param jpegData the captured jpegdata
+          */
+        void onCapture(byte[] jpegData);
+
+    }
+
+   /**
+     * @hide
+     * An interface which contains a callback for the auto panorama movtion vector
      */
-     public class Coordinate {
+    public interface AutoRamaMoveCallback
+    {
         /**
-         * Sets the x,y co-ordinates for a touch event
-         *
-         * @param x the x co-ordinate (pixels)
-         * @param y the y co-ordinate (pixels)
+         * @internal
+         * @param xx the pointer
+         * @param yy direction
          */
-        public Coordinate(int x, int y) {
-            xCoordinate = x;
-            yCoordinate = y;
-        }
+        void onFrame(int xx, int yy);
+    }
+
+    /**
+     * @hide
+     * An interface which contains a callback for the motion track
+     */
+    public interface MotionTrackCallback
+    {
         /**
-         * Compares {@code obj} to this co-ordinate.
-         *
-         * @param obj the object to compare this co-ordinate with.
-         * @return {@code true} if the xCoordinate and yCoordinate of {@code obj} is the
-         *         same as those of this coordinate. {@code false} otherwise.
+         * @internal
+         * @param data the data of callback
          */
-        @Override
-        public boolean equals(Object obj) {
-            if (!(obj instanceof Coordinate)) {
-                return false;
-            }
-            Coordinate c = (Coordinate) obj;
-            return xCoordinate == c.xCoordinate && yCoordinate == c.yCoordinate;
-        }
-
-        /** x co-ordinate for the touch event*/
-        public int xCoordinate;
-
-        /** y co-ordinate for the touch event */
-        public int yCoordinate;
-    };
+        void onDataCallback(byte[] data);
+    }
 
-    /** @hide
-     * Returns the current focus position.
-     *
-     * If it's in AF mode, it's the lens position after af is done.
-     *
-     * If it's in Manual Focus mode, it actually returns the value
-     *     set by user via {@link #setParameters(Camera.Parameters)}.
+    /**
+     * @hide
+     * An interface which contains a callback for result & static metadata
      */
-    public int getCurrentFocusPosition() {
-        Parameters p = new Parameters();
-        String s = native_getParameters();
-        p.unflatten(s);
+    public interface MetadataCallback
+    {
+        /**
+         * on receive result & static metadata
+         */
+        void onMetadataReceived( CaptureResult result, CameraCharacteristics characteristic); 
 
-        int focus_pos = -1;
-        if (p.getCurrentFocusPosition() != null) {
-            focus_pos = Integer.parseInt(p.getCurrentFocusPosition());
-        }
-        return focus_pos;
     }
 
-    /* ### QC ADD-ONS: END */
     /**
-     * Returns a copied {@link Parameters}; for shim use only.
-     *
-     * @param parameters a non-{@code null} parameters
-     * @return a Parameter object, with all the parameters copied from {@code parameters}.
-     *
-     * @throws NullPointerException if {@code parameters} was {@code null}
      * @hide
+     * An interface which contains a callback for HDR origin image
      */
-    public static Parameters getParametersCopy(Camera.Parameters parameters) {
-        if (parameters == null) {
-            throw new NullPointerException("parameters must not be null");
-        }
-
-        Camera camera = parameters.getOuter();
-        Parameters p = camera.new Parameters();
-        p.copyFrom(parameters);
+    public interface HdrOriginalCallback
+    {
+        /**
+         * @internal
+         * @param originJpegData capture data
+         */
+        void onCapture(byte[] originJpegData);
+    }
 
-        return p;
+    /**
+     * @hide
+     * An interface which contains a callback for stere Camera JPS image
+     */
+    public interface StereoCameraJpsCallback
+    {
+        /**
+         * @internal
+         * @param originJpegData capture data
+         */
+        void onCapture(byte[] originJpegData);
     }
 
     /**
-     * Image size (width and height dimensions).
-     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
-     *             applications.
+     * @hide
+     * An interface which contains a callback for stere Camera Warning Message
      */
-    @Deprecated
-    public class Size {
+    public interface StereoCameraWarningCallback
+    {
         /**
-         * Sets the dimensions for pictures.
-         *
-         * @param w the photo width (pixels)
-         * @param h the photo height (pixels)
+         * @internal
+         * @param type warning type
          */
-        public Size(int w, int h) {
-            width = w;
-            height = h;
-        }
+        void onWarning(int type);
+    }
+
+    /**
+     * @hide
+     * An interface which contains a callback for stere Camera Distance Info
+     */
+    public interface DistanceInfoCallback
+    {
         /**
-         * Compares {@code obj} to this size.
-         *
-         * @param obj the object to compare this size with.
-         * @return {@code true} if the width and height of {@code obj} is the
-         *         same as those of this size. {@code false} otherwise.
+         * @internal
+         * @param info distance info
          */
-        @Override
-        public boolean equals(Object obj) {
-            if (!(obj instanceof Size)) {
-                return false;
-            }
-            Size s = (Size) obj;
-            return width == s.width && height == s.height;
-        }
-        @Override
-        public int hashCode() {
-            return width * 32713 + height;
-        }
-        /** width of the picture */
-        public int width;
-        /** height of the picture */
-        public int height;
-    };
+        void onInfo(String info);
+    }
 
     /**
-     * <p>The Area class is used for choosing specific metering and focus areas for
-     * the camera to use when calculating auto-exposure, auto-white balance, and
-     * auto-focus.</p>
-     *
-     * <p>To find out how many simultaneous areas a given camera supports, use
-     * {@link Parameters#getMaxNumMeteringAreas()} and
-     * {@link Parameters#getMaxNumFocusAreas()}. If metering or focusing area
-     * selection is unsupported, these methods will return 0.</p>
-     *
-     * <p>Each Area consists of a rectangle specifying its bounds, and a weight
-     * that determines its importance. The bounds are relative to the camera's
-     * current field of view. The coordinates are mapped so that (-1000, -1000)
-     * is always the top-left corner of the current field of view, and (1000,
-     * 1000) is always the bottom-right corner of the current field of
-     * view. Setting Areas with bounds outside that range is not allowed. Areas
-     * with zero or negative width or height are not allowed.</p>
-     *
-     * <p>The weight must range from 1 to 1000, and represents a weight for
-     * every pixel in the area. This means that a large metering area with
-     * the same weight as a smaller area will have more effect in the
-     * metering result.  Metering areas can overlap and the driver
-     * will add the weights in the overlap region.</p>
-     *
-     * @see Parameters#setFocusAreas(List)
-     * @see Parameters#getFocusAreas()
-     * @see Parameters#getMaxNumFocusAreas()
-     * @see Parameters#setMeteringAreas(List)
-     * @see Parameters#getMeteringAreas()
-     * @see Parameters#getMaxNumMeteringAreas()
-     *
-     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
-     *             applications.
+     * @hide
+     * An interface which contains a callback for stere Camera Mask info
      */
-    @Deprecated
-    public static class Area {
+    public interface StereoCameraMaskCallback
+    {
         /**
-         * Create an area with specified rectangle and weight.
-         *
-         * @param rect the bounds of the area.
-         * @param weight the weight of the area.
+         * @internal
+         * @param originJpegData capture data
          */
-        public Area(Rect rect, int weight) {
-            this.rect = rect;
-            this.weight = weight;
-        }
+        void onCapture(byte[] originJpegData);
+    }
+    /**
+     * @hide
+     * An interface which contains a callback for FB origin image
+     */
+    public interface FbOriginalCallback
+    {
         /**
-         * Compares {@code obj} to this area.
-         *
-         * @param obj the object to compare this area with.
-         * @return {@code true} if the rectangle and weight of {@code obj} is
-         *         the same as those of this area. {@code false} otherwise.
+         * @internal
+         * @param originJpegData capture data
          */
-        @Override
-        public boolean equals(Object obj) {
-            if (!(obj instanceof Area)) {
-                return false;
-            }
-            Area a = (Area) obj;
-            if (rect == null) {
-                if (a.rect != null) return false;
-            } else {
-                if (!rect.equals(a.rect)) return false;
+        void onCapture(byte[] originJpegData);
+    }
+
+    /**
+     * @hide
+     * @internal
+     *
+     * Registers a callback to be invoked when a image for autorama is taken
+     * @param cb the callback to run
+     */
+    public final void setAutoRamaCallback(AutoRamaCallback cb)
+    {
+        mAutoRamaCallback = cb;
+    }
+
+     // Add for CTA
+     private static boolean isPermissionGranted() {
+        if ("1".equals(SystemProperties.get("ro.mtk_mobile_management"))) {
+            IBinder binder = ServiceManager.getService(Context.MOBILE_SERVICE);
+            IMobileManagerService moms = IMobileManagerService.Stub.asInterface(binder);
+            int uid = Binder.getCallingUid();
+            String permission = SubPermissions.OPEN_CAMERA;
+            try {
+                if (moms != null) {
+                    if (moms.checkPermission(permission, uid) != PackageManager.PERMISSION_GRANTED) {
+                        Xlog.d(TAG, "open: user denied permission " + permission + " for uid " + uid);
+                        return false;
+                    }
+                }
+            } catch (RemoteException e) {
+                Xlog.e(TAG, "CheckPermission failed in open with RemoteException, continues open.", e);
+                return true;
             }
-            return weight == a.weight;
         }
+        return true;
+     }
 
-        /**
-         * Bounds of the area. (-1000, -1000) represents the top-left of the
-         * camera field of view, and (1000, 1000) represents the bottom-right of
-         * the field of view. Setting bounds outside that range is not
-         * allowed. Bounds with zero or negative width or height are not
-         * allowed.
-         *
-         * @see Parameters#getFocusAreas()
-         * @see Parameters#getMeteringAreas()
-         */
-        public Rect rect;
+    /**
+     * @hide
+     * @internal
+     *
+     * Registers a callback to be invoked when the motion vector is calculated
+     * @param cb the callback to run
+     */
+    public final void setAutoRamaMoveCallback(AutoRamaMoveCallback cb)
+    {
+        mAutoRamaMoveCallback = cb;
+    }
 
-        /**
-         * Weight of the area. The weight must range from 1 to 1000, and
-         * represents a weight for every pixel in the area. This means that a
-         * large metering area with the same weight as a smaller area will have
-         * more effect in the metering result.  Metering areas can overlap and
-         * the driver will add the weights in the overlap region.
-         *
-         * @see Parameters#getFocusAreas()
-         * @see Parameters#getMeteringAreas()
-         */
-        public int weight;
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoked when the motion track is callback
+     * @param cb the callback to run
+     */
+    public final void setMotionTrackCallback(MotionTrackCallback cb)
+    {
+        mMotionTrackCallback = cb;
     }
 
     /**
-     * Camera service settings.
+     * @hide
+     * @internal
+     * Registers a callback to be invoke when HDR origin image is taken
+     * @param cb the callback to run
+     */
+    public final void setHdrOriginalCallback(HdrOriginalCallback cb)
+    {
+        mHdrOriginalCallback = cb;
+    }
+
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoke when Stereo Camera JPS image is taken
+     * @param cb the callback to run
+     */
+    public final void setStereoCameraJpsCallback(StereoCameraJpsCallback cb)
+    {
+        mStereoCameraJpsCallback = cb;
+    }
+
+    /**
+     * @hide
      *
-     * <p>To make camera parameters take effect, applications have to call
-     * {@link Camera#setParameters(Camera.Parameters)}. For example, after
-     * {@link Camera.Parameters#setWhiteBalance} is called, white balance is not
-     * actually changed until {@link Camera#setParameters(Camera.Parameters)}
-     * is called with the changed parameters object.
+     * Registers a callback to be invoke when Stereo Camera warning is taken
+     * @param cb the callback to run
+     */
+    public final void setStereoCameraWarningCallback(StereoCameraWarningCallback cb)
+    {
+        mStereoCameraWarningCallback = cb;
+    }
+
+    /**
+     * @hide
      *
-     * <p>Different devices may have different camera capabilities, such as
-     * picture size or flash modes. The application should query the camera
-     * capabilities before setting parameters. For example, the application
-     * should call {@link Camera.Parameters#getSupportedColorEffects()} before
-     * calling {@link Camera.Parameters#setColorEffect(String)}. If the
-     * camera does not support color effects,
-     * {@link Camera.Parameters#getSupportedColorEffects()} will return null.
+     * Registers a callback to be invoke when Distance info is taken
+     * @param cb the callback to run
+     */
+    public final void setDistanceInfoCallback(DistanceInfoCallback cb)
+    {
+        mDistanceInfoCallback = cb;
+    }
+
+    /**
+     * @hide
      *
-     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
-     *             applications.
+     * Registers a callback to be invoke when Mask info is taken
+     * @param cb the callback to run
      */
-    @Deprecated
-    public class Parameters {
-        // Parameter keys to communicate with the camera driver.
-        private static final String KEY_PREVIEW_SIZE = "preview-size";
-        private static final String KEY_PREVIEW_FORMAT = "preview-format";
-        private static final String KEY_PREVIEW_FRAME_RATE = "preview-frame-rate";
-        private static final String KEY_PREVIEW_FPS_RANGE = "preview-fps-range";
-        private static final String KEY_PICTURE_SIZE = "picture-size";
-        private static final String KEY_PICTURE_FORMAT = "picture-format";
-        private static final String KEY_JPEG_THUMBNAIL_SIZE = "jpeg-thumbnail-size";
-        private static final String KEY_JPEG_THUMBNAIL_WIDTH = "jpeg-thumbnail-width";
-        private static final String KEY_JPEG_THUMBNAIL_HEIGHT = "jpeg-thumbnail-height";
-        private static final String KEY_JPEG_THUMBNAIL_QUALITY = "jpeg-thumbnail-quality";
-        private static final String KEY_JPEG_QUALITY = "jpeg-quality";
-        private static final String KEY_ROTATION = "rotation";
-        private static final String KEY_GPS_LATITUDE = "gps-latitude";
-        private static final String KEY_GPS_LONGITUDE = "gps-longitude";
-        private static final String KEY_GPS_ALTITUDE = "gps-altitude";
-        private static final String KEY_GPS_TIMESTAMP = "gps-timestamp";
-        private static final String KEY_GPS_PROCESSING_METHOD = "gps-processing-method";
-        private static final String KEY_WHITE_BALANCE = "whitebalance";
-        private static final String KEY_EFFECT = "effect";
-        private static final String KEY_ANTIBANDING = "antibanding";
-        private static final String KEY_SCENE_MODE = "scene-mode";
-        private static final String KEY_FLASH_MODE = "flash-mode";
-        private static final String KEY_FOCUS_MODE = "focus-mode";
-        private static final String KEY_FOCUS_AREAS = "focus-areas";
-        private static final String KEY_MAX_NUM_FOCUS_AREAS = "max-num-focus-areas";
-        private static final String KEY_FOCAL_LENGTH = "focal-length";
-        private static final String KEY_HORIZONTAL_VIEW_ANGLE = "horizontal-view-angle";
-        private static final String KEY_VERTICAL_VIEW_ANGLE = "vertical-view-angle";
-        private static final String KEY_EXPOSURE_COMPENSATION = "exposure-compensation";
-        private static final String KEY_MAX_EXPOSURE_COMPENSATION = "max-exposure-compensation";
-        private static final String KEY_MIN_EXPOSURE_COMPENSATION = "min-exposure-compensation";
-        private static final String KEY_EXPOSURE_COMPENSATION_STEP = "exposure-compensation-step";
-        private static final String KEY_AUTO_EXPOSURE_LOCK = "auto-exposure-lock";
-        private static final String KEY_AUTO_EXPOSURE_LOCK_SUPPORTED = "auto-exposure-lock-supported";
-        private static final String KEY_AUTO_WHITEBALANCE_LOCK = "auto-whitebalance-lock";
-        private static final String KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED = "auto-whitebalance-lock-supported";
-        private static final String KEY_METERING_AREAS = "metering-areas";
-        private static final String KEY_MAX_NUM_METERING_AREAS = "max-num-metering-areas";
-        private static final String KEY_ZOOM = "zoom";
-        private static final String KEY_MAX_ZOOM = "max-zoom";
-        private static final String KEY_ZOOM_RATIOS = "zoom-ratios";
-        private static final String KEY_ZOOM_SUPPORTED = "zoom-supported";
-        private static final String KEY_SMOOTH_ZOOM_SUPPORTED = "smooth-zoom-supported";
-        private static final String KEY_FOCUS_DISTANCES = "focus-distances";
-        private static final String KEY_VIDEO_SIZE = "video-size";
-        private static final String KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO =
-                                            "preferred-preview-size-for-video";
-        private static final String KEY_MAX_NUM_DETECTED_FACES_HW = "max-num-detected-faces-hw";
-        private static final String KEY_MAX_NUM_DETECTED_FACES_SW = "max-num-detected-faces-sw";
-        private static final String KEY_RECORDING_HINT = "recording-hint";
-        private static final String KEY_VIDEO_SNAPSHOT_SUPPORTED = "video-snapshot-supported";
-        private static final String KEY_VIDEO_STABILIZATION = "video-stabilization";
-        private static final String KEY_VIDEO_STABILIZATION_SUPPORTED = "video-stabilization-supported";
+    public final void setStereoCameraMaskCallback(StereoCameraMaskCallback cb)
+    {
+        mStereoCameraMaskCallback = cb;
+    }
+
+    /**
+     * @hide
+     *
+     * Registers a callback to be invoke when HDR origin image is taken
+     * @param cb the callback to run
+     */
+    public final void setFbOriginalCallback(FbOriginalCallback cb)
+    {
+        mFbOriginalCallback = cb;
+    }
+
+   /**
+    * @hide
+    * @internal
+    *
+    * Start to capture number of images of panorama.
+    * @param num number of images
+    */
+    public final void startAutoRama(int num) {
+        startAUTORAMA(num);
+    }
+    
+    private native final void startAUTORAMA(int num);
+
+    /**
+    * @hide
+    * @internal
+    *
+    * Stop auto panorama
+    * @param isMerge if isMerge is 1, there will be an autorama callback when merge is done
+    */
+    public void stopAutoRama(int isMerge){
+        stopAUTORAMA(isMerge);
+    }
+    
+    private native void stopAUTORAMA(int isMerge);
+
+     /**
+    * @hide
+    *
+    * Start to capture number of images of 3d panorama.
+    */
+    public native final void start3DSHOT(int num);
+
+    /**
+     * @hide
+     *
+    * Stop 3D panorama, if isMerge is 1, there will be a callback when merge is done
+    */
+    public native void stop3DSHOT(int isMerge);
+    /**
+     * @hide
+     * @internal
+     * Start to capture number of images of MAV
+     * @param num number of images, max num is 10
+     */
+    public final void startMav(int num){
+        startMAV(num);
+    }
+    
+    private native final void startMAV(int num);
+    /**
+     * @hide
+     * @internal
+     * Stop MAV
+     * @param isMerge if isMerge is 1, there will be a callback when merge is done
+     */
+    public void stopMav(int isMerge) {
+        stopMAV(isMerge);
+    }
+    
+    private native void stopMAV(int isMerge);
+    
+    /**
+     * @hide
+     * Start MainFace
+     */
+    public final void setMainFaceCoordinate(int x, int y) {
+        setMainFace(x, y);
+    }
+    private native final void setMainFace(int x, int y);
+
+    /**
+     * @hide
+     * Stop MainFace
+     */
+    public final void cancelMainFaceInfo() {
+        cancelMainFace();
+    }
+    private native final void cancelMainFace();
+
+    /**
+     * @hide
+     * @internal
+     * Start ObjectTracking
+     */
+    public final void startObjectTracking(int x, int y) {
+        startOT(x, y);
+    }
+    private native final void startOT(int x, int y);
+
+    /**
+     * @hide
+     * @internal
+     * Stop ObjectTracking
+     */
+    public final void stopObjectTracking() {
+        stopOT();
+    }
+    private native final void stopOT();
+    /**
+     * @hide
+     * Callback interface for Object Tracking in the preview frame.
+     *
+     */
+    public interface ObjectTrackingListener {
+        /**
+         * Notify the listener of the detected Object in the preview frame.
+         * @internal
+         * @param face The detected Object
+         * @param camera  The {@link Camera} service object
+         */
+        void onObjectTracking(Face face, Camera camera);
+    }
+    /**
+     * @hide
+     * @internal
+     * Stop motion track
+     */
+    public native void stopMotionTrack();
+    /**
+     * @hide
+     * @internal
+     * Start motion track
+     */
+    public native void startMotionTrack(int num);
+   /**
+     * @hide
+     * Registers a listener to be notified about the faces detected in the
+     * preview frame.
+     * @internal
+     * @param listener the listener to notify
+     * @see #startObjectTracking(int x, int y)
+     */
+    public final void setObjectTrackingListener(ObjectTrackingListener listener) {
+        mObjectListener = listener;
+    }
+
+    /**
+     * @hide
+     * @internal
+     *
+     * Cancel continuous shot
+     */
+    public native void cancelContinuousShot();
+
+    /**
+     * @hide
+     * @internal
+     * @param speed : the speed set for continuous shot
+     * set speed of continuous shot(xx fps)
+     */
+    public native void setContinuousShotSpeed(int speed);
+
+    /**
+     * @hide
+     * An interface which contains a callback for the zero shutter delay preview
+     */
+    public interface ZSDPreviewDone {
+        public void onPreviewDone();
+    }
+
+    /**
+     * @hide
+     *
+     */
+    public interface PreviewRawDumpCallback {
+        public void onNotify(int code);
+    }
+
+    /**
+     * @hide
+     */
+    public void setPreviewRawDumpCallback(PreviewRawDumpCallback callback) {
+        mPreviewRawDumpCallback = callback;
+    }
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoked when a preview frame is done
+     * @param ZSDPreviewDone
+     */
+    public void setPreviewDoneCallback(ZSDPreviewDone callback) {
+        mPreviewDoneCallback = callback;
+    }
+
+    /**
+     * @hide
+     * An interface which contains a callback for the continuous shot
+     */
+    public interface ContinuousShotCallback {
+      /**
+        * @internal
+        * @param capture number
+        */
+        public void onConinuousShotDone(int capNum);
+    }
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoked when continuous shot is done
+     * @param ContinuousShotCallback
+     */
+    public void setContinuousShotCallback(ContinuousShotCallback callback) {
+        mCSDoneCallback = callback;
+    }
+    //!--
+
+    //!++
+    /**
+     * Determine if the target process is restricted to get the all preview size list
+     * TRUE means the device is restricted
+     * FALSE means the device is not restricted
+     *
+     * @hide
+     */
+    public static boolean isRestricted(int pid) {
+        boolean ret = false;
+        String f = "/proc/" + pid + "/cmdline";
+
+        FileInputStream in = null;
+        try {
+            in = new FileInputStream(f);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        }
+
+        InputStreamReader inReader = new InputStreamReader(in);
+        StringBuilder buffer = new StringBuilder();
+        char buf[] = new char[1];
+        try {
+            while (inReader.read(buf) != -1) {
+                buffer.append(buf[0]);
+            }
+            inReader.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        if (buffer.toString().contains("com.google.android.apps.unveil")) {
+            ret = true;
+        }
+        return ret;
+    }
+    /**
+     * M: Return the device's screen size
+     * The format is like: "800x480"
+     * The default screen size is "800x480"
+     *
+     * @hide
+     */
+    public static String getScreenSize() {
+        final String mHD720NOPK = "1184x720";
+        final String mWVGAScreenSize = "800x480";
+        final String mQhdScreenSize = "960x540";
+        final String m720P = "1280x720";
+        /// M: Default size is 800x480
+        String screenSize = mWVGAScreenSize;
+
+        /// M: Get screen size from display
+        android.hardware.display.DisplayManagerGlobal dmGlobal = android.hardware.display.DisplayManagerGlobal.getInstance();
+        android.view.Display dispaly = dmGlobal.getCompatibleDisplay(android.view.Display.DEFAULT_DISPLAY,
+                                                    android.view.DisplayAdjustments.DEFAULT_DISPLAY_ADJUSTMENTS);
+        android.graphics.Point size = new android.graphics.Point();
+        dispaly.getSize(size);
+
+        /// M: Put larger size in the front
+        if (size.x > size.y) {
+            screenSize = size.x + "x" + size.y;
+        } else {
+            screenSize = size.y + "x" + size.x;
+        }
+
+        /// M: For special screen size, change the return value
+        if (mHD720NOPK.equals(screenSize)) {
+            screenSize = mWVGAScreenSize;
+        } else if (mQhdScreenSize.equals(screenSize)) {
+            screenSize = mWVGAScreenSize;
+        } else if (m720P.equals(screenSize)) {
+            screenSize = mWVGAScreenSize;
+        }
+
+        Log.i(TAG, "Screen size = " + screenSize);
+        return screenSize;
+    }
+
+    /**
+     * @hide
+     *
+     * Enable stereo 3D camera mode
+     *
+     * This should be called before {@link #Camera.Parameters#getPreviewSize()), {@link #Camera.Parameters#getSupportedPreviewSizes()}.
+     * Otherwise, wrong sizes may be returned.
+     *
+     * @param enable true: enable stereo3d_mode, false: disable (default)
+     */
+    public void setStereo3DModeForCamera(boolean enable) {
+        mStereo3DModeForCamera = enable;
+    }
+    /**
+     * Returns an empty {@link Parameters} for testing purpose.
+     *
+     * @return a Parameter object.
+     *
+     * @hide
+     */
+    public static Parameters getEmptyParameters() {
+        Camera camera = new Camera();
+        return camera.new Parameters();
+    }
+
+    /* ### QC ADD-ONS: START */
+    private static int byteToInt(byte[] b, int offset) {
+        int value = 0;
+        for (int i = 0; i < 4; i++) {
+            int shift = (4 - 1 - i) * 8;
+            value += (b[(3-i) + offset] & 0x000000FF) << shift;
+        }
+        return value;
+    }
+    /** @hide
+     * Handles the callback for when Camera Data is available.
+     * data is read from the camera.
+     */
+    public interface CameraDataCallback {
+        /**
+         * Callback for when camera data is available.
+         *
+         * @param data   a int array of the camera data
+         * @param camera the Camera service object
+         */
+        void onCameraData(int[] data, Camera camera);
+    };
+
+    /** @hide
+     * Set camera histogram mode and registers a callback function to run.
+     *  Only valid after startPreview() has been called.
+     *
+     * @param cb the callback to run
+     */
+    public final void setHistogramMode(CameraDataCallback cb)
+    {
+        mCameraDataCallback = cb;
+        native_setHistogramMode(cb!=null);
+    }
+    private native final void native_setHistogramMode(boolean mode);
+
+    /** @hide
+     * Set camera histogram command to send data.
+     *
+     */
+    public final void sendHistogramData()
+    {
+        native_sendHistogramData();
+    }
+    private native final void native_sendHistogramData();
+
+    /** @hide
+     * Handles the callback for when Camera Meta Data is available.
+     * Meta data is read from the camera.
+     */
+    public interface CameraMetaDataCallback {
+        /**
+         * Callback for when camera meta data is available.
+         *
+         * @param data   a byte array of the camera meta data
+         * @param camera the Camera service object
+         */
+        void onCameraMetaData(byte[] data, Camera camera);
+    };
+
+    /** @hide
+     * Set camera meta data and registers a callback function to run.
+     *  Only valid after startPreview() has been called.
+     *
+     * @param cb the callback to run
+     */
+    public final void setMetadataCb(CameraMetaDataCallback cb)
+    {
+        mCameraMetaDataCallback = cb;
+        native_setMetadataCb(cb!=null);
+    }
+    private native final void native_setMetadataCb(boolean mode);
+
+    /** @hide
+     * Set camera face detection command to send meta data.
+     */
+    public final void sendMetaData()
+    {
+        native_sendMetaData();
+    }
+    private native final void native_sendMetaData();
+
+    /** @hide
+     * Configure longshot mode. Available only in ZSL.
+     *
+     * @param enable enable/disable this mode
+     */
+    public final void setLongshot(boolean enable)
+    {
+        native_setLongshot(enable);
+    }
+    private native final void native_setLongshot(boolean enable);
+
+    /** @hide
+     * Stop longshot. Available only in ZSL.
+     */
+    public final void stopLongshot()
+    {
+        native_stopLongshot();
+    }
+    private native final void native_stopLongshot();
+
+     /** @hide
+     * Handles the Touch Co-ordinate.
+     */
+     public class Coordinate {
+        /**
+         * Sets the x,y co-ordinates for a touch event
+         *
+         * @param x the x co-ordinate (pixels)
+         * @param y the y co-ordinate (pixels)
+         */
+        public Coordinate(int x, int y) {
+            xCoordinate = x;
+            yCoordinate = y;
+        }
+        /**
+         * Compares {@code obj} to this co-ordinate.
+         *
+         * @param obj the object to compare this co-ordinate with.
+         * @return {@code true} if the xCoordinate and yCoordinate of {@code obj} is the
+         *         same as those of this coordinate. {@code false} otherwise.
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Coordinate)) {
+                return false;
+            }
+            Coordinate c = (Coordinate) obj;
+            return xCoordinate == c.xCoordinate && yCoordinate == c.yCoordinate;
+        }
+
+        /** x co-ordinate for the touch event*/
+        public int xCoordinate;
+
+        /** y co-ordinate for the touch event */
+        public int yCoordinate;
+    };
+
+    /** @hide
+     * Returns the current focus position.
+     *
+     * If it's in AF mode, it's the lens position after af is done.
+     *
+     * If it's in Manual Focus mode, it actually returns the value
+     *     set by user via {@link #setParameters(Camera.Parameters)}.
+     */
+    public int getCurrentFocusPosition() {
+        Parameters p = new Parameters();
+        String s = native_getParameters();
+        p.unflatten(s);
+
+        int focus_pos = -1;
+        if (p.getCurrentFocusPosition() != null) {
+            focus_pos = Integer.parseInt(p.getCurrentFocusPosition());
+        }
+        return focus_pos;
+    }
+
+    /* ### QC ADD-ONS: END */
+    /**
+     * Returns a copied {@link Parameters}; for shim use only.
+     *
+     * @param parameters a non-{@code null} parameters
+     * @return a Parameter object, with all the parameters copied from {@code parameters}.
+     *
+     * @throws NullPointerException if {@code parameters} was {@code null}
+     * @hide
+     */
+    public static Parameters getParametersCopy(Camera.Parameters parameters) {
+        if (parameters == null) {
+            throw new NullPointerException("parameters must not be null");
+        }
+
+        Camera camera = parameters.getOuter();
+        Parameters p = camera.new Parameters();
+        p.copyFrom(parameters);
+
+        return p;
+    }
+
+    /**
+     * Image size (width and height dimensions).
+     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
+     *             applications.
+     */
+    @Deprecated
+    public class Size {
+        /**
+         * Sets the dimensions for pictures.
+         *
+         * @param w the photo width (pixels)
+         * @param h the photo height (pixels)
+         */
+        public Size(int w, int h) {
+            width = w;
+            height = h;
+        }
+        /**
+         * Compares {@code obj} to this size.
+         *
+         * @param obj the object to compare this size with.
+         * @return {@code true} if the width and height of {@code obj} is the
+         *         same as those of this size. {@code false} otherwise.
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Size)) {
+                return false;
+            }
+            Size s = (Size) obj;
+            return width == s.width && height == s.height;
+        }
+        @Override
+        public int hashCode() {
+            return width * 32713 + height;
+        }
+        /** width of the picture */
+        public int width;
+        /** height of the picture */
+        public int height;
+    };
+
+    /**
+     * <p>The Area class is used for choosing specific metering and focus areas for
+     * the camera to use when calculating auto-exposure, auto-white balance, and
+     * auto-focus.</p>
+     *
+     * <p>To find out how many simultaneous areas a given camera supports, use
+     * {@link Parameters#getMaxNumMeteringAreas()} and
+     * {@link Parameters#getMaxNumFocusAreas()}. If metering or focusing area
+     * selection is unsupported, these methods will return 0.</p>
+     *
+     * <p>Each Area consists of a rectangle specifying its bounds, and a weight
+     * that determines its importance. The bounds are relative to the camera's
+     * current field of view. The coordinates are mapped so that (-1000, -1000)
+     * is always the top-left corner of the current field of view, and (1000,
+     * 1000) is always the bottom-right corner of the current field of
+     * view. Setting Areas with bounds outside that range is not allowed. Areas
+     * with zero or negative width or height are not allowed.</p>
+     *
+     * <p>The weight must range from 1 to 1000, and represents a weight for
+     * every pixel in the area. This means that a large metering area with
+     * the same weight as a smaller area will have more effect in the
+     * metering result.  Metering areas can overlap and the driver
+     * will add the weights in the overlap region.</p>
+     *
+     * @see Parameters#setFocusAreas(List)
+     * @see Parameters#getFocusAreas()
+     * @see Parameters#getMaxNumFocusAreas()
+     * @see Parameters#setMeteringAreas(List)
+     * @see Parameters#getMeteringAreas()
+     * @see Parameters#getMaxNumMeteringAreas()
+     *
+     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
+     *             applications.
+     */
+    @Deprecated
+    public static class Area {
+        /**
+         * Create an area with specified rectangle and weight.
+         *
+         * @param rect the bounds of the area.
+         * @param weight the weight of the area.
+         */
+        public Area(Rect rect, int weight) {
+            this.rect = rect;
+            this.weight = weight;
+        }
+        /**
+         * Compares {@code obj} to this area.
+         *
+         * @param obj the object to compare this area with.
+         * @return {@code true} if the rectangle and weight of {@code obj} is
+         *         the same as those of this area. {@code false} otherwise.
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Area)) {
+                return false;
+            }
+            Area a = (Area) obj;
+            if (rect == null) {
+                if (a.rect != null) return false;
+            } else {
+                if (!rect.equals(a.rect)) return false;
+            }
+            return weight == a.weight;
+        }
+
+        /**
+         * Bounds of the area. (-1000, -1000) represents the top-left of the
+         * camera field of view, and (1000, 1000) represents the bottom-right of
+         * the field of view. Setting bounds outside that range is not
+         * allowed. Bounds with zero or negative width or height are not
+         * allowed.
+         *
+         * @see Parameters#getFocusAreas()
+         * @see Parameters#getMeteringAreas()
+         */
+        public Rect rect;
+
+        /**
+         * Weight of the area. The weight must range from 1 to 1000, and
+         * represents a weight for every pixel in the area. This means that a
+         * large metering area with the same weight as a smaller area will have
+         * more effect in the metering result.  Metering areas can overlap and
+         * the driver will add the weights in the overlap region.
+         *
+         * @see Parameters#getFocusAreas()
+         * @see Parameters#getMeteringAreas()
+         */
+        public int weight;
+    }
+
+    /**
+     * Camera service settings.
+     *
+     * <p>To make camera parameters take effect, applications have to call
+     * {@link Camera#setParameters(Camera.Parameters)}. For example, after
+     * {@link Camera.Parameters#setWhiteBalance} is called, white balance is not
+     * actually changed until {@link Camera#setParameters(Camera.Parameters)}
+     * is called with the changed parameters object.
+     *
+     * <p>Different devices may have different camera capabilities, such as
+     * picture size or flash modes. The application should query the camera
+     * capabilities before setting parameters. For example, the application
+     * should call {@link Camera.Parameters#getSupportedColorEffects()} before
+     * calling {@link Camera.Parameters#setColorEffect(String)}. If the
+     * camera does not support color effects,
+     * {@link Camera.Parameters#getSupportedColorEffects()} will return null.
+     *
+     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
+     *             applications.
+     */
+    @Deprecated
+    public class Parameters {
+        // Parameter keys to communicate with the camera driver.
+        private static final String KEY_PREVIEW_SIZE = "preview-size";
+        private static final String KEY_PREVIEW_FORMAT = "preview-format";
+        private static final String KEY_PREVIEW_FRAME_RATE = "preview-frame-rate";
+        private static final String KEY_PREVIEW_FPS_RANGE = "preview-fps-range";
+        private static final String KEY_PICTURE_SIZE = "picture-size";
+        private static final String KEY_PICTURE_FORMAT = "picture-format";
+        private static final String KEY_JPEG_THUMBNAIL_SIZE = "jpeg-thumbnail-size";
+        private static final String KEY_JPEG_THUMBNAIL_WIDTH = "jpeg-thumbnail-width";
+        private static final String KEY_JPEG_THUMBNAIL_HEIGHT = "jpeg-thumbnail-height";
+        private static final String KEY_JPEG_THUMBNAIL_QUALITY = "jpeg-thumbnail-quality";
+        private static final String KEY_JPEG_QUALITY = "jpeg-quality";
+        private static final String KEY_ROTATION = "rotation";
+        private static final String KEY_GPS_LATITUDE = "gps-latitude";
+        private static final String KEY_GPS_LONGITUDE = "gps-longitude";
+        private static final String KEY_GPS_ALTITUDE = "gps-altitude";
+        private static final String KEY_GPS_TIMESTAMP = "gps-timestamp";
+        private static final String KEY_GPS_PROCESSING_METHOD = "gps-processing-method";
+        private static final String KEY_WHITE_BALANCE = "whitebalance";
+        private static final String KEY_EFFECT = "effect";
+        private static final String KEY_ANTIBANDING = "antibanding";
+        private static final String KEY_SCENE_MODE = "scene-mode";
+        private static final String KEY_FLASH_MODE = "flash-mode";
+        private static final String KEY_FOCUS_MODE = "focus-mode";
+        private static final String KEY_FOCUS_AREAS = "focus-areas";
+        private static final String KEY_MAX_NUM_FOCUS_AREAS = "max-num-focus-areas";
+        private static final String KEY_FOCAL_LENGTH = "focal-length";
+        private static final String KEY_HORIZONTAL_VIEW_ANGLE = "horizontal-view-angle";
+        private static final String KEY_VERTICAL_VIEW_ANGLE = "vertical-view-angle";
+        private static final String KEY_EXPOSURE_COMPENSATION = "exposure-compensation";
+        private static final String KEY_MAX_EXPOSURE_COMPENSATION = "max-exposure-compensation";
+        private static final String KEY_MIN_EXPOSURE_COMPENSATION = "min-exposure-compensation";
+        private static final String KEY_EXPOSURE_COMPENSATION_STEP = "exposure-compensation-step";
+        private static final String KEY_AUTO_EXPOSURE_LOCK = "auto-exposure-lock";
+        private static final String KEY_AUTO_EXPOSURE_LOCK_SUPPORTED = "auto-exposure-lock-supported";
+        private static final String KEY_AUTO_WHITEBALANCE_LOCK = "auto-whitebalance-lock";
+        private static final String KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED = "auto-whitebalance-lock-supported";
+        private static final String KEY_METERING_AREAS = "metering-areas";
+        private static final String KEY_MAX_NUM_METERING_AREAS = "max-num-metering-areas";
+        private static final String KEY_ZOOM = "zoom";
+        private static final String KEY_MAX_ZOOM = "max-zoom";
+        private static final String KEY_ZOOM_RATIOS = "zoom-ratios";
+        private static final String KEY_ZOOM_SUPPORTED = "zoom-supported";
+        private static final String KEY_SMOOTH_ZOOM_SUPPORTED = "smooth-zoom-supported";
+        private static final String KEY_FOCUS_DISTANCES = "focus-distances";
+        private static final String KEY_VIDEO_SIZE = "video-size";
+        private static final String KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO =
+                                            "preferred-preview-size-for-video";
+        private static final String KEY_HSVR_PRV_SIZE = "hsvr-prv-size";
+        private static final String KEY_HSVR_PRV_FPS = "hsvr-prv-fps";
+        private static final String KEY_MAX_NUM_DETECTED_FACES_HW = "max-num-detected-faces-hw";
+        private static final String KEY_MAX_NUM_DETECTED_FACES_SW = "max-num-detected-faces-sw";
+        private static final String KEY_RECORDING_HINT = "recording-hint";
+        private static final String KEY_VIDEO_SNAPSHOT_SUPPORTED = "video-snapshot-supported";
+        private static final String KEY_VIDEO_STABILIZATION = "video-stabilization";
+        private static final String KEY_VIDEO_STABILIZATION_SUPPORTED = "video-stabilization-supported";
+        private static final String KEY_PDAF_SUPPORTED = "pdaf-supported";
+        //!++
+        private static final String KEY_ISOSPEED_MODE = "iso-speed";
+        private static final String KEY_FD_MODE = "fd-mode";
+        private static final String KEY_EDGE_MODE = "edge";
+        private static final String KEY_HUE_MODE = "hue";
+        private static final String KEY_SATURATION_MODE = "saturation";
+        private static final String KEY_BRIGHTNESS_MODE = "brightness";
+        private static final String KEY_CONTRAST_MODE = "contrast";
+        private static final String KEY_CAMERA_MODE = "mtk-cam-mode";
+        private static final String KEY_FPS_MODE = "fps-mode";
+        private static final String KEY_RAW_SAVE_MODE = "rawsave-mode";
+        private static final String KEY_FOCUS_ENG_MODE = "afeng-mode";
+        private static final String KEY_FOCUS_ENG_STEP = "afeng-pos";
+        private static final String KEY_FOCUS_ENG_MAX_STEP = "afeng-max-focus-step";
+        private static final String KEY_FOCUS_ENG_MIN_STEP = "afeng-min-focus-step";
+        private static final String KEY_FOCUS_ENG_BEST_STEP = "afeng-best-focus-step";
+        private static final String KEY_RAW_DUMP_FLAG = "afeng_raw_dump_flag";
+        private static final String KEY_PREVIEW_DUMP_RESOLUTION = "prv-dump-res";
+
+        private static final String KEY_ENG_AE_ENABLE = "ae-e";
+        private static final String KEY_ENG_PREVIEW_SHUTTER_SPEED = "prv-ss";
+        private static final String KEY_ENG_PREVIEW_SENSOR_GAIN = "prv-sr-g";
+        private static final String KEY_ENG_PREVIEW_ISP_GAIN = "prv-isp-g";
+        private static final String KEY_ENG_PREVIEW_AE_INDEX = "prv-ae-i";
+        private static final String KEY_ENG_CAPTURE_SENSOR_GAIN = "cap-sr-g";
+        private static final String KEY_ENG_CAPTURE_ISP_GAIN = "cap-isp-g";
+        private static final String KEY_ENG_CAPTURE_SHUTTER_SPEED = "cap-ss";
+        private static final String KEY_ENG_CAPTURE_ISO = "cap-iso";
+        private static final String KEY_ENG_FLASH_DUTY_VALUE = "flash-duty-value";
+        private static final String KEY_ENG_FLASH_DUTY_MIN = "flash-duty-min";
+        private static final String KEY_ENG_FLASH_DUTY_MAX = "flash-duty-max";
+        private static final String KEY_ENG_ZSD_ENABLE = "eng-zsd-e";
+        private static final String KEY_SENSOR_TYPE = "sensor-type";
+        private static final String KEY_ENG_PREVIEW_FPS = "eng-prv-fps";
+        private static final String KEY_ENG_MSG = "eng-msg";
+        private static final String KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL = "focus-fs-fi";
+        private static final String KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX = "focus-fs-fi-max";
+        private static final String KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN = "focus-fs-fi-min";
+        private static final String KEY_ENG_PREVIEW_FRAME_INTERVAL_IN_US = "eng-prv-fius";
+        private static final String KEY_ENG_PARAMETER1 = "eng-p1";
+        private static final String KEY_ENG_PARAMETER2 = "eng-p2";
+        private static final String KEY_ENG_PARAMETER3 = "eng-p3";
+        private static final String KEY_ENG_SAVE_SHADING_TABLE = "eng-s-shad-t";
+        private static final String KEY_ENG_SHADING_TABLE = "eng-shad-t";
+        private static final String KEY_ENG_EV_CALBRATION_OFFSET_VALUE = "ev-cal-o";
+        private static final String KEY_ENG_MFLL_SUPPORTED = "eng-mfll-s";
+        private static final String KEY_ENG_MFLL_ENABLE = "eng-mfll-e";
+        private static final String KEY_ENG_MFLL_PICTURE_COUNT = "eng-mfll-pc";
+        private static final String KEY_ENG_SENOSR_MODE_SLIM_VIDEO1_SUPPORTED = "sv1-s";
+        private static final String KEY_ENG_SENOSR_MODE_SLIM_VIDEO2_SUPPORTED = "sv2-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_2M_SUPPORTED = "vdr-r2m-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_4K2K_SUPPORTED = "vdr-r4k2k-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_CROP_CENTER_2M_SUPPORTED = "vdr-cc2m-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_SUPPORTED = "vrd-mfr-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_ENABLE = "vrd-mfr-e";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MIN = "vrd-mfr-min";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MAX = "vrd-mfr-max";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_LOW = "vrd-mfr-low";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_HIGH = "vrd-mfr-high";
+        private static final String KEY_ENG_MTK_AWB_SUPPORTED = "mtk-awb-s";
+        private static final String KEY_ENG_SENSOR_AWB_SUPPORTED = "sr-awb-s";
+        private static final String KEY_ENG_MTK_AWB_ENABLE = "mtk-awb-e";
+        private static final String KEY_ENG_SENSOR_AWB_ENABLE = "sr-awb-e";
+        private static final String KEY_ENG_MTK_SHADING_SUPPORTED = "mtk-shad-s";
+        private static final String KEY_ENG_MTK_1to3_SHADING_SUPPORTED = "mtk-123-shad-s";
+        private static final String KEY_ENG_SENSOR_SHADNING_SUPPORTED = "sr-shad-s";
+        private static final String KEY_ENG_MTK_SHADING_ENABLE = "mtk-shad-e";
+        private static final String KEY_ENG_MTK_1to3_SHADING_ENABLE = "mtk-123-shad-e";
+        private static final String KEY_ENG_SENSOR_SHADNING_ENABLE = "sr-shad-e";
+
+        private static final String KEY_CAPTURE_MODE = "cap-mode";
+        private static final String KEY_CAPTURE_PATH = "capfname";
+        private static final String KEY_BURST_SHOT_NUM = "burst-num";
+        private static final String KEY_MATV_PREVIEW_DELAY = "tv-delay";
+        private static final String KEY_SENSOR_DEV = "sensor-dev";
+        private static final String KEY_EIS_MODE = "eis-mode";
+        private static final String KEY_AFLAMP_MODE = "aflamp-mode";
+        private static final String KEY_ZSD_MODE = "zsd-mode";
+        private static final String KEY_CONTINUOUS_SPEED_MODE = "continuous-shot-speed";
+        //
+        private static final String KEY_ZSD_SUPPORTED = "zsd-supported";
+    private static final String KEY_MUTE_RECORDING_SOUND = "rec-mute-ogg";
+        // Exposure meter mode for OT
+        private static final String KEY_EXPOSURE_METER_MODE = "exposure-meter";
+        // add for pip
+        private static final String KEY_MAX_FRAME_RATE_ZSD_ON = "pip-fps-zsd-on";
+        private static final String KEY_MAX_FRAME_RATE_ZSD_OFF = "pip-fps-zsd-off";
+        private static final String KEY_DYNAMIC_FRAME_RATE = "dynamic-frame-rate";
+        private static final String KEY_DYNAMIC_FRAME_RATE_SUPPORTED = "dynamic-frame-rate-supported";
+        // add for image refocus
+        private static final String KEY_REFOCUS_JPS_FILE_NAME = "refocus-jps-file-name";
+        private static final String KEY_STEREO_REFOCUS_MODE = "stereo-image-refocus";
+        private static final String KEY_STEREO_DEPTHAF_MODE = "stereo-depth-af";
+        private static final String KEY_STEREO_DISTANCE_MODE = "stereo-distance-measurement";
+    /**
+     * @hide
+    */
+        public static final String WHITE_BALANCE_TUNGSTEN = "tungsten";
+        //!--
+        // Parameter key suffix for supported values.
+        private static final String SUPPORTED_VALUES_SUFFIX = "-values";
+
+        private static final String TRUE = "true";
+        private static final String FALSE = "false";
+
+        // Values for white balance settings.
+        public static final String WHITE_BALANCE_AUTO = "auto";
+        public static final String WHITE_BALANCE_INCANDESCENT = "incandescent";
+        public static final String WHITE_BALANCE_FLUORESCENT = "fluorescent";
+        public static final String WHITE_BALANCE_WARM_FLUORESCENT = "warm-fluorescent";
+        public static final String WHITE_BALANCE_DAYLIGHT = "daylight";
+        public static final String WHITE_BALANCE_CLOUDY_DAYLIGHT = "cloudy-daylight";
+        public static final String WHITE_BALANCE_TWILIGHT = "twilight";
+        public static final String WHITE_BALANCE_SHADE = "shade";
+        /** @hide
+         * wb manual cct mode.
+         */
+        public static final String WHITE_BALANCE_MANUAL_CCT = "manual-cct";
+
+        // Values for color effect settings.
+        public static final String EFFECT_NONE = "none";
+        public static final String EFFECT_MONO = "mono";
+        public static final String EFFECT_NEGATIVE = "negative";
+        public static final String EFFECT_SOLARIZE = "solarize";
+        public static final String EFFECT_SEPIA = "sepia";
+        public static final String EFFECT_POSTERIZE = "posterize";
+        public static final String EFFECT_WHITEBOARD = "whiteboard";
+        public static final String EFFECT_BLACKBOARD = "blackboard";
+        public static final String EFFECT_AQUA = "aqua";
+
+        // Values for antibanding settings.
+        public static final String ANTIBANDING_AUTO = "auto";
+        public static final String ANTIBANDING_50HZ = "50hz";
+        public static final String ANTIBANDING_60HZ = "60hz";
+        public static final String ANTIBANDING_OFF = "off";
+
+        //!++
+        // Add for STEREO 3D
+
+        private static final String ON = "on";
+        private static final String OFF = "off";
+        /**
+         *@hide
+         */
+        private static final String KEY_STEREO3D_PRE = "stereo3d-";
+        /**
+         *@hide
+         */
+        public static final String KEY_STEREO3D_TYPE = "type";
+        /**
+         *@hide
+         */
+        public static final String KEY_STEREO3D_MODE = "mode";
+        /**
+         *@hide
+         */
+        public static final String STEREO3D_TYPE_OFF = "off";
+        /**
+         * Frame sequential
+         *@hide
+         */
+        public static final String STEREO3D_TYPE_FRAMESEQ = "frame_seq";
+        /**
+         * Side-by-side
+         *@hide
+         */
+        public static final String STEREO3D_TYPE_SIDEBYSIDE = "sidebyside";
+        /**
+         * Top-bottom
+         *@hide
+         */
+        public static final String STEREO3D_TYPE_TOPBOTTOM = "topbottom";
+        /**
+         *@hide
+         */
+        private boolean mStereo3DMode = false;
+        //for EIS mode
+        /**
+         * Eletric image stablization on
+         * @hide
+         */
+        public static final String EIS_MODE_ON = "on";
+        /**
+         * Eletric image stablization off
+         * @hide
+         */
+        public static final String EIS_MODE_OFF = "off";
+        //!--
+
+        // Values for flash mode settings.
+        /**
+         * Flash will not be fired.
+         */
+        public static final String FLASH_MODE_OFF = "off";
+
+        /**
+         * Flash will be fired automatically when required. The flash may be fired
+         * during preview, auto-focus, or snapshot depending on the driver.
+         */
+        public static final String FLASH_MODE_AUTO = "auto";
+
+        /**
+         * Flash will always be fired during snapshot. The flash may also be
+         * fired during preview or auto-focus depending on the driver.
+         */
+        public static final String FLASH_MODE_ON = "on";
+
+        /**
+         * Flash will be fired in red-eye reduction mode.
+         */
+        public static final String FLASH_MODE_RED_EYE = "red-eye";
+
+        /**
+         * Constant emission of light during preview, auto-focus and snapshot.
+         * This can also be used for video recording.
+         */
+        public static final String FLASH_MODE_TORCH = "torch";
+
+        /** @hide
+         * Scene mode is off.
+         */
+        public static final String SCENE_MODE_ASD = "asd";
+
+        /**
+         * Scene mode is off.
+         */
+        public static final String SCENE_MODE_AUTO = "auto";
+
+        /**
+         * Take photos of fast moving objects. Same as {@link
+         * #SCENE_MODE_SPORTS}.
+         */
+        public static final String SCENE_MODE_ACTION = "action";
+
+        /**
+         * Take people pictures.
+         */
+        public static final String SCENE_MODE_PORTRAIT = "portrait";
+
+        /**
+         * Take pictures on distant objects.
+         */
+        public static final String SCENE_MODE_LANDSCAPE = "landscape";
+
+        /**
+         * Take photos at night.
+         */
+        public static final String SCENE_MODE_NIGHT = "night";
+
+        /**
+         * Take people pictures at night.
+         */
+        public static final String SCENE_MODE_NIGHT_PORTRAIT = "night-portrait";
+
+        /**
+         * Take photos in a theater. Flash light is off.
+         */
+        public static final String SCENE_MODE_THEATRE = "theatre";
+
+        /**
+         * Take pictures on the beach.
+         */
+        public static final String SCENE_MODE_BEACH = "beach";
+
+        /**
+         * Take pictures on the snow.
+         */
+        public static final String SCENE_MODE_SNOW = "snow";
+
+        /**
+         * Take sunset photos.
+         */
+        public static final String SCENE_MODE_SUNSET = "sunset";
+
+        /**
+         * Avoid blurry pictures (for example, due to hand shake).
+         */
+        public static final String SCENE_MODE_STEADYPHOTO = "steadyphoto";
+
+        /**
+         * For shooting firework displays.
+         */
+        public static final String SCENE_MODE_FIREWORKS = "fireworks";
+
+        /**
+         * Take photos of fast moving objects. Same as {@link
+         * #SCENE_MODE_ACTION}.
+         */
+        public static final String SCENE_MODE_SPORTS = "sports";
+
+        /**
+         * Take indoor low-light shot.
+         */
+        public static final String SCENE_MODE_PARTY = "party";
+
+        /**
+         * Capture the naturally warm color of scenes lit by candles.
+         */
+        public static final String SCENE_MODE_CANDLELIGHT = "candlelight";
+        /** @hide
+        * SCENE_MODE_BACKLIGHT
+        **/
+        public static final String SCENE_MODE_BACKLIGHT = "backlight";
+        /** @hide
+        * SCENE_MODE_FLOWERS
+        **/
+        public static final String SCENE_MODE_FLOWERS = "flowers";
+
+        /**
+         * Applications are looking for a barcode. Camera driver will be
+         * optimized for barcode reading.
+         */
+        public static final String SCENE_MODE_BARCODE = "barcode";
+
+        /**
+         * Capture a scene using high dynamic range imaging techniques. The
+         * camera will return an image that has an extended dynamic range
+         * compared to a regular capture. Capturing such an image may take
+         * longer than a regular capture.
+         */
+        public static final String SCENE_MODE_HDR = "hdr";
+
+        /**
+         * Auto-focus mode. Applications should call {@link
+         * #autoFocus(AutoFocusCallback)} to start the focus in this mode.
+         */
+        public static final String FOCUS_MODE_AUTO = "auto";
+
+        /**
+         * Focus is set at infinity. Applications should not call
+         * {@link #autoFocus(AutoFocusCallback)} in this mode.
+         */
+        public static final String FOCUS_MODE_INFINITY = "infinity";
+
+        /**
+         * Macro (close-up) focus mode. Applications should call
+         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
+         * mode.
+         */
+        public static final String FOCUS_MODE_MACRO = "macro";
+
+        /**
+         * Focus is fixed. The camera is always in this mode if the focus is not
+         * adjustable. If the camera has auto-focus, this mode can fix the
+         * focus, which is usually at hyperfocal distance. Applications should
+         * not call {@link #autoFocus(AutoFocusCallback)} in this mode.
+         */
+        public static final String FOCUS_MODE_FIXED = "fixed";
+
+        /** @hide
+         * Normal focus mode. Applications should call
+         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
+         * mode.
+         */
+        public static final String FOCUS_MODE_NORMAL = "normal";
+
+        /**
+         * Extended depth of field (EDOF). Focusing is done digitally and
+         * continuously. Applications should not call {@link
+         * #autoFocus(AutoFocusCallback)} in this mode.
+         */
+        public static final String FOCUS_MODE_EDOF = "edof";
+
+       //!++
+        /*
+         * for Camera mode
+        */
+        /**
+          * @hide
+         */
+        public static final int CAMERA_MODE_NORMAL  = 0;
+        /**
+          * @hide
+         */
+        public static final int CAMERA_MODE_MTK_PRV = 1;
+        /**
+          * @hide
+         */
+        public static final int CAMERA_MODE_MTK_VDO = 2;
+        /**
+          * @hide
+         */
+        public static final int CAMERA_MODE_MTK_VT  = 3;
+
+        /*
+         * for AF engineer mode
+        */
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_NONE = 0;
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_BRACKET = 1;
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_FULLSCAN = 2;
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_FULLSCAN_REPEAT = 3;
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_REPEAT = 4;
+        /**
+          * @hide
+         */
+        public static final String FOCUS_MODE_MANUAL = "manual";
+        /**
+          * @hide
+         */
+        public static final String FOCUS_MODE_FULLSCAN = "fullscan";
+
+        /**
+          * @hide
+         */
+        public static final int PREVIEW_DUMP_RESOLUTION_NORMAL  = 0;
+        /**
+          * @hide
+         */
+        public static final int PREVIEW_DUMP_RESOLUTION_CROP = 1;
+
+
+        // Values for capture mode settings.
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_NORMAL = "normal";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_BEST_SHOT = "bestshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_EV_BRACKET_SHOT = "evbracketshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_BURST_SHOT = "burstshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_SMILE_SHOT = "smileshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_GESTURE_SHOT = "gestureshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_PANORAMA_SHOT = "autorama";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_HDR = "hdr";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_ASD = "asd";
+        /**
+         * @hide
+         */
+        public static final String CAPTURE_MODE_FB = "face_beauty";
+        /**
+         * @hide
+         */
+        public static final String KEY_MAX_NUM_DETECTED_OBJECT = "max-num-ot";
+        /**
+         * @hide
+         */
+        public static final String CAPTURE_MODE_S3D = "single3d";
+        /**
+         * @hide
+         */
+        public static final String CAPTURE_MODE_PANORAMA3D = "panorama3dmode";
+        /**
+         * @hide
+         */
+        public static final String CAPTURE_MODE_CONTINUOUS_SHOT = "continuousshot";
 
-        // Parameter key suffix for supported values.
-        private static final String SUPPORTED_VALUES_SUFFIX = "-values";
+        // Values for KEY_SENSOR_DEV
+        /**
+         * @hide
+         */
+        public static final String SENSOR_DEV_MAIN = "main";
+        /**
+         * @hide
+         */
+        public static final String SENSOR_DEV_SUB =  "sub";
+        /**
+         * @hide
+         */
+        public static final String SENSOR_DEV_ATV = "atv";
+        //!--
 
-        private static final String TRUE = "true";
-        private static final String FALSE = "false";
+        /**
+         * Continuous auto focus mode intended for video recording. The camera
+         * continuously tries to focus. This is the best choice for video
+         * recording because the focus changes smoothly . Applications still can
+         * call {@link #takePicture(Camera.ShutterCallback,
+         * Camera.PictureCallback, Camera.PictureCallback)} in this mode but the
+         * subject may not be in focus. Auto focus starts when the parameter is
+         * set.
+         *
+         * <p>Since API level 14, applications can call {@link
+         * #autoFocus(AutoFocusCallback)} in this mode. The focus callback will
+         * immediately return with a boolean that indicates whether the focus is
+         * sharp or not. The focus position is locked after autoFocus call. If
+         * applications want to resume the continuous focus, cancelAutoFocus
+         * must be called. Restarting the preview will not resume the continuous
+         * autofocus. To stop continuous focus, applications should change the
+         * focus mode to other modes.
+         *
+         * @see #FOCUS_MODE_CONTINUOUS_PICTURE
+         */
+        public static final String FOCUS_MODE_CONTINUOUS_VIDEO = "continuous-video";
+
+        /**
+         * Continuous auto focus mode intended for taking pictures. The camera
+         * continuously tries to focus. The speed of focus change is more
+         * aggressive than {@link #FOCUS_MODE_CONTINUOUS_VIDEO}. Auto focus
+         * starts when the parameter is set.
+         *
+         * <p>Applications can call {@link #autoFocus(AutoFocusCallback)} in
+         * this mode. If the autofocus is in the middle of scanning, the focus
+         * callback will return when it completes. If the autofocus is not
+         * scanning, the focus callback will immediately return with a boolean
+         * that indicates whether the focus is sharp or not. The apps can then
+         * decide if they want to take a picture immediately or to change the
+         * focus mode to auto, and run a full autofocus cycle. The focus
+         * position is locked after autoFocus call. If applications want to
+         * resume the continuous focus, cancelAutoFocus must be called.
+         * Restarting the preview will not resume the continuous autofocus. To
+         * stop continuous focus, applications should change the focus mode to
+         * other modes.
+         *
+         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         */
+        public static final String FOCUS_MODE_CONTINUOUS_PICTURE = "continuous-picture";
 
-        // Values for white balance settings.
-        public static final String WHITE_BALANCE_AUTO = "auto";
-        public static final String WHITE_BALANCE_INCANDESCENT = "incandescent";
-        public static final String WHITE_BALANCE_FLUORESCENT = "fluorescent";
-        public static final String WHITE_BALANCE_WARM_FLUORESCENT = "warm-fluorescent";
-        public static final String WHITE_BALANCE_DAYLIGHT = "daylight";
-        public static final String WHITE_BALANCE_CLOUDY_DAYLIGHT = "cloudy-daylight";
-        public static final String WHITE_BALANCE_TWILIGHT = "twilight";
-        public static final String WHITE_BALANCE_SHADE = "shade";
         /** @hide
-         * wb manual cct mode.
+         *  manual focus mode
          */
-        public static final String WHITE_BALANCE_MANUAL_CCT = "manual-cct";
+        public static final String FOCUS_MODE_MANUAL_POSITION = "manual";
 
-        // Values for color effect settings.
-        public static final String EFFECT_NONE = "none";
-        public static final String EFFECT_MONO = "mono";
-        public static final String EFFECT_NEGATIVE = "negative";
-        public static final String EFFECT_SOLARIZE = "solarize";
-        public static final String EFFECT_SEPIA = "sepia";
-        public static final String EFFECT_POSTERIZE = "posterize";
-        public static final String EFFECT_WHITEBOARD = "whiteboard";
-        public static final String EFFECT_BLACKBOARD = "blackboard";
-        public static final String EFFECT_AQUA = "aqua";
+        // Indices for focus distance array.
+        /**
+         * The array index of near focus distance for use with
+         * {@link #getFocusDistances(float[])}.
+         */
+        public static final int FOCUS_DISTANCE_NEAR_INDEX = 0;
 
-        // Values for antibanding settings.
-        public static final String ANTIBANDING_AUTO = "auto";
-        public static final String ANTIBANDING_50HZ = "50hz";
-        public static final String ANTIBANDING_60HZ = "60hz";
-        public static final String ANTIBANDING_OFF = "off";
+        /**
+         * The array index of optimal focus distance for use with
+         * {@link #getFocusDistances(float[])}.
+         */
+        public static final int FOCUS_DISTANCE_OPTIMAL_INDEX = 1;
 
-        // Values for flash mode settings.
         /**
-         * Flash will not be fired.
+         * The array index of far focus distance for use with
+         * {@link #getFocusDistances(float[])}.
          */
-        public static final String FLASH_MODE_OFF = "off";
+        public static final int FOCUS_DISTANCE_FAR_INDEX = 2;
 
         /**
-         * Flash will be fired automatically when required. The flash may be fired
-         * during preview, auto-focus, or snapshot depending on the driver.
+         * The array index of minimum preview fps for use with {@link
+         * #getPreviewFpsRange(int[])} or {@link
+         * #getSupportedPreviewFpsRange()}.
          */
-        public static final String FLASH_MODE_AUTO = "auto";
+        public static final int PREVIEW_FPS_MIN_INDEX = 0;
 
         /**
-         * Flash will always be fired during snapshot. The flash may also be
-         * fired during preview or auto-focus depending on the driver.
+         * The array index of maximum preview fps for use with {@link
+         * #getPreviewFpsRange(int[])} or {@link
+         * #getSupportedPreviewFpsRange()}.
          */
-        public static final String FLASH_MODE_ON = "on";
+        public static final int PREVIEW_FPS_MAX_INDEX = 1;
+
+        // Formats for setPreviewFormat and setPictureFormat.
+        private static final String PIXEL_FORMAT_YUV422SP = "yuv422sp";
+        private static final String PIXEL_FORMAT_YUV420SP = "yuv420sp";
+        private static final String PIXEL_FORMAT_YUV420SP_ADRENO = "yuv420sp-adreno";
+        private static final String PIXEL_FORMAT_YUV422I = "yuv422i-yuyv";
+        private static final String PIXEL_FORMAT_YUV420P = "yuv420p";
+        private static final String PIXEL_FORMAT_RGB565 = "rgb565";
+        private static final String PIXEL_FORMAT_JPEG = "jpeg";
+        private static final String PIXEL_FORMAT_BAYER_RGGB = "bayer-rggb";
+        private static final String PIXEL_FORMAT_RAW = "raw";
+        private static final String PIXEL_FORMAT_YV12 = "yv12";
+        private static final String PIXEL_FORMAT_NV12 = "nv12";
+
+        /**
+         * Order matters: Keys that are {@link #set(String, String) set} later
+         * will take precedence over keys that are set earlier (if the two keys
+         * conflict with each other).
+         *
+         * <p>One example is {@link #setPreviewFpsRange(int, int)} , since it
+         * conflicts with {@link #setPreviewFrameRate(int)} whichever key is set later
+         * is the one that will take precedence.
+         * </p>
+         */
+        private final LinkedHashMap<String, String> mMap;
+
+        private Parameters() {
+            mMap = new LinkedHashMap<String, String>(/*initialCapacity*/64);
+        }
+
+        /**
+         * @hide
+         */
+        private Parameters(LinkedHashMap map) {
+            mMap = new LinkedHashMap<String, String>(map);
+        }
+
+        /**
+         * Clone parameter from current settings.
+         * @hide
+         * @return the clone parameter
+         */
+        public Parameters copy() {
+            return new Parameters(mMap);
+        }
+         /**
+         * Overwrite existing parameters with a copy of the ones from {@code other}.
+         *
+         * <b>For use by the legacy shim only.</b>
+         *
+         * @hide
+         */
+        public void copyFrom(Parameters other) {
+            if (other == null) {
+                throw new NullPointerException("other must not be null");
+            }
+
+            mMap.putAll(other.mMap);
+        }
+
+        private Camera getOuter() {
+            return Camera.this;
+        }
+
+
+        /**
+         * Value equality check.
+         *
+         * @hide
+         */
+        public boolean same(Parameters other) {
+            if (this == other) {
+                return true;
+            }
+            return other != null && Parameters.this.mMap.equals(other.mMap);
+        }
+
+        /**
+         * Writes the current Parameters to the log.
+         * @hide
+         * @deprecated
+         */
+        @Deprecated
+        public void dump() {
+            Log.e(TAG, "dump: size=" + mMap.size());
+            for (String k : mMap.keySet()) {
+                Log.e(TAG, "dump: " + k + "=" + mMap.get(k));
+            }
+        }
+
+        /**
+         * Creates a single string with all the parameters set in
+         * this Parameters object.
+         * <p>The {@link #unflatten(String)} method does the reverse.</p>
+         *
+         * @return a String with all values from this Parameters object, in
+         *         semi-colon delimited key-value pairs
+         */
+        public String flatten() {
+            StringBuilder flattened = new StringBuilder(128);
+            for (String k : mMap.keySet()) {
+                flattened.append(k);
+                flattened.append("=");
+                flattened.append(mMap.get(k));
+                flattened.append(";");
+            }
+            // chop off the extra semicolon at the end
+            flattened.deleteCharAt(flattened.length()-1);
+            return flattened.toString();
+        }
+
+        /**
+         * Takes a flattened string of parameters and adds each one to
+         * this Parameters object.
+         * <p>The {@link #flatten()} method does the reverse.</p>
+         *
+         * @param flattened a String of parameters (key-value paired) that
+         *                  are semi-colon delimited
+         */
+        public void unflatten(String flattened) {
+            mMap.clear();
+
+            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(';');
+            splitter.setString(flattened);
+            for (String kv : splitter) {
+                int pos = kv.indexOf('=');
+                if (pos == -1) {
+                    continue;
+                }
+                String k = kv.substring(0, pos);
+                String v = kv.substring(pos + 1);
+                mMap.put(k, v);
+            }
+        }
 
-        /**
-         * Flash will be fired in red-eye reduction mode.
-         */
-        public static final String FLASH_MODE_RED_EYE = "red-eye";
+        public void remove(String key) {
+            mMap.remove(key);
+        }
 
         /**
-         * Constant emission of light during preview, auto-focus and snapshot.
-         * This can also be used for video recording.
+         * Sets a String parameter.
+         *
+         * @param key   the key name for the parameter
+         * @param value the String value of the parameter
          */
-        public static final String FLASH_MODE_TORCH = "torch";
+        public void set(String key, String value) {
+            if (key.indexOf('=') != -1 || key.indexOf(';') != -1 || key.indexOf(0) != -1) {
+                Log.e(TAG, "Key \"" + key + "\" contains invalid character (= or ; or \\0)");
+                return;
+            }
+            if (value.indexOf('=') != -1 || value.indexOf(';') != -1 || value.indexOf(0) != -1) {
+                Log.e(TAG, "Value \"" + value + "\" contains invalid character (= or ; or \\0)");
+                return;
+            }
 
-        /** @hide
-         * Scene mode is off.
-         */
-        public static final String SCENE_MODE_ASD = "asd";
+            put(key, value);
+        }
 
         /**
-         * Scene mode is off.
+         * Sets an integer parameter.
+         *
+         * @param key   the key name for the parameter
+         * @param value the int value of the parameter
          */
-        public static final String SCENE_MODE_AUTO = "auto";
+        public void set(String key, int value) {
+            put(key, Integer.toString(value));
+        }
 
-        /**
-         * Take photos of fast moving objects. Same as {@link
-         * #SCENE_MODE_SPORTS}.
-         */
-        public static final String SCENE_MODE_ACTION = "action";
+        private void put(String key, String value) {
+            /*
+             * Remove the key if it already exists.
+             *
+             * This way setting a new value for an already existing key will always move
+             * that key to be ordered the latest in the map.
+             */
+            mMap.remove(key);
+            mMap.put(key, value);
+        }
 
-        /**
-         * Take people pictures.
-         */
-        public static final String SCENE_MODE_PORTRAIT = "portrait";
+        private void set(String key, List<Area> areas) {
+            if (areas == null) {
+                set(key, "(0,0,0,0,0)");
+            } else {
+                StringBuilder buffer = new StringBuilder();
+                for (int i = 0; i < areas.size(); i++) {
+                    Area area = areas.get(i);
+                    Rect rect = area.rect;
+                    buffer.append('(');
+                    buffer.append(rect.left);
+                    buffer.append(',');
+                    buffer.append(rect.top);
+                    buffer.append(',');
+                    buffer.append(rect.right);
+                    buffer.append(',');
+                    buffer.append(rect.bottom);
+                    buffer.append(',');
+                    buffer.append(area.weight);
+                    buffer.append(')');
+                    if (i != areas.size() - 1) buffer.append(',');
+                }
+                set(key, buffer.toString());
+            }
+        }
 
         /**
-         * Take pictures on distant objects.
+         * Returns the value of a String parameter.
+         *
+         * @param key the key name for the parameter
+         * @return the String value of the parameter
          */
-        public static final String SCENE_MODE_LANDSCAPE = "landscape";
+        public String get(String key) {
+            return mMap.get(key);
+        }
 
         /**
-         * Take photos at night.
+         * Returns the value of an integer parameter.
+         *
+         * @param key the key name for the parameter
+         * @return the int value of the parameter
          */
-        public static final String SCENE_MODE_NIGHT = "night";
+        public int getInt(String key) {
+            return Integer.parseInt(mMap.get(key));
+        }
 
         /**
-         * Take people pictures at night.
+         * Sets the dimensions for preview pictures. If the preview has already
+         * started, applications should stop the preview first before changing
+         * preview size.
+         *
+         * The sides of width and height are based on camera orientation. That
+         * is, the preview size is the size before it is rotated by display
+         * orientation. So applications need to consider the display orientation
+         * while setting preview size. For example, suppose the camera supports
+         * both 480x320 and 320x480 preview sizes. The application wants a 3:2
+         * preview ratio. If the display orientation is set to 0 or 180, preview
+         * size should be set to 480x320. If the display orientation is set to
+         * 90 or 270, preview size should be set to 320x480. The display
+         * orientation should also be considered while setting picture size and
+         * thumbnail size.
+         *
+         * @param width  the width of the pictures, in pixels
+         * @param height the height of the pictures, in pixels
+         * @see #setDisplayOrientation(int)
+         * @see #getCameraInfo(int, CameraInfo)
+         * @see #setPictureSize(int, int)
+         * @see #setJpegThumbnailSize(int, int)
          */
-        public static final String SCENE_MODE_NIGHT_PORTRAIT = "night-portrait";
+        public void setPreviewSize(int width, int height) {
+            String v = Integer.toString(width) + "x" + Integer.toString(height);
+            set((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PREVIEW_SIZE, v);
+        }
 
         /**
-         * Take photos in a theater. Flash light is off.
+         * Returns the dimensions setting for preview pictures.
+         *
+         * @return a Size object with the width and height setting
+         *          for the preview picture
          */
-        public static final String SCENE_MODE_THEATRE = "theatre";
+        public Size getPreviewSize() {
+            String pair = get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PREVIEW_SIZE);
+            return strToSize(pair);
+        }
 
         /**
-         * Take pictures on the beach.
+         * Gets the supported preview sizes.
+         *
+         * @return a list of Size object. This method will always return a list
+         *         with at least one element.
          */
-        public static final String SCENE_MODE_BEACH = "beach";
+        public List<Size> getSupportedPreviewSizes() {
+            String str = get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PREVIEW_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
 
         /**
-         * Take pictures on the snow.
+         * <p>Gets the supported video frame sizes that can be used by
+         * MediaRecorder.</p>
+         *
+         * <p>If the returned list is not null, the returned list will contain at
+         * least one Size and one of the sizes in the returned list must be
+         * passed to MediaRecorder.setVideoSize() for camcorder application if
+         * camera is used as the video source. In this case, the size of the
+         * preview can be different from the resolution of the recorded video
+         * during video recording.</p>
+         *
+         * @return a list of Size object if camera has separate preview and
+         *         video output; otherwise, null is returned.
+         * @see #getPreferredPreviewSizeForVideo()
          */
-        public static final String SCENE_MODE_SNOW = "snow";
+        public List<Size> getSupportedVideoSizes() {
+            String str = get(KEY_VIDEO_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
 
         /**
-         * Take sunset photos.
+         * Returns the preferred or recommended preview size (width and height)
+         * in pixels for video recording. Camcorder applications should
+         * set the preview size to a value that is not larger than the
+         * preferred preview size. In other words, the product of the width
+         * and height of the preview size should not be larger than that of
+         * the preferred preview size. In addition, we recommend to choose a
+         * preview size that has the same aspect ratio as the resolution of
+         * video to be recorded.
+         *
+         * @return the preferred preview size (width and height) in pixels for
+         *         video recording if getSupportedVideoSizes() does not return
+         *         null; otherwise, null is returned.
+         * @see #getSupportedVideoSizes()
          */
-        public static final String SCENE_MODE_SUNSET = "sunset";
-
+        public Size getPreferredPreviewSizeForVideo() {
+            String pair = get(KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO);
+            return strToSize(pair);
+        }
         /**
-         * Avoid blurry pictures (for example, due to hand shake).
+         * @hide
+         * add for slow motion preview size
+         * @return the list size will tell camera ap to choose right preview size
          */
-        public static final String SCENE_MODE_STEADYPHOTO = "steadyphoto";
-
+        public Size getPreferredPreviewSizeForSlowMotionVideo() {
+            String pair = get(KEY_HSVR_PRV_SIZE);
+            return strToSize(pair);
+        }
         /**
-         * For shooting firework displays.
+         * @hide
+         * add for slow motion preview size
+         * @return the list size will tell camera ap to choose right preview size
          */
-        public static final String SCENE_MODE_FIREWORKS = "fireworks";
-
+        public List<Size> getSupportedSlowMotionVideoSizes() {
+            String str = get(KEY_HSVR_PRV_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
         /**
-         * Take photos of fast moving objects. Same as {@link
-         * #SCENE_MODE_ACTION}.
+         * <p>Sets the dimensions for EXIF thumbnail in Jpeg picture. If
+         * applications set both width and height to 0, EXIF will not contain
+         * thumbnail.</p>
+         *
+         * <p>Applications need to consider the display orientation. See {@link
+         * #setPreviewSize(int,int)} for reference.</p>
+         *
+         * @param width  the width of the thumbnail, in pixels
+         * @param height the height of the thumbnail, in pixels
+         * @see #setPreviewSize(int,int)
          */
-        public static final String SCENE_MODE_SPORTS = "sports";
+        public void setJpegThumbnailSize(int width, int height) {
+            set(KEY_JPEG_THUMBNAIL_WIDTH, width);
+            set(KEY_JPEG_THUMBNAIL_HEIGHT, height);
+        }
 
         /**
-         * Take indoor low-light shot.
+         * Returns the dimensions for EXIF thumbnail in Jpeg picture.
+         *
+         * @return a Size object with the height and width setting for the EXIF
+         *         thumbnails
          */
-        public static final String SCENE_MODE_PARTY = "party";
+        public Size getJpegThumbnailSize() {
+            return new Size(getInt(KEY_JPEG_THUMBNAIL_WIDTH),
+                            getInt(KEY_JPEG_THUMBNAIL_HEIGHT));
+        }
 
         /**
-         * Capture the naturally warm color of scenes lit by candles.
+         * Gets the supported jpeg thumbnail sizes.
+         *
+         * @return a list of Size object. This method will always return a list
+         *         with at least two elements. Size 0,0 (no thumbnail) is always
+         *         supported.
          */
-        public static final String SCENE_MODE_CANDLELIGHT = "candlelight";
-        /** @hide
-        * SCENE_MODE_BACKLIGHT
-        **/
-        public static final String SCENE_MODE_BACKLIGHT = "backlight";
-        /** @hide
-        * SCENE_MODE_FLOWERS
-        **/
-        public static final String SCENE_MODE_FLOWERS = "flowers";
+        public List<Size> getSupportedJpegThumbnailSizes() {
+            String str = get(KEY_JPEG_THUMBNAIL_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
 
         /**
-         * Applications are looking for a barcode. Camera driver will be
-         * optimized for barcode reading.
+         * Sets the quality of the EXIF thumbnail in Jpeg picture.
+         *
+         * @param quality the JPEG quality of the EXIF thumbnail. The range is 1
+         *                to 100, with 100 being the best.
          */
-        public static final String SCENE_MODE_BARCODE = "barcode";
+        public void setJpegThumbnailQuality(int quality) {
+            set(KEY_JPEG_THUMBNAIL_QUALITY, quality);
+        }
 
         /**
-         * Capture a scene using high dynamic range imaging techniques. The
-         * camera will return an image that has an extended dynamic range
-         * compared to a regular capture. Capturing such an image may take
-         * longer than a regular capture.
+         * Returns the quality setting for the EXIF thumbnail in Jpeg picture.
+         *
+         * @return the JPEG quality setting of the EXIF thumbnail.
          */
-        public static final String SCENE_MODE_HDR = "hdr";
+        public int getJpegThumbnailQuality() {
+            return getInt(KEY_JPEG_THUMBNAIL_QUALITY);
+        }
 
         /**
-         * Auto-focus mode. Applications should call {@link
-         * #autoFocus(AutoFocusCallback)} to start the focus in this mode.
+         * Sets Jpeg quality of captured picture.
+         *
+         * @param quality the JPEG quality of captured picture. The range is 1
+         *                to 100, with 100 being the best.
          */
-        public static final String FOCUS_MODE_AUTO = "auto";
+        public void setJpegQuality(int quality) {
+            set(KEY_JPEG_QUALITY, quality);
+        }
 
         /**
-         * Focus is set at infinity. Applications should not call
-         * {@link #autoFocus(AutoFocusCallback)} in this mode.
+         * Returns the quality setting for the JPEG picture.
+         *
+         * @return the JPEG picture quality setting.
          */
-        public static final String FOCUS_MODE_INFINITY = "infinity";
+        public int getJpegQuality() {
+            return getInt(KEY_JPEG_QUALITY);
+        }
 
         /**
-         * Macro (close-up) focus mode. Applications should call
-         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
-         * mode.
+         * Sets the rate at which preview frames are received. This is the
+         * target frame rate. The actual frame rate depends on the driver.
+         *
+         * @param fps the frame rate (frames per second)
+         * @deprecated replaced by {@link #setPreviewFpsRange(int,int)}
          */
-        public static final String FOCUS_MODE_MACRO = "macro";
+        @Deprecated
+        public void setPreviewFrameRate(int fps) {
+            set(KEY_PREVIEW_FRAME_RATE, fps);
+        }
 
         /**
-         * Focus is fixed. The camera is always in this mode if the focus is not
-         * adjustable. If the camera has auto-focus, this mode can fix the
-         * focus, which is usually at hyperfocal distance. Applications should
-         * not call {@link #autoFocus(AutoFocusCallback)} in this mode.
+         * Returns the setting for the rate at which preview frames are
+         * received. This is the target frame rate. The actual frame rate
+         * depends on the driver.
+         *
+         * @return the frame rate setting (frames per second)
+         * @deprecated replaced by {@link #getPreviewFpsRange(int[])}
          */
-        public static final String FOCUS_MODE_FIXED = "fixed";
+        @Deprecated
+        public int getPreviewFrameRate() {
+            return getInt(KEY_PREVIEW_FRAME_RATE);
+        }
 
-        /** @hide
-         * Normal focus mode. Applications should call
-         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
-         * mode.
+        /**
+         * Gets the supported preview frame rates.
+         *
+         * @return a list of supported preview frame rates. null if preview
+         *         frame rate setting is not supported.
+         * @deprecated replaced by {@link #getSupportedPreviewFpsRange()}
          */
-        public static final String FOCUS_MODE_NORMAL = "normal";
+        @Deprecated
+        public List<Integer> getSupportedPreviewFrameRates() {
+            String str = get(KEY_PREVIEW_FRAME_RATE + SUPPORTED_VALUES_SUFFIX);
+            return splitInt(str);
+        }
 
         /**
-         * Extended depth of field (EDOF). Focusing is done digitally and
-         * continuously. Applications should not call {@link
-         * #autoFocus(AutoFocusCallback)} in this mode.
+         * Sets the minimum and maximum preview fps. This controls the rate of
+         * preview frames received in {@link PreviewCallback}. The minimum and
+         * maximum preview fps must be one of the elements from {@link
+         * #getSupportedPreviewFpsRange}.
+         *
+         * @param min the minimum preview fps (scaled by 1000).
+         * @param max the maximum preview fps (scaled by 1000).
+         * @throws RuntimeException if fps range is invalid.
+         * @see #setPreviewCallbackWithBuffer(Camera.PreviewCallback)
+         * @see #getSupportedPreviewFpsRange()
          */
-        public static final String FOCUS_MODE_EDOF = "edof";
+        public void setPreviewFpsRange(int min, int max) {
+            set(KEY_PREVIEW_FPS_RANGE, "" + min + "," + max);
+        }
 
         /**
-         * Continuous auto focus mode intended for video recording. The camera
-         * continuously tries to focus. This is the best choice for video
-         * recording because the focus changes smoothly . Applications still can
-         * call {@link #takePicture(Camera.ShutterCallback,
-         * Camera.PictureCallback, Camera.PictureCallback)} in this mode but the
-         * subject may not be in focus. Auto focus starts when the parameter is
-         * set.
+         * Returns the current minimum and maximum preview fps. The values are
+         * one of the elements returned by {@link #getSupportedPreviewFpsRange}.
          *
-         * <p>Since API level 14, applications can call {@link
-         * #autoFocus(AutoFocusCallback)} in this mode. The focus callback will
-         * immediately return with a boolean that indicates whether the focus is
-         * sharp or not. The focus position is locked after autoFocus call. If
-         * applications want to resume the continuous focus, cancelAutoFocus
-         * must be called. Restarting the preview will not resume the continuous
-         * autofocus. To stop continuous focus, applications should change the
-         * focus mode to other modes.
+         * @return range the minimum and maximum preview fps (scaled by 1000).
+         * @see #PREVIEW_FPS_MIN_INDEX
+         * @see #PREVIEW_FPS_MAX_INDEX
+         * @see #getSupportedPreviewFpsRange()
+         */
+        public void getPreviewFpsRange(int[] range) {
+            if (range == null || range.length != 2) {
+                throw new IllegalArgumentException(
+                        "range must be an array with two elements.");
+            }
+            splitInt(get(KEY_PREVIEW_FPS_RANGE), range);
+        }
+
+        /**
+         * Gets the supported preview fps (frame-per-second) ranges. Each range
+         * contains a minimum fps and maximum fps. If minimum fps equals to
+         * maximum fps, the camera outputs frames in fixed frame rate. If not,
+         * the camera outputs frames in auto frame rate. The actual frame rate
+         * fluctuates between the minimum and the maximum. The values are
+         * multiplied by 1000 and represented in integers. For example, if frame
+         * rate is 26.623 frames per second, the value is 26623.
          *
-         * @see #FOCUS_MODE_CONTINUOUS_PICTURE
+         * @return a list of supported preview fps ranges. This method returns a
+         *         list with at least one element. Every element is an int array
+         *         of two values - minimum fps and maximum fps. The list is
+         *         sorted from small to large (first by maximum fps and then
+         *         minimum fps).
+         * @see #PREVIEW_FPS_MIN_INDEX
+         * @see #PREVIEW_FPS_MAX_INDEX
          */
-        public static final String FOCUS_MODE_CONTINUOUS_VIDEO = "continuous-video";
+        public List<int[]> getSupportedPreviewFpsRange() {
+            String str = get(KEY_PREVIEW_FPS_RANGE + SUPPORTED_VALUES_SUFFIX);
+            return splitRange(str);
+        }
 
         /**
-         * Continuous auto focus mode intended for taking pictures. The camera
-         * continuously tries to focus. The speed of focus change is more
-         * aggressive than {@link #FOCUS_MODE_CONTINUOUS_VIDEO}. Auto focus
-         * starts when the parameter is set.
+         * Sets the image format for preview pictures.
+         * <p>If this is never called, the default format will be
+         * {@link android.graphics.ImageFormat#NV21}, which
+         * uses the NV21 encoding format.</p>
          *
-         * <p>Applications can call {@link #autoFocus(AutoFocusCallback)} in
-         * this mode. If the autofocus is in the middle of scanning, the focus
-         * callback will return when it completes. If the autofocus is not
-         * scanning, the focus callback will immediately return with a boolean
-         * that indicates whether the focus is sharp or not. The apps can then
-         * decide if they want to take a picture immediately or to change the
-         * focus mode to auto, and run a full autofocus cycle. The focus
-         * position is locked after autoFocus call. If applications want to
-         * resume the continuous focus, cancelAutoFocus must be called.
-         * Restarting the preview will not resume the continuous autofocus. To
-         * stop continuous focus, applications should change the focus mode to
-         * other modes.
+         * <p>Use {@link Parameters#getSupportedPreviewFormats} to get a list of
+         * the available preview formats.
          *
-         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         * <p>It is strongly recommended that either
+         * {@link android.graphics.ImageFormat#NV21} or
+         * {@link android.graphics.ImageFormat#YV12} is used, since
+         * they are supported by all camera devices.</p>
+         *
+         * <p>For YV12, the image buffer that is received is not necessarily
+         * tightly packed, as there may be padding at the end of each row of
+         * pixel data, as described in
+         * {@link android.graphics.ImageFormat#YV12}. For camera callback data,
+         * it can be assumed that the stride of the Y and UV data is the
+         * smallest possible that meets the alignment requirements. That is, if
+         * the preview size is <var>width x height</var>, then the following
+         * equations describe the buffer index for the beginning of row
+         * <var>y</var> for the Y plane and row <var>c</var> for the U and V
+         * planes:
+         *
+         * {@code
+         * <pre>
+         * yStride   = (int) ceil(width / 16.0) * 16;
+         * uvStride  = (int) ceil( (yStride / 2) / 16.0) * 16;
+         * ySize     = yStride * height;
+         * uvSize    = uvStride * height / 2;
+         * yRowIndex = yStride * y;
+         * uRowIndex = ySize + uvSize + uvStride * c;
+         * vRowIndex = ySize + uvStride * c;
+         * size      = ySize + uvSize * 2;</pre>
+         * }
+         *
+         * @param pixel_format the desired preview picture format, defined by
+         *   one of the {@link android.graphics.ImageFormat} constants.  (E.g.,
+         *   <var>ImageFormat.NV21</var> (default), or
+         *   <var>ImageFormat.YV12</var>)
+         *
+         * @see android.graphics.ImageFormat
+         * @see android.hardware.Camera.Parameters#getSupportedPreviewFormats
          */
-        public static final String FOCUS_MODE_CONTINUOUS_PICTURE = "continuous-picture";
+        public void setPreviewFormat(int pixel_format) {
+            String s = cameraFormatForPixelFormat(pixel_format);
+            if (s == null) {
+                throw new IllegalArgumentException(
+                        "Invalid pixel_format=" + pixel_format);
+            }
 
-        /** @hide
-         *  manual focus mode
+            set(KEY_PREVIEW_FORMAT, s);
+        }
+
+        /**
+         * Returns the image format for preview frames got from
+         * {@link PreviewCallback}.
+         *
+         * @return the preview format.
+         * @see android.graphics.ImageFormat
+         * @see #setPreviewFormat
          */
-        public static final String FOCUS_MODE_MANUAL_POSITION = "manual";
+        public int getPreviewFormat() {
+            return pixelFormatForCameraFormat(get(KEY_PREVIEW_FORMAT));
+        }
 
-        // Indices for focus distance array.
         /**
-         * The array index of near focus distance for use with
-         * {@link #getFocusDistances(float[])}.
+         * Gets the supported preview formats. {@link android.graphics.ImageFormat#NV21}
+         * is always supported. {@link android.graphics.ImageFormat#YV12}
+         * is always supported since API level 12.
+         *
+         * @return a list of supported preview formats. This method will always
+         *         return a list with at least one element.
+         * @see android.graphics.ImageFormat
+         * @see #setPreviewFormat
          */
-        public static final int FOCUS_DISTANCE_NEAR_INDEX = 0;
+        public List<Integer> getSupportedPreviewFormats() {
+            String str = get(KEY_PREVIEW_FORMAT + SUPPORTED_VALUES_SUFFIX);
+            ArrayList<Integer> formats = new ArrayList<Integer>();
+            for (String s : split(str)) {
+                int f = pixelFormatForCameraFormat(s);
+                if (f == ImageFormat.UNKNOWN) continue;
+                formats.add(f);
+            }
+            return formats;
+        }
 
         /**
-         * The array index of optimal focus distance for use with
-         * {@link #getFocusDistances(float[])}.
+         * <p>Sets the dimensions for pictures.</p>
+         *
+         * <p>Applications need to consider the display orientation. See {@link
+         * #setPreviewSize(int,int)} for reference.</p>
+         *
+         * @param width  the width for pictures, in pixels
+         * @param height the height for pictures, in pixels
+         * @see #setPreviewSize(int,int)
+         *
          */
-        public static final int FOCUS_DISTANCE_OPTIMAL_INDEX = 1;
+        public void setPictureSize(int width, int height) {
+            String v = Integer.toString(width) + "x" + Integer.toString(height);
+            set((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PICTURE_SIZE, v);
+        }
 
         /**
-         * The array index of far focus distance for use with
-         * {@link #getFocusDistances(float[])}.
+         * Returns the dimension setting for pictures.
+         *
+         * @return a Size object with the height and width setting
+         *          for pictures
          */
-        public static final int FOCUS_DISTANCE_FAR_INDEX = 2;
+        public Size getPictureSize() {
+            String pair = get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PICTURE_SIZE);
+            return strToSize(pair);
+        }
 
         /**
-         * The array index of minimum preview fps for use with {@link
-         * #getPreviewFpsRange(int[])} or {@link
-         * #getSupportedPreviewFpsRange()}.
+         * Gets the supported picture sizes.
+         *
+         * @return a list of supported picture sizes. This method will always
+         *         return a list with at least one element.
          */
-        public static final int PREVIEW_FPS_MIN_INDEX = 0;
+        public List<Size> getSupportedPictureSizes() {
+            String str = get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
 
         /**
-         * The array index of maximum preview fps for use with {@link
-         * #getPreviewFpsRange(int[])} or {@link
-         * #getSupportedPreviewFpsRange()}.
+         * Sets the image format for pictures.
+         *
+         * @param pixel_format the desired picture format
+         *                     (<var>ImageFormat.NV21</var>,
+         *                      <var>ImageFormat.RGB_565</var>, or
+         *                      <var>ImageFormat.JPEG</var>)
+         * @see android.graphics.ImageFormat
          */
-        public static final int PREVIEW_FPS_MAX_INDEX = 1;
+        public void setPictureFormat(int pixel_format) {
+            String s = cameraFormatForPixelFormat(pixel_format);
+            if (s == null) {
+                throw new IllegalArgumentException(
+                        "Invalid pixel_format=" + pixel_format);
+            }
 
-        // Formats for setPreviewFormat and setPictureFormat.
-        private static final String PIXEL_FORMAT_YUV422SP = "yuv422sp";
-        private static final String PIXEL_FORMAT_YUV420SP = "yuv420sp";
-        private static final String PIXEL_FORMAT_YUV420SP_ADRENO = "yuv420sp-adreno";
-        private static final String PIXEL_FORMAT_YUV422I = "yuv422i-yuyv";
-        private static final String PIXEL_FORMAT_YUV420P = "yuv420p";
-        private static final String PIXEL_FORMAT_RGB565 = "rgb565";
-        private static final String PIXEL_FORMAT_JPEG = "jpeg";
-        private static final String PIXEL_FORMAT_BAYER_RGGB = "bayer-rggb";
-        private static final String PIXEL_FORMAT_RAW = "raw";
-        private static final String PIXEL_FORMAT_YV12 = "yv12";
-        private static final String PIXEL_FORMAT_NV12 = "nv12";
+            set(KEY_PICTURE_FORMAT, s);
+        }
 
         /**
-         * Order matters: Keys that are {@link #set(String, String) set} later
-         * will take precedence over keys that are set earlier (if the two keys
-         * conflict with each other).
+         * Returns the image format for pictures.
          *
-         * <p>One example is {@link #setPreviewFpsRange(int, int)} , since it
-         * conflicts with {@link #setPreviewFrameRate(int)} whichever key is set later
-         * is the one that will take precedence.
-         * </p>
+         * @return the picture format
+         * @see android.graphics.ImageFormat
          */
-        private final LinkedHashMap<String, String> mMap;
-
-        private Parameters() {
-            mMap = new LinkedHashMap<String, String>(/*initialCapacity*/64);
+        public int getPictureFormat() {
+            return pixelFormatForCameraFormat(get(KEY_PICTURE_FORMAT));
         }
 
         /**
-         * Overwrite existing parameters with a copy of the ones from {@code other}.
-         *
-         * <b>For use by the legacy shim only.</b>
+         * Gets the supported picture formats.
          *
-         * @hide
+         * @return supported picture formats. This method will always return a
+         *         list with at least one element.
+         * @see android.graphics.ImageFormat
          */
-        public void copyFrom(Parameters other) {
-            if (other == null) {
-                throw new NullPointerException("other must not be null");
+        public List<Integer> getSupportedPictureFormats() {
+            String str = get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX);
+            ArrayList<Integer> formats = new ArrayList<Integer>();
+            for (String s : split(str)) {
+                int f = pixelFormatForCameraFormat(s);
+                if (f == ImageFormat.UNKNOWN) continue;
+                formats.add(f);
             }
-
-            mMap.putAll(other.mMap);
+            return formats;
         }
 
-        private Camera getOuter() {
-            return Camera.this;
+        private String cameraFormatForPixelFormat(int pixel_format) {
+            switch(pixel_format) {
+            case ImageFormat.NV16:      return PIXEL_FORMAT_YUV422SP;
+            case ImageFormat.NV21:      return PIXEL_FORMAT_YUV420SP;
+            case ImageFormat.YUY2:      return PIXEL_FORMAT_YUV422I;
+            case ImageFormat.YV12:      return PIXEL_FORMAT_YUV420P;
+            case ImageFormat.RGB_565:   return PIXEL_FORMAT_RGB565;
+            case ImageFormat.JPEG:      return PIXEL_FORMAT_JPEG;
+            default:                    return null;
+            }
         }
 
+        private int pixelFormatForCameraFormat(String format) {
+            if (format == null)
+                return ImageFormat.UNKNOWN;
 
-        /**
-         * Value equality check.
-         *
-         * @hide
-         */
-        public boolean same(Parameters other) {
-            if (this == other) {
-                return true;
-            }
-            return other != null && Parameters.this.mMap.equals(other.mMap);
+            if (format.equals(PIXEL_FORMAT_YUV422SP))
+                return ImageFormat.NV16;
+
+            if (format.equals(PIXEL_FORMAT_YUV420SP))
+                return ImageFormat.NV21;
+
+            if (format.equals(PIXEL_FORMAT_YUV422I))
+                return ImageFormat.YUY2;
+
+            if (format.equals(PIXEL_FORMAT_YUV420P))
+                return ImageFormat.YV12;
+
+            if (format.equals(PIXEL_FORMAT_RGB565))
+                return ImageFormat.RGB_565;
+
+            if (format.equals(PIXEL_FORMAT_JPEG))
+                return ImageFormat.JPEG;
+
+            return ImageFormat.UNKNOWN;
         }
 
         /**
-         * Writes the current Parameters to the log.
-         * @hide
-         * @deprecated
+         * Sets the clockwise rotation angle in degrees relative to the
+         * orientation of the camera. This affects the pictures returned from
+         * JPEG {@link PictureCallback}. The camera driver may set orientation
+         * in the EXIF header without rotating the picture. Or the driver may
+         * rotate the picture and the EXIF thumbnail. If the Jpeg picture is
+         * rotated, the orientation in the EXIF header will be missing or 1 (row
+         * #0 is top and column #0 is left side).
+         *
+         * <p>
+         * If applications want to rotate the picture to match the orientation
+         * of what users see, apps should use
+         * {@link android.view.OrientationEventListener} and
+         * {@link android.hardware.Camera.CameraInfo}. The value from
+         * OrientationEventListener is relative to the natural orientation of
+         * the device. CameraInfo.orientation is the angle between camera
+         * orientation and natural device orientation. The sum of the two is the
+         * rotation angle for back-facing camera. The difference of the two is
+         * the rotation angle for front-facing camera. Note that the JPEG
+         * pictures of front-facing cameras are not mirrored as in preview
+         * display.
+         *
+         * <p>
+         * For example, suppose the natural orientation of the device is
+         * portrait. The device is rotated 270 degrees clockwise, so the device
+         * orientation is 270. Suppose a back-facing camera sensor is mounted in
+         * landscape and the top side of the camera sensor is aligned with the
+         * right edge of the display in natural orientation. So the camera
+         * orientation is 90. The rotation should be set to 0 (270 + 90).
+         *
+         * <p>The reference code is as follows.
+         *
+         * <pre>
+         * public void onOrientationChanged(int orientation) {
+         *     if (orientation == ORIENTATION_UNKNOWN) return;
+         *     android.hardware.Camera.CameraInfo info =
+         *            new android.hardware.Camera.CameraInfo();
+         *     android.hardware.Camera.getCameraInfo(cameraId, info);
+         *     orientation = (orientation + 45) / 90 * 90;
+         *     int rotation = 0;
+         *     if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
+         *         rotation = (info.orientation - orientation + 360) % 360;
+         *     } else {  // back-facing camera
+         *         rotation = (info.orientation + orientation) % 360;
+         *     }
+         *     mParameters.setRotation(rotation);
+         * }
+         * </pre>
+         *
+         * @param rotation The rotation angle in degrees relative to the
+         *                 orientation of the camera. Rotation can only be 0,
+         *                 90, 180 or 270.
+         * @throws IllegalArgumentException if rotation value is invalid.
+         * @see android.view.OrientationEventListener
+         * @see #getCameraInfo(int, CameraInfo)
          */
-        @Deprecated
-        public void dump() {
-            Log.e(TAG, "dump: size=" + mMap.size());
-            for (String k : mMap.keySet()) {
-                Log.e(TAG, "dump: " + k + "=" + mMap.get(k));
+        public void setRotation(int rotation) {
+            if (rotation == 0 || rotation == 90 || rotation == 180
+                    || rotation == 270) {
+                set(KEY_ROTATION, Integer.toString(rotation));
+            } else {
+                throw new IllegalArgumentException(
+                        "Invalid rotation=" + rotation);
             }
         }
 
         /**
-         * Creates a single string with all the parameters set in
-         * this Parameters object.
-         * <p>The {@link #unflatten(String)} method does the reverse.</p>
+         * Sets GPS latitude coordinate. This will be stored in JPEG EXIF
+         * header.
          *
-         * @return a String with all values from this Parameters object, in
-         *         semi-colon delimited key-value pairs
+         * @param latitude GPS latitude coordinate.
          */
-        public String flatten() {
-            StringBuilder flattened = new StringBuilder(128);
-            for (String k : mMap.keySet()) {
-                flattened.append(k);
-                flattened.append("=");
-                flattened.append(mMap.get(k));
-                flattened.append(";");
-            }
-            // chop off the extra semicolon at the end
-            flattened.deleteCharAt(flattened.length()-1);
-            return flattened.toString();
+        public void setGpsLatitude(double latitude) {
+            set(KEY_GPS_LATITUDE, Double.toString(latitude));
         }
 
         /**
-         * Takes a flattened string of parameters and adds each one to
-         * this Parameters object.
-         * <p>The {@link #flatten()} method does the reverse.</p>
+         * Sets GPS longitude coordinate. This will be stored in JPEG EXIF
+         * header.
          *
-         * @param flattened a String of parameters (key-value paired) that
-         *                  are semi-colon delimited
+         * @param longitude GPS longitude coordinate.
          */
-        public void unflatten(String flattened) {
-            mMap.clear();
-
-            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(';');
-            splitter.setString(flattened);
-            for (String kv : splitter) {
-                int pos = kv.indexOf('=');
-                if (pos == -1) {
-                    continue;
-                }
-                String k = kv.substring(0, pos);
-                String v = kv.substring(pos + 1);
-                mMap.put(k, v);
-            }
+        public void setGpsLongitude(double longitude) {
+            set(KEY_GPS_LONGITUDE, Double.toString(longitude));
         }
 
-        public void remove(String key) {
-            mMap.remove(key);
+        /**
+         * Sets GPS altitude. This will be stored in JPEG EXIF header.
+         *
+         * @param altitude GPS altitude in meters.
+         */
+        public void setGpsAltitude(double altitude) {
+            set(KEY_GPS_ALTITUDE, Double.toString(altitude));
         }
 
         /**
-         * Sets a String parameter.
+         * Sets GPS timestamp. This will be stored in JPEG EXIF header.
          *
-         * @param key   the key name for the parameter
-         * @param value the String value of the parameter
+         * @param timestamp GPS timestamp (UTC in seconds since January 1,
+         *                  1970).
          */
-        public void set(String key, String value) {
-            if (key.indexOf('=') != -1 || key.indexOf(';') != -1 || key.indexOf(0) != -1) {
-                Log.e(TAG, "Key \"" + key + "\" contains invalid character (= or ; or \\0)");
-                return;
-            }
-            if (value.indexOf('=') != -1 || value.indexOf(';') != -1 || value.indexOf(0) != -1) {
-                Log.e(TAG, "Value \"" + value + "\" contains invalid character (= or ; or \\0)");
-                return;
-            }
-
-            put(key, value);
+        public void setGpsTimestamp(long timestamp) {
+            set(KEY_GPS_TIMESTAMP, Long.toString(timestamp));
         }
 
         /**
-         * Sets an integer parameter.
+         * Sets GPS processing method. It will store up to 32 characters
+         * in JPEG EXIF header.
          *
-         * @param key   the key name for the parameter
-         * @param value the int value of the parameter
+         * @param processing_method The processing method to get this location.
          */
-        public void set(String key, int value) {
-            put(key, Integer.toString(value));
-        }
-
-        private void put(String key, String value) {
-            /*
-             * Remove the key if it already exists.
-             *
-             * This way setting a new value for an already existing key will always move
-             * that key to be ordered the latest in the map.
-             */
-            mMap.remove(key);
-            mMap.put(key, value);
+        public void setGpsProcessingMethod(String processing_method) {
+            set(KEY_GPS_PROCESSING_METHOD, processing_method);
         }
 
-        private void set(String key, List<Area> areas) {
-            if (areas == null) {
-                set(key, "(0,0,0,0,0)");
-            } else {
-                StringBuilder buffer = new StringBuilder();
-                for (int i = 0; i < areas.size(); i++) {
-                    Area area = areas.get(i);
-                    Rect rect = area.rect;
-                    buffer.append('(');
-                    buffer.append(rect.left);
-                    buffer.append(',');
-                    buffer.append(rect.top);
-                    buffer.append(',');
-                    buffer.append(rect.right);
-                    buffer.append(',');
-                    buffer.append(rect.bottom);
-                    buffer.append(',');
-                    buffer.append(area.weight);
-                    buffer.append(')');
-                    if (i != areas.size() - 1) buffer.append(',');
-                }
-                set(key, buffer.toString());
-            }
+        /**
+         * Removes GPS latitude, longitude, altitude, and timestamp from the
+         * parameters.
+         */
+        public void removeGpsData() {
+            remove(KEY_QC_GPS_LATITUDE_REF);
+            remove(KEY_GPS_LATITUDE);
+            remove(KEY_QC_GPS_LONGITUDE_REF);
+            remove(KEY_GPS_LONGITUDE);
+            remove(KEY_QC_GPS_ALTITUDE_REF);
+            remove(KEY_GPS_ALTITUDE);
+            remove(KEY_GPS_TIMESTAMP);
+            remove(KEY_GPS_PROCESSING_METHOD);
         }
 
         /**
-         * Returns the value of a String parameter.
+         * Gets the current white balance setting.
+         *
+         * @return current white balance. null if white balance setting is not
+         *         supported.
+         * @see #WHITE_BALANCE_AUTO
+         * @see #WHITE_BALANCE_INCANDESCENT
+         * @see #WHITE_BALANCE_FLUORESCENT
+         * @see #WHITE_BALANCE_WARM_FLUORESCENT
+         * @see #WHITE_BALANCE_DAYLIGHT
+         * @see #WHITE_BALANCE_CLOUDY_DAYLIGHT
+         * @see #WHITE_BALANCE_TWILIGHT
+         * @see #WHITE_BALANCE_SHADE
          *
-         * @param key the key name for the parameter
-         * @return the String value of the parameter
          */
-        public String get(String key) {
-            return mMap.get(key);
+        public String getWhiteBalance() {
+            return get(KEY_WHITE_BALANCE);
         }
 
         /**
-         * Returns the value of an integer parameter.
+         * Sets the white balance. Changing the setting will release the
+         * auto-white balance lock. It is recommended not to change white
+         * balance and AWB lock at the same time.
          *
-         * @param key the key name for the parameter
-         * @return the int value of the parameter
+         * @param value new white balance.
+         * @see #getWhiteBalance()
+         * @see #setAutoWhiteBalanceLock(boolean)
          */
-        public int getInt(String key) {
-            return Integer.parseInt(mMap.get(key));
+        public void setWhiteBalance(String value) {
+            String oldValue = get(KEY_WHITE_BALANCE);
+            if (same(value, oldValue)) return;
+            set(KEY_WHITE_BALANCE, value);
+            set(KEY_AUTO_WHITEBALANCE_LOCK, FALSE);
         }
 
         /**
-         * Sets the dimensions for preview pictures. If the preview has already
-         * started, applications should stop the preview first before changing
-         * preview size.
-         *
-         * The sides of width and height are based on camera orientation. That
-         * is, the preview size is the size before it is rotated by display
-         * orientation. So applications need to consider the display orientation
-         * while setting preview size. For example, suppose the camera supports
-         * both 480x320 and 320x480 preview sizes. The application wants a 3:2
-         * preview ratio. If the display orientation is set to 0 or 180, preview
-         * size should be set to 480x320. If the display orientation is set to
-         * 90 or 270, preview size should be set to 320x480. The display
-         * orientation should also be considered while setting picture size and
-         * thumbnail size.
+         * Gets the supported white balance.
          *
-         * @param width  the width of the pictures, in pixels
-         * @param height the height of the pictures, in pixels
-         * @see #setDisplayOrientation(int)
-         * @see #getCameraInfo(int, CameraInfo)
-         * @see #setPictureSize(int, int)
-         * @see #setJpegThumbnailSize(int, int)
+         * @return a list of supported white balance. null if white balance
+         *         setting is not supported.
+         * @see #getWhiteBalance()
          */
-        public void setPreviewSize(int width, int height) {
-            String v = Integer.toString(width) + "x" + Integer.toString(height);
-            set(KEY_PREVIEW_SIZE, v);
+        public List<String> getSupportedWhiteBalance() {
+            String str = get(KEY_WHITE_BALANCE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
-         * Returns the dimensions setting for preview pictures.
+         * Gets the current color effect setting.
          *
-         * @return a Size object with the width and height setting
-         *          for the preview picture
+         * @return current color effect. null if color effect
+         *         setting is not supported.
+         * @see #EFFECT_NONE
+         * @see #EFFECT_MONO
+         * @see #EFFECT_NEGATIVE
+         * @see #EFFECT_SOLARIZE
+         * @see #EFFECT_SEPIA
+         * @see #EFFECT_POSTERIZE
+         * @see #EFFECT_WHITEBOARD
+         * @see #EFFECT_BLACKBOARD
+         * @see #EFFECT_AQUA
          */
-        public Size getPreviewSize() {
-            String pair = get(KEY_PREVIEW_SIZE);
-            return strToSize(pair);
+        public String getColorEffect() {
+            return get(KEY_EFFECT);
         }
 
         /**
-         * Gets the supported preview sizes.
+         * Sets the current color effect setting.
          *
-         * @return a list of Size object. This method will always return a list
-         *         with at least one element.
+         * @param value new color effect.
+         * @see #getColorEffect()
          */
-        public List<Size> getSupportedPreviewSizes() {
-            String str = get(KEY_PREVIEW_SIZE + SUPPORTED_VALUES_SUFFIX);
-            return splitSize(str);
+        public void setColorEffect(String value) {
+            set(KEY_EFFECT, value);
         }
 
         /**
-         * <p>Gets the supported video frame sizes that can be used by
-         * MediaRecorder.</p>
-         *
-         * <p>If the returned list is not null, the returned list will contain at
-         * least one Size and one of the sizes in the returned list must be
-         * passed to MediaRecorder.setVideoSize() for camcorder application if
-         * camera is used as the video source. In this case, the size of the
-         * preview can be different from the resolution of the recorded video
-         * during video recording.</p>
+         * Gets the supported color effects.
          *
-         * @return a list of Size object if camera has separate preview and
-         *         video output; otherwise, null is returned.
-         * @see #getPreferredPreviewSizeForVideo()
+         * @return a list of supported color effects. null if color effect
+         *         setting is not supported.
+         * @see #getColorEffect()
          */
-        public List<Size> getSupportedVideoSizes() {
-            String str = get(KEY_VIDEO_SIZE + SUPPORTED_VALUES_SUFFIX);
-            return splitSize(str);
+        public List<String> getSupportedColorEffects() {
+            String str = get(KEY_EFFECT + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
+
         /**
-         * Returns the preferred or recommended preview size (width and height)
-         * in pixels for video recording. Camcorder applications should
-         * set the preview size to a value that is not larger than the
-         * preferred preview size. In other words, the product of the width
-         * and height of the preview size should not be larger than that of
-         * the preferred preview size. In addition, we recommend to choose a
-         * preview size that has the same aspect ratio as the resolution of
-         * video to be recorded.
+         * Gets the current antibanding setting.
          *
-         * @return the preferred preview size (width and height) in pixels for
-         *         video recording if getSupportedVideoSizes() does not return
-         *         null; otherwise, null is returned.
-         * @see #getSupportedVideoSizes()
+         * @return current antibanding. null if antibanding setting is not
+         *         supported.
+         * @see #ANTIBANDING_AUTO
+         * @see #ANTIBANDING_50HZ
+         * @see #ANTIBANDING_60HZ
+         * @see #ANTIBANDING_OFF
          */
-        public Size getPreferredPreviewSizeForVideo() {
-            String pair = get(KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO);
-            return strToSize(pair);
+        public String getAntibanding() {
+            return get(KEY_ANTIBANDING);
         }
 
         /**
-         * <p>Sets the dimensions for EXIF thumbnail in Jpeg picture. If
-         * applications set both width and height to 0, EXIF will not contain
-         * thumbnail.</p>
-         *
-         * <p>Applications need to consider the display orientation. See {@link
-         * #setPreviewSize(int,int)} for reference.</p>
+         * Sets the antibanding.
          *
-         * @param width  the width of the thumbnail, in pixels
-         * @param height the height of the thumbnail, in pixels
-         * @see #setPreviewSize(int,int)
+         * @param antibanding new antibanding value.
+         * @see #getAntibanding()
          */
-        public void setJpegThumbnailSize(int width, int height) {
-            set(KEY_JPEG_THUMBNAIL_WIDTH, width);
-            set(KEY_JPEG_THUMBNAIL_HEIGHT, height);
+        public void setAntibanding(String antibanding) {
+            set(KEY_ANTIBANDING, antibanding);
         }
 
         /**
-         * Returns the dimensions for EXIF thumbnail in Jpeg picture.
+         * Gets the supported antibanding values.
          *
-         * @return a Size object with the height and width setting for the EXIF
-         *         thumbnails
+         * @return a list of supported antibanding values. null if antibanding
+         *         setting is not supported.
+         * @see #getAntibanding()
          */
-        public Size getJpegThumbnailSize() {
-            return new Size(getInt(KEY_JPEG_THUMBNAIL_WIDTH),
-                            getInt(KEY_JPEG_THUMBNAIL_HEIGHT));
+        public List<String> getSupportedAntibanding() {
+            String str = get(KEY_ANTIBANDING + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+    //!++
+    /**
+    * @hide
+    * Gets the current Eis mode setting (on/off)
+    * @ return one of EIS_MODE_xxx string constant.
+    * @see #EIS_MODE_ON
+    * @see #EIS_MODE_OFF
+    */
+        public String getEisMode() {
+            return get(KEY_EIS_MODE);
+        }
+    /**
+    * @hide
+    */
+        public void setEisMode(String eis) {
+            set(KEY_EIS_MODE, eis);
+        }
+    /**
+    * @hide
+    */
+        public List<String> getSupportedEisMode() {
+            String str = get(KEY_EIS_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
-        /**
-         * Gets the supported jpeg thumbnail sizes.
-         *
-         * @return a list of Size object. This method will always return a list
-         *         with at least two elements. Size 0,0 (no thumbnail) is always
-         *         supported.
-         */
-        public List<Size> getSupportedJpegThumbnailSizes() {
-            String str = get(KEY_JPEG_THUMBNAIL_SIZE + SUPPORTED_VALUES_SUFFIX);
-            return splitSize(str);
+    /**
+    * @hide
+    * IF environment light is not strong enough, camera will turn on flash while focusing
+    */
+        public String getAFLampMode() {
+            return get(KEY_AFLAMP_MODE);
+        }
+    /**
+    * @hide
+    */
+        public void setAFLampMode(String aflamp) {
+            set(KEY_AFLAMP_MODE, aflamp);
+        }
+    /**
+    * @hide
+    */
+        public List<String> getSupportedAFLampMode() {
+            String str = get(KEY_AFLAMP_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
+    //!--
 
         /**
-         * Sets the quality of the EXIF thumbnail in Jpeg picture.
+         * Gets the current scene mode setting.
          *
-         * @param quality the JPEG quality of the EXIF thumbnail. The range is 1
-         *                to 100, with 100 being the best.
+         * @return one of SCENE_MODE_XXX string constant. null if scene mode
+         *         setting is not supported.
+         * @see #SCENE_MODE_AUTO
+         * @see #SCENE_MODE_ACTION
+         * @see #SCENE_MODE_PORTRAIT
+         * @see #SCENE_MODE_LANDSCAPE
+         * @see #SCENE_MODE_NIGHT
+         * @see #SCENE_MODE_NIGHT_PORTRAIT
+         * @see #SCENE_MODE_THEATRE
+         * @see #SCENE_MODE_BEACH
+         * @see #SCENE_MODE_SNOW
+         * @see #SCENE_MODE_SUNSET
+         * @see #SCENE_MODE_STEADYPHOTO
+         * @see #SCENE_MODE_FIREWORKS
+         * @see #SCENE_MODE_SPORTS
+         * @see #SCENE_MODE_PARTY
+         * @see #SCENE_MODE_CANDLELIGHT
+         * @see #SCENE_MODE_BARCODE
          */
-        public void setJpegThumbnailQuality(int quality) {
-            set(KEY_JPEG_THUMBNAIL_QUALITY, quality);
+        public String getSceneMode() {
+            return get(KEY_SCENE_MODE);
         }
 
         /**
-         * Returns the quality setting for the EXIF thumbnail in Jpeg picture.
+         * Sets the scene mode. Changing scene mode may override other
+         * parameters (such as flash mode, focus mode, white balance). For
+         * example, suppose originally flash mode is on and supported flash
+         * modes are on/off. In night scene mode, both flash mode and supported
+         * flash mode may be changed to off. After setting scene mode,
+         * applications should call getParameters to know if some parameters are
+         * changed.
          *
-         * @return the JPEG quality setting of the EXIF thumbnail.
+         * @param value scene mode.
+         * @see #getSceneMode()
          */
-        public int getJpegThumbnailQuality() {
-            return getInt(KEY_JPEG_THUMBNAIL_QUALITY);
+        public void setSceneMode(String value) {
+            set(KEY_SCENE_MODE, value);
         }
 
         /**
-         * Sets Jpeg quality of captured picture.
+         * Gets the supported scene modes.
          *
-         * @param quality the JPEG quality of captured picture. The range is 1
-         *                to 100, with 100 being the best.
+         * @return a list of supported scene modes. null if scene mode setting
+         *         is not supported.
+         * @see #getSceneMode()
          */
-        public void setJpegQuality(int quality) {
-            set(KEY_JPEG_QUALITY, quality);
+        public List<String> getSupportedSceneModes() {
+            String str = get(KEY_SCENE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
-         * Returns the quality setting for the JPEG picture.
+         * Gets the current flash mode setting.
          *
-         * @return the JPEG picture quality setting.
+         * @return current flash mode. null if flash mode setting is not
+         *         supported.
+         * @see #FLASH_MODE_OFF
+         * @see #FLASH_MODE_AUTO
+         * @see #FLASH_MODE_ON
+         * @see #FLASH_MODE_RED_EYE
+         * @see #FLASH_MODE_TORCH
          */
-        public int getJpegQuality() {
-            return getInt(KEY_JPEG_QUALITY);
+        public String getFlashMode() {
+            return get(KEY_FLASH_MODE);
         }
 
         /**
-         * Sets the rate at which preview frames are received. This is the
-         * target frame rate. The actual frame rate depends on the driver.
+         * Sets the flash mode.
          *
-         * @param fps the frame rate (frames per second)
-         * @deprecated replaced by {@link #setPreviewFpsRange(int,int)}
+         * @param value flash mode.
+         * @see #getFlashMode()
          */
-        @Deprecated
-        public void setPreviewFrameRate(int fps) {
-            set(KEY_PREVIEW_FRAME_RATE, fps);
+        public void setFlashMode(String value) {
+            set(KEY_FLASH_MODE, value);
         }
 
         /**
-         * Returns the setting for the rate at which preview frames are
-         * received. This is the target frame rate. The actual frame rate
-         * depends on the driver.
+         * Gets the supported flash modes.
          *
-         * @return the frame rate setting (frames per second)
-         * @deprecated replaced by {@link #getPreviewFpsRange(int[])}
+         * @return a list of supported flash modes. null if flash mode setting
+         *         is not supported.
+         * @see #getFlashMode()
          */
-        @Deprecated
-        public int getPreviewFrameRate() {
-            return getInt(KEY_PREVIEW_FRAME_RATE);
+        public List<String> getSupportedFlashModes() {
+            String str = get(KEY_FLASH_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
-         * Gets the supported preview frame rates.
+         * Gets the current focus mode setting.
          *
-         * @return a list of supported preview frame rates. null if preview
-         *         frame rate setting is not supported.
-         * @deprecated replaced by {@link #getSupportedPreviewFpsRange()}
+         * @return current focus mode. This method will always return a non-null
+         *         value. Applications should call {@link
+         *         #autoFocus(AutoFocusCallback)} to start the focus if focus
+         *         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
+         * @see #FOCUS_MODE_AUTO
+         * @see #FOCUS_MODE_INFINITY
+         * @see #FOCUS_MODE_MACRO
+         * @see #FOCUS_MODE_FIXED
+         * @see #FOCUS_MODE_EDOF
+         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
          */
-        @Deprecated
-        public List<Integer> getSupportedPreviewFrameRates() {
-            String str = get(KEY_PREVIEW_FRAME_RATE + SUPPORTED_VALUES_SUFFIX);
-            return splitInt(str);
+        public String getFocusMode() {
+            return get(KEY_FOCUS_MODE);
         }
 
         /**
-         * Sets the minimum and maximum preview fps. This controls the rate of
-         * preview frames received in {@link PreviewCallback}. The minimum and
-         * maximum preview fps must be one of the elements from {@link
-         * #getSupportedPreviewFpsRange}.
+         * Sets the focus mode.
          *
-         * @param min the minimum preview fps (scaled by 1000).
-         * @param max the maximum preview fps (scaled by 1000).
-         * @throws RuntimeException if fps range is invalid.
-         * @see #setPreviewCallbackWithBuffer(Camera.PreviewCallback)
-         * @see #getSupportedPreviewFpsRange()
+         * @param value focus mode.
+         * @see #getFocusMode()
          */
-        public void setPreviewFpsRange(int min, int max) {
-            set(KEY_PREVIEW_FPS_RANGE, "" + min + "," + max);
+        public void setFocusMode(String value) {
+            set(KEY_FOCUS_MODE, value);
         }
 
         /**
-         * Returns the current minimum and maximum preview fps. The values are
-         * one of the elements returned by {@link #getSupportedPreviewFpsRange}.
+         * Gets the supported focus modes.
          *
-         * @return range the minimum and maximum preview fps (scaled by 1000).
-         * @see #PREVIEW_FPS_MIN_INDEX
-         * @see #PREVIEW_FPS_MAX_INDEX
-         * @see #getSupportedPreviewFpsRange()
+         * @return a list of supported focus modes. This method will always
+         *         return a list with at least one element.
+         * @see #getFocusMode()
          */
-        public void getPreviewFpsRange(int[] range) {
-            if (range == null || range.length != 2) {
-                throw new IllegalArgumentException(
-                        "range must be an array with two elements.");
-            }
-            splitInt(get(KEY_PREVIEW_FPS_RANGE), range);
+        public List<String> getSupportedFocusModes() {
+            String str = get(KEY_FOCUS_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
-         * Gets the supported preview fps (frame-per-second) ranges. Each range
-         * contains a minimum fps and maximum fps. If minimum fps equals to
-         * maximum fps, the camera outputs frames in fixed frame rate. If not,
-         * the camera outputs frames in auto frame rate. The actual frame rate
-         * fluctuates between the minimum and the maximum. The values are
-         * multiplied by 1000 and represented in integers. For example, if frame
-         * rate is 26.623 frames per second, the value is 26623.
+         * Gets the focal length (in millimeter) of the camera.
          *
-         * @return a list of supported preview fps ranges. This method returns a
-         *         list with at least one element. Every element is an int array
-         *         of two values - minimum fps and maximum fps. The list is
-         *         sorted from small to large (first by maximum fps and then
-         *         minimum fps).
-         * @see #PREVIEW_FPS_MIN_INDEX
-         * @see #PREVIEW_FPS_MAX_INDEX
+         * @return the focal length. This method will always return a valid
+         *         value.
          */
-        public List<int[]> getSupportedPreviewFpsRange() {
-            String str = get(KEY_PREVIEW_FPS_RANGE + SUPPORTED_VALUES_SUFFIX);
-            return splitRange(str);
+        public float getFocalLength() {
+            return Float.parseFloat(get(KEY_FOCAL_LENGTH));
         }
 
         /**
-         * Sets the image format for preview pictures.
-         * <p>If this is never called, the default format will be
-         * {@link android.graphics.ImageFormat#NV21}, which
-         * uses the NV21 encoding format.</p>
-         *
-         * <p>Use {@link Parameters#getSupportedPreviewFormats} to get a list of
-         * the available preview formats.
-         *
-         * <p>It is strongly recommended that either
-         * {@link android.graphics.ImageFormat#NV21} or
-         * {@link android.graphics.ImageFormat#YV12} is used, since
-         * they are supported by all camera devices.</p>
-         *
-         * <p>For YV12, the image buffer that is received is not necessarily
-         * tightly packed, as there may be padding at the end of each row of
-         * pixel data, as described in
-         * {@link android.graphics.ImageFormat#YV12}. For camera callback data,
-         * it can be assumed that the stride of the Y and UV data is the
-         * smallest possible that meets the alignment requirements. That is, if
-         * the preview size is <var>width x height</var>, then the following
-         * equations describe the buffer index for the beginning of row
-         * <var>y</var> for the Y plane and row <var>c</var> for the U and V
-         * planes:
-         *
-         * {@code
-         * <pre>
-         * yStride   = (int) ceil(width / 16.0) * 16;
-         * uvStride  = (int) ceil( (yStride / 2) / 16.0) * 16;
-         * ySize     = yStride * height;
-         * uvSize    = uvStride * height / 2;
-         * yRowIndex = yStride * y;
-         * uRowIndex = ySize + uvSize + uvStride * c;
-         * vRowIndex = ySize + uvStride * c;
-         * size      = ySize + uvSize * 2;</pre>
-         * }
-         *
-         * @param pixel_format the desired preview picture format, defined by
-         *   one of the {@link android.graphics.ImageFormat} constants.  (E.g.,
-         *   <var>ImageFormat.NV21</var> (default), or
-         *   <var>ImageFormat.YV12</var>)
+         * Gets the horizontal angle of view in degrees.
          *
-         * @see android.graphics.ImageFormat
-         * @see android.hardware.Camera.Parameters#getSupportedPreviewFormats
+         * @return horizontal angle of view. This method will always return a
+         *         valid value.
          */
-        public void setPreviewFormat(int pixel_format) {
-            String s = cameraFormatForPixelFormat(pixel_format);
-            if (s == null) {
-                throw new IllegalArgumentException(
-                        "Invalid pixel_format=" + pixel_format);
-            }
-
-            set(KEY_PREVIEW_FORMAT, s);
+        public float getHorizontalViewAngle() {
+            return Float.parseFloat(get(KEY_HORIZONTAL_VIEW_ANGLE));
         }
 
         /**
-         * Returns the image format for preview frames got from
-         * {@link PreviewCallback}.
+         * Gets the vertical angle of view in degrees.
          *
-         * @return the preview format.
-         * @see android.graphics.ImageFormat
-         * @see #setPreviewFormat
-         */
-        public int getPreviewFormat() {
-            return pixelFormatForCameraFormat(get(KEY_PREVIEW_FORMAT));
+         * @return vertical angle of view. This method will always return a
+         *         valid value.
+         */
+        public float getVerticalViewAngle() {
+            return Float.parseFloat(get(KEY_VERTICAL_VIEW_ANGLE));
         }
 
         /**
-         * Gets the supported preview formats. {@link android.graphics.ImageFormat#NV21}
-         * is always supported. {@link android.graphics.ImageFormat#YV12}
-         * is always supported since API level 12.
+         * Gets the current exposure compensation index.
          *
-         * @return a list of supported preview formats. This method will always
-         *         return a list with at least one element.
-         * @see android.graphics.ImageFormat
-         * @see #setPreviewFormat
+         * @return current exposure compensation index. The range is {@link
+         *         #getMinExposureCompensation} to {@link
+         *         #getMaxExposureCompensation}. 0 means exposure is not
+         *         adjusted.
          */
-        public List<Integer> getSupportedPreviewFormats() {
-            String str = get(KEY_PREVIEW_FORMAT + SUPPORTED_VALUES_SUFFIX);
-            ArrayList<Integer> formats = new ArrayList<Integer>();
-            for (String s : split(str)) {
-                int f = pixelFormatForCameraFormat(s);
-                if (f == ImageFormat.UNKNOWN) continue;
-                formats.add(f);
-            }
-            return formats;
+        public int getExposureCompensation() {
+            return getInt(KEY_EXPOSURE_COMPENSATION, 0);
         }
 
         /**
-         * <p>Sets the dimensions for pictures.</p>
-         *
-         * <p>Applications need to consider the display orientation. See {@link
-         * #setPreviewSize(int,int)} for reference.</p>
-         *
-         * @param width  the width for pictures, in pixels
-         * @param height the height for pictures, in pixels
-         * @see #setPreviewSize(int,int)
+         * Sets the exposure compensation index.
          *
+         * @param value exposure compensation index. The valid value range is
+         *        from {@link #getMinExposureCompensation} (inclusive) to {@link
+         *        #getMaxExposureCompensation} (inclusive). 0 means exposure is
+         *        not adjusted. Application should call
+         *        getMinExposureCompensation and getMaxExposureCompensation to
+         *        know if exposure compensation is supported.
          */
-        public void setPictureSize(int width, int height) {
-            String v = Integer.toString(width) + "x" + Integer.toString(height);
-            set(KEY_PICTURE_SIZE, v);
+        public void setExposureCompensation(int value) {
+            set(KEY_EXPOSURE_COMPENSATION, value);
         }
 
         /**
-         * Returns the dimension setting for pictures.
+         * Gets the maximum exposure compensation index.
          *
-         * @return a Size object with the height and width setting
-         *          for pictures
+         * @return maximum exposure compensation index (>=0). If both this
+         *         method and {@link #getMinExposureCompensation} return 0,
+         *         exposure compensation is not supported.
          */
-        public Size getPictureSize() {
-            String pair = get(KEY_PICTURE_SIZE);
-            return strToSize(pair);
+        public int getMaxExposureCompensation() {
+            return getInt(KEY_MAX_EXPOSURE_COMPENSATION, 0);
         }
 
         /**
-         * Gets the supported picture sizes.
+         * Gets the minimum exposure compensation index.
          *
-         * @return a list of supported picture sizes. This method will always
-         *         return a list with at least one element.
+         * @return minimum exposure compensation index (<=0). If both this
+         *         method and {@link #getMaxExposureCompensation} return 0,
+         *         exposure compensation is not supported.
          */
-        public List<Size> getSupportedPictureSizes() {
-            String str = get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX);
-            return splitSize(str);
+        public int getMinExposureCompensation() {
+            return getInt(KEY_MIN_EXPOSURE_COMPENSATION, 0);
         }
 
         /**
-         * Sets the image format for pictures.
+         * Gets the exposure compensation step.
          *
-         * @param pixel_format the desired picture format
-         *                     (<var>ImageFormat.NV21</var>,
-         *                      <var>ImageFormat.RGB_565</var>, or
-         *                      <var>ImageFormat.JPEG</var>)
-         * @see android.graphics.ImageFormat
+         * @return exposure compensation step. Applications can get EV by
+         *         multiplying the exposure compensation index and step. Ex: if
+         *         exposure compensation index is -6 and step is 0.333333333, EV
+         *         is -2.
          */
-        public void setPictureFormat(int pixel_format) {
-            String s = cameraFormatForPixelFormat(pixel_format);
-            if (s == null) {
-                throw new IllegalArgumentException(
-                        "Invalid pixel_format=" + pixel_format);
-            }
-
-            set(KEY_PICTURE_FORMAT, s);
+        public float getExposureCompensationStep() {
+            return getFloat(KEY_EXPOSURE_COMPENSATION_STEP, 0);
         }
 
         /**
-         * Returns the image format for pictures.
+         * <p>Sets the auto-exposure lock state. Applications should check
+         * {@link #isAutoExposureLockSupported} before using this method.</p>
          *
-         * @return the picture format
-         * @see android.graphics.ImageFormat
+         * <p>If set to true, the camera auto-exposure routine will immediately
+         * pause until the lock is set to false. Exposure compensation settings
+         * changes will still take effect while auto-exposure is locked.</p>
+         *
+         * <p>If auto-exposure is already locked, setting this to true again has
+         * no effect (the driver will not recalculate exposure values).</p>
+         *
+         * <p>Stopping preview with {@link #stopPreview()}, or triggering still
+         * image capture with {@link #takePicture(Camera.ShutterCallback,
+         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the
+         * lock.</p>
+         *
+         * <p>Exposure compensation, auto-exposure lock, and auto-white balance
+         * lock can be used to capture an exposure-bracketed burst of images,
+         * for example.</p>
+         *
+         * <p>Auto-exposure state, including the lock state, will not be
+         * maintained after camera {@link #release()} is called.  Locking
+         * auto-exposure after {@link #open()} but before the first call to
+         * {@link #startPreview()} will not allow the auto-exposure routine to
+         * run at all, and may result in severely over- or under-exposed
+         * images.</p>
+         *
+         * @param toggle new state of the auto-exposure lock. True means that
+         *        auto-exposure is locked, false means that the auto-exposure
+         *        routine is free to run normally.
+         *
+         * @see #getAutoExposureLock()
          */
-        public int getPictureFormat() {
-            return pixelFormatForCameraFormat(get(KEY_PICTURE_FORMAT));
+        public void setAutoExposureLock(boolean toggle) {
+            set(KEY_AUTO_EXPOSURE_LOCK, toggle ? TRUE : FALSE);
         }
 
         /**
-         * Gets the supported picture formats.
+         * Gets the state of the auto-exposure lock. Applications should check
+         * {@link #isAutoExposureLockSupported} before using this method. See
+         * {@link #setAutoExposureLock} for details about the lock.
+         *
+         * @return State of the auto-exposure lock. Returns true if
+         *         auto-exposure is currently locked, and false otherwise.
+         *
+         * @see #setAutoExposureLock(boolean)
          *
-         * @return supported picture formats. This method will always return a
-         *         list with at least one element.
-         * @see android.graphics.ImageFormat
          */
-        public List<Integer> getSupportedPictureFormats() {
-            String str = get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX);
-            ArrayList<Integer> formats = new ArrayList<Integer>();
-            for (String s : split(str)) {
-                int f = pixelFormatForCameraFormat(s);
-                if (f == ImageFormat.UNKNOWN) continue;
-                formats.add(f);
-            }
-            return formats;
-        }
-
-        private String cameraFormatForPixelFormat(int pixel_format) {
-            switch(pixel_format) {
-            case ImageFormat.NV16:      return PIXEL_FORMAT_YUV422SP;
-            case ImageFormat.NV21:      return PIXEL_FORMAT_YUV420SP;
-            case ImageFormat.YUY2:      return PIXEL_FORMAT_YUV422I;
-            case ImageFormat.YV12:      return PIXEL_FORMAT_YUV420P;
-            case ImageFormat.RGB_565:   return PIXEL_FORMAT_RGB565;
-            case ImageFormat.JPEG:      return PIXEL_FORMAT_JPEG;
-            default:                    return null;
-            }
+        public boolean getAutoExposureLock() {
+            String str = get(KEY_AUTO_EXPOSURE_LOCK);
+            return TRUE.equals(str);
         }
 
-        private int pixelFormatForCameraFormat(String format) {
-            if (format == null)
-                return ImageFormat.UNKNOWN;
-
-            if (format.equals(PIXEL_FORMAT_YUV422SP))
-                return ImageFormat.NV16;
-
-            if (format.equals(PIXEL_FORMAT_YUV420SP))
-                return ImageFormat.NV21;
-
-            if (format.equals(PIXEL_FORMAT_YUV422I))
-                return ImageFormat.YUY2;
-
-            if (format.equals(PIXEL_FORMAT_YUV420P))
-                return ImageFormat.YV12;
-
-            if (format.equals(PIXEL_FORMAT_RGB565))
-                return ImageFormat.RGB_565;
-
-            if (format.equals(PIXEL_FORMAT_JPEG))
-                return ImageFormat.JPEG;
-
-            return ImageFormat.UNKNOWN;
+        /**
+         * Returns true if auto-exposure locking is supported. Applications
+         * should call this before trying to lock auto-exposure. See
+         * {@link #setAutoExposureLock} for details about the lock.
+         *
+         * @return true if auto-exposure lock is supported.
+         * @see #setAutoExposureLock(boolean)
+         *
+         */
+        public boolean isAutoExposureLockSupported() {
+            String str = get(KEY_AUTO_EXPOSURE_LOCK_SUPPORTED);
+            return TRUE.equals(str);
         }
 
         /**
-         * Sets the clockwise rotation angle in degrees relative to the
-         * orientation of the camera. This affects the pictures returned from
-         * JPEG {@link PictureCallback}. The camera driver may set orientation
-         * in the EXIF header without rotating the picture. Or the driver may
-         * rotate the picture and the EXIF thumbnail. If the Jpeg picture is
-         * rotated, the orientation in the EXIF header will be missing or 1 (row
-         * #0 is top and column #0 is left side).
+         * <p>Sets the auto-white balance lock state. Applications should check
+         * {@link #isAutoWhiteBalanceLockSupported} before using this
+         * method.</p>
          *
-         * <p>
-         * If applications want to rotate the picture to match the orientation
-         * of what users see, apps should use
-         * {@link android.view.OrientationEventListener} and
-         * {@link android.hardware.Camera.CameraInfo}. The value from
-         * OrientationEventListener is relative to the natural orientation of
-         * the device. CameraInfo.orientation is the angle between camera
-         * orientation and natural device orientation. The sum of the two is the
-         * rotation angle for back-facing camera. The difference of the two is
-         * the rotation angle for front-facing camera. Note that the JPEG
-         * pictures of front-facing cameras are not mirrored as in preview
-         * display.
+         * <p>If set to true, the camera auto-white balance routine will
+         * immediately pause until the lock is set to false.</p>
          *
-         * <p>
-         * For example, suppose the natural orientation of the device is
-         * portrait. The device is rotated 270 degrees clockwise, so the device
-         * orientation is 270. Suppose a back-facing camera sensor is mounted in
-         * landscape and the top side of the camera sensor is aligned with the
-         * right edge of the display in natural orientation. So the camera
-         * orientation is 90. The rotation should be set to 0 (270 + 90).
+         * <p>If auto-white balance is already locked, setting this to true
+         * again has no effect (the driver will not recalculate white balance
+         * values).</p>
+         *
+         * <p>Stopping preview with {@link #stopPreview()}, or triggering still
+         * image capture with {@link #takePicture(Camera.ShutterCallback,
+         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the
+         * the lock.</p>
+         *
+         * <p> Changing the white balance mode with {@link #setWhiteBalance}
+         * will release the auto-white balance lock if it is set.</p>
+         *
+         * <p>Exposure compensation, AE lock, and AWB lock can be used to
+         * capture an exposure-bracketed burst of images, for example.
+         * Auto-white balance state, including the lock state, will not be
+         * maintained after camera {@link #release()} is called.  Locking
+         * auto-white balance after {@link #open()} but before the first call to
+         * {@link #startPreview()} will not allow the auto-white balance routine
+         * to run at all, and may result in severely incorrect color in captured
+         * images.</p>
+         *
+         * @param toggle new state of the auto-white balance lock. True means
+         *        that auto-white balance is locked, false means that the
+         *        auto-white balance routine is free to run normally.
+         *
+         * @see #getAutoWhiteBalanceLock()
+         * @see #setWhiteBalance(String)
+         */
+        public void setAutoWhiteBalanceLock(boolean toggle) {
+            set(KEY_AUTO_WHITEBALANCE_LOCK, toggle ? TRUE : FALSE);
+        }
+
+        /**
+         * Gets the state of the auto-white balance lock. Applications should
+         * check {@link #isAutoWhiteBalanceLockSupported} before using this
+         * method. See {@link #setAutoWhiteBalanceLock} for details about the
+         * lock.
          *
-         * <p>The reference code is as follows.
+         * @return State of the auto-white balance lock. Returns true if
+         *         auto-white balance is currently locked, and false
+         *         otherwise.
          *
-         * <pre>
-         * public void onOrientationChanged(int orientation) {
-         *     if (orientation == ORIENTATION_UNKNOWN) return;
-         *     android.hardware.Camera.CameraInfo info =
-         *            new android.hardware.Camera.CameraInfo();
-         *     android.hardware.Camera.getCameraInfo(cameraId, info);
-         *     orientation = (orientation + 45) / 90 * 90;
-         *     int rotation = 0;
-         *     if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
-         *         rotation = (info.orientation - orientation + 360) % 360;
-         *     } else {  // back-facing camera
-         *         rotation = (info.orientation + orientation) % 360;
-         *     }
-         *     mParameters.setRotation(rotation);
-         * }
-         * </pre>
+         * @see #setAutoWhiteBalanceLock(boolean)
          *
-         * @param rotation The rotation angle in degrees relative to the
-         *                 orientation of the camera. Rotation can only be 0,
-         *                 90, 180 or 270.
-         * @throws IllegalArgumentException if rotation value is invalid.
-         * @see android.view.OrientationEventListener
-         * @see #getCameraInfo(int, CameraInfo)
          */
-        public void setRotation(int rotation) {
-            if (rotation == 0 || rotation == 90 || rotation == 180
-                    || rotation == 270) {
-                set(KEY_ROTATION, Integer.toString(rotation));
-            } else {
-                throw new IllegalArgumentException(
-                        "Invalid rotation=" + rotation);
-            }
+        public boolean getAutoWhiteBalanceLock() {
+            String str = get(KEY_AUTO_WHITEBALANCE_LOCK);
+            return TRUE.equals(str);
         }
 
         /**
-         * Sets GPS latitude coordinate. This will be stored in JPEG EXIF
-         * header.
+         * Returns true if auto-white balance locking is supported. Applications
+         * should call this before trying to lock auto-white balance. See
+         * {@link #setAutoWhiteBalanceLock} for details about the lock.
+         *
+         * @return true if auto-white balance lock is supported.
+         * @see #setAutoWhiteBalanceLock(boolean)
          *
-         * @param latitude GPS latitude coordinate.
          */
-        public void setGpsLatitude(double latitude) {
-            set(KEY_GPS_LATITUDE, Double.toString(latitude));
+        public boolean isAutoWhiteBalanceLockSupported() {
+            String str = get(KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED);
+            return TRUE.equals(str);
         }
 
         /**
-         * Sets GPS longitude coordinate. This will be stored in JPEG EXIF
-         * header.
+         * Gets current zoom value. This also works when smooth zoom is in
+         * progress. Applications should check {@link #isZoomSupported} before
+         * using this method.
          *
-         * @param longitude GPS longitude coordinate.
+         * @return the current zoom value. The range is 0 to {@link
+         *         #getMaxZoom}. 0 means the camera is not zoomed.
          */
-        public void setGpsLongitude(double longitude) {
-            set(KEY_GPS_LONGITUDE, Double.toString(longitude));
+        public int getZoom() {
+            return getInt(KEY_ZOOM, 0);
         }
 
         /**
-         * Sets GPS altitude. This will be stored in JPEG EXIF header.
+         * Sets current zoom value. If the camera is zoomed (value > 0), the
+         * actual picture size may be smaller than picture size setting.
+         * Applications can check the actual picture size after picture is
+         * returned from {@link PictureCallback}. The preview size remains the
+         * same in zoom. Applications should check {@link #isZoomSupported}
+         * before using this method.
          *
-         * @param altitude GPS altitude in meters.
+         * @param value zoom value. The valid range is 0 to {@link #getMaxZoom}.
          */
-        public void setGpsAltitude(double altitude) {
-            set(KEY_GPS_ALTITUDE, Double.toString(altitude));
+        public void setZoom(int value) {
+            set(KEY_ZOOM, value);
         }
 
         /**
-         * Sets GPS timestamp. This will be stored in JPEG EXIF header.
+         * Returns true if zoom is supported. Applications should call this
+         * before using other zoom methods.
          *
-         * @param timestamp GPS timestamp (UTC in seconds since January 1,
-         *                  1970).
+         * @return true if zoom is supported.
          */
-        public void setGpsTimestamp(long timestamp) {
-            set(KEY_GPS_TIMESTAMP, Long.toString(timestamp));
+        public boolean isZoomSupported() {
+            String str = get(KEY_ZOOM_SUPPORTED);
+            return TRUE.equals(str);
         }
 
         /**
-         * Sets GPS processing method. It will store up to 32 characters
-         * in JPEG EXIF header.
+         * Gets the maximum zoom value allowed for snapshot. This is the maximum
+         * value that applications can set to {@link #setZoom(int)}.
+         * Applications should call {@link #isZoomSupported} before using this
+         * method. This value may change in different preview size. Applications
+         * should call this again after setting preview size.
          *
-         * @param processing_method The processing method to get this location.
+         * @return the maximum zoom value supported by the camera.
          */
-        public void setGpsProcessingMethod(String processing_method) {
-            set(KEY_GPS_PROCESSING_METHOD, processing_method);
+        public int getMaxZoom() {
+            return getInt(KEY_MAX_ZOOM, 0);
         }
 
         /**
-         * Removes GPS latitude, longitude, altitude, and timestamp from the
-         * parameters.
+         * Gets the zoom ratios of all zoom values. Applications should check
+         * {@link #isZoomSupported} before using this method.
+         *
+         * @return the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
+         *         returned as 320. The number of elements is {@link
+         *         #getMaxZoom} + 1. The list is sorted from small to large. The
+         *         first element is always 100. The last element is the zoom
+         *         ratio of the maximum zoom value.
          */
-        public void removeGpsData() {
-            remove(KEY_QC_GPS_LATITUDE_REF);
-            remove(KEY_GPS_LATITUDE);
-            remove(KEY_QC_GPS_LONGITUDE_REF);
-            remove(KEY_GPS_LONGITUDE);
-            remove(KEY_QC_GPS_ALTITUDE_REF);
-            remove(KEY_GPS_ALTITUDE);
-            remove(KEY_GPS_TIMESTAMP);
-            remove(KEY_GPS_PROCESSING_METHOD);
+        public List<Integer> getZoomRatios() {
+            return splitInt(get(KEY_ZOOM_RATIOS));
         }
 
         /**
-         * Gets the current white balance setting.
-         *
-         * @return current white balance. null if white balance setting is not
-         *         supported.
-         * @see #WHITE_BALANCE_AUTO
-         * @see #WHITE_BALANCE_INCANDESCENT
-         * @see #WHITE_BALANCE_FLUORESCENT
-         * @see #WHITE_BALANCE_WARM_FLUORESCENT
-         * @see #WHITE_BALANCE_DAYLIGHT
-         * @see #WHITE_BALANCE_CLOUDY_DAYLIGHT
-         * @see #WHITE_BALANCE_TWILIGHT
-         * @see #WHITE_BALANCE_SHADE
+         * Returns true if smooth zoom is supported. Applications should call
+         * this before using other smooth zoom methods.
          *
+         * @return true if smooth zoom is supported.
          */
-        public String getWhiteBalance() {
-            return get(KEY_WHITE_BALANCE);
+        public boolean isSmoothZoomSupported() {
+            String str = get(KEY_SMOOTH_ZOOM_SUPPORTED);
+            return TRUE.equals(str);
         }
 
+        //!++
+        // ISO
         /**
-         * Sets the white balance. Changing the setting will release the
-         * auto-white balance lock. It is recommended not to change white
-         * balance and AWB lock at the same time.
+         * @hide
+         * Gets the ISO speed
+         * @return "auto", "100", "200", "400", "800" or "1600"
+         */
+        public String getISOSpeed() {
+            return get(KEY_ISOSPEED_MODE);
+        }
+        /**
+         * @hide
+         * Sets the ISO speed
+         * @param value "auto", "100", "200", "400", "800" or "1600"
+         */
+        public void setISOSpeed(String value) {
+            set(KEY_ISOSPEED_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported ISO speed
+         * get all supported ISO speed
+         */
+        public List<String> getSupportedISOSpeed() {
+            String str = get(KEY_ISOSPEED_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        //OT
+        /**
+         * @hide get max num of objects
+         *
          *
-         * @param value new white balance.
-         * @see #getWhiteBalance()
-         * @see #setAutoWhiteBalanceLock(boolean)
          */
-        public void setWhiteBalance(String value) {
-            String oldValue = get(KEY_WHITE_BALANCE);
-            if (same(value, oldValue)) return;
-            set(KEY_WHITE_BALANCE, value);
-            set(KEY_AUTO_WHITEBALANCE_LOCK, FALSE);
+        public int getMaxNumDetectedObjects() {
+            return getInt(Parameters.KEY_MAX_NUM_DETECTED_OBJECT, 0);
         }
 
+        // FDMode
         /**
-         * Gets the supported white balance.
-         *
-         * @return a list of supported white balance. null if white balance
-         *         setting is not supported.
-         * @see #getWhiteBalance()
+         * @hide
+         * Gets the FD mode
+         * @return "on" or "off"
          */
-        public List<String> getSupportedWhiteBalance() {
-            String str = get(KEY_WHITE_BALANCE + SUPPORTED_VALUES_SUFFIX);
+        public String getFDMode() {
+            return get(KEY_FD_MODE);
+        }
+        /**
+         * @hide
+         * Sets the FD mode
+         * @param value "on" or "off"
+         */
+        public void setFDMode(String value) {
+            set(KEY_FD_MODE, value);
+        }
+        /**
+         * @hide
+         */
+        public List<String> getSupportedFDMode() {
+            String str = get(KEY_FD_MODE + SUPPORTED_VALUES_SUFFIX);
             return split(str);
         }
-
+        // Edge
         /**
-         * Gets the current color effect setting.
-         *
-         * @return current color effect. null if color effect
-         *         setting is not supported.
-         * @see #EFFECT_NONE
-         * @see #EFFECT_MONO
-         * @see #EFFECT_NEGATIVE
-         * @see #EFFECT_SOLARIZE
-         * @see #EFFECT_SEPIA
-         * @see #EFFECT_POSTERIZE
-         * @see #EFFECT_WHITEBOARD
-         * @see #EFFECT_BLACKBOARD
-         * @see #EFFECT_AQUA
+         * @hide
+         * @return the edge mode
+         * get the edge mode
+         */
+        public String getEdgeMode() {
+            return get(KEY_EDGE_MODE);
+        }
+        /**
+         * @hide
+         * @param value : the value set for edge mode
+         * set value for edge mode
+         */
+        public void setEdgeMode(String value) {
+            set(KEY_EDGE_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported edge mode
+         * get all supported edge mode
+         */
+        public List<String> getSupportedEdgeMode() {
+            String str = get(KEY_EDGE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        // Hue
+        /**
+         * @hide
+         * @return the hue mode
+         * get the hue mode
+         */
+        public String getHueMode() {
+            return get(KEY_HUE_MODE);
+        }
+        /**
+         * @hide
+         * @param value: the value set for hue mode
+         * set value for hue mode
+         */
+        public void setHueMode(String value) {
+            set(KEY_HUE_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported hue mode
+         * get all supported hue mode
+         */
+        public List<String> getSupportedHueMode() {
+            String str = get(KEY_HUE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        // Saturation
+        /**
+         * @hide
+         * @return the Saturation mode
+         * get the Saturation mode
+         */
+        public String getSaturationMode() {
+            return get(KEY_SATURATION_MODE);
+        }
+        /**
+         * @hide
+         * @param value: the value set to Saturation
+         * set value for Saturation
+         */
+        public void setSaturationMode(String value) {
+            set(KEY_SATURATION_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported Saturation mode
+         * get all supported Saturation mode
+         */
+        public List<String> getSupportedSaturationMode() {
+            String str = get(KEY_SATURATION_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        // Brightness
+        /**
+         * @hide
+         * @return the brightness mode
+         * get the brightness mode
+         */
+        public String getBrightnessMode() {
+            return get(KEY_BRIGHTNESS_MODE);
+        }
+        /**
+         * @hide
+         * @param value: the value set to brightness mode
+         * set value for brightness mode
+         */
+        public void setBrightnessMode(String value) {
+            set(KEY_BRIGHTNESS_MODE, value);
+        }
+        /**
+         * @hide
+         */
+        public List<String> getSupportedBrightnessMode() {
+            String str = get(KEY_BRIGHTNESS_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        // Contrast
+        /**
+         * @hide
+         * @return the contrast mode
+         * get the contrast mode
          */
-        public String getColorEffect() {
-            return get(KEY_EFFECT);
+        public String getContrastMode() {
+            return get(KEY_CONTRAST_MODE);
         }
-
         /**
-         * Sets the current color effect setting.
-         *
-         * @param value new color effect.
-         * @see #getColorEffect()
+         * @hide
+         * @param value: the value set to contrast mode
+         * set value for contrast mode
          */
-        public void setColorEffect(String value) {
-            set(KEY_EFFECT, value);
+        public void setContrastMode(String value) {
+            set(KEY_CONTRAST_MODE, value);
         }
-
         /**
-         * Gets the supported color effects.
-         *
-         * @return a list of supported color effects. null if color effect
-         *         setting is not supported.
-         * @see #getColorEffect()
+         * @hide
+         * @return the supported contrast mode
+         * get all supported contrast mode
          */
-        public List<String> getSupportedColorEffects() {
-            String str = get(KEY_EFFECT + SUPPORTED_VALUES_SUFFIX);
+        public List<String> getSupportedContrastMode() {
+            String str = get(KEY_CONTRAST_MODE + SUPPORTED_VALUES_SUFFIX);
             return split(str);
         }
-
-
+        // Capture mode
         /**
-         * Gets the current antibanding setting.
-         *
-         * @return current antibanding. null if antibanding setting is not
-         *         supported.
-         * @see #ANTIBANDING_AUTO
-         * @see #ANTIBANDING_50HZ
-         * @see #ANTIBANDING_60HZ
-         * @see #ANTIBANDING_OFF
+         * @hide
          */
-        public String getAntibanding() {
-            return get(KEY_ANTIBANDING);
+        public String getCaptureMode() {
+            return get(KEY_CAPTURE_MODE);
         }
-
         /**
-         * Sets the antibanding.
-         *
-         * @param antibanding new antibanding value.
-         * @see #getAntibanding()
+         * @hide
+         * @param value: CAPTURE_MODE_NORMAL, CAPTURE_MODE_BEST_SHOT,
+         *        CAPTURE_MODE_EV_BRACKET_SHOT, CAPTURE_MODE_BURST_SHOT,
+         *        CAPTURE_MODE_SMILE_SHOT, CAPTURE_MODE_PANORAMA_SHOT
          */
-        public void setAntibanding(String antibanding) {
-            set(KEY_ANTIBANDING, antibanding);
+        public void setCaptureMode(String value) {
+            set(KEY_CAPTURE_MODE, value);
         }
-
         /**
-         * Gets the supported antibanding values.
-         *
-         * @return a list of supported antibanding values. null if antibanding
-         *         setting is not supported.
-         * @see #getAntibanding()
+         * @hide
+         * @return the supported capture mode
+         * get all supported capture mode
          */
-        public List<String> getSupportedAntibanding() {
-            String str = get(KEY_ANTIBANDING + SUPPORTED_VALUES_SUFFIX);
+        public List<String> getSupportedCaptureMode() {
+            String str = get(KEY_CAPTURE_MODE + SUPPORTED_VALUES_SUFFIX);
             return split(str);
         }
-
         /**
-         * Gets the current scene mode setting.
+         * @hide
+         * @param   value: file path, if file path is /sdcard/DCIM/cap00, the output file
+         * will be cap00, cap01, cap02, ...
+         * set the storage path for capture image store
+         */
+        public void setCapturePath(String value) {
+            if (value == null) {
+                remove(KEY_CAPTURE_PATH);
+            } else {
+                set(KEY_CAPTURE_PATH, value);
+            }
+        }
+        /**
+         * @hide
+         * @param  value: should be 4 / 8 / 16
+         * set the burst shot number
+         */
+        public void setBurstShotNum(int value) {
+            set(KEY_BURST_SHOT_NUM, value);
+        }
+        /**
+         * @hide
          *
-         * @return one of SCENE_MODE_XXX string constant. null if scene mode
-         *         setting is not supported.
-         * @see #SCENE_MODE_AUTO
-         * @see #SCENE_MODE_ACTION
-         * @see #SCENE_MODE_PORTRAIT
-         * @see #SCENE_MODE_LANDSCAPE
-         * @see #SCENE_MODE_NIGHT
-         * @see #SCENE_MODE_NIGHT_PORTRAIT
-         * @see #SCENE_MODE_THEATRE
-         * @see #SCENE_MODE_BEACH
-         * @see #SCENE_MODE_SNOW
-         * @see #SCENE_MODE_SUNSET
-         * @see #SCENE_MODE_STEADYPHOTO
-         * @see #SCENE_MODE_FIREWORKS
-         * @see #SCENE_MODE_SPORTS
-         * @see #SCENE_MODE_PARTY
-         * @see #SCENE_MODE_CANDLELIGHT
-         * @see #SCENE_MODE_BARCODE
+         * Sets the focus engineer mode
+         * mode: FOCUS_ENG_MODE_NONE, FOCUS_ENG_MODE_BRACKET,
+         *       FOCUS_ENG_MODE_FULLSCAN, FOCUS_ENG_MODE_REPEAT
          */
-        public String getSceneMode() {
-            return get(KEY_SCENE_MODE);
+        public void setFocusEngMode(int mode) {
+            set(KEY_FOCUS_ENG_MODE, mode);
         }
 
         /**
-         * Sets the scene mode. Changing scene mode may override other
-         * parameters (such as flash mode, focus mode, white balance). For
-         * example, suppose originally flash mode is on and supported flash
-         * modes are on/off. In night scene mode, both flash mode and supported
-         * flash mode may be changed to off. After setting scene mode,
-         * applications should call getParameters to know if some parameters are
-         * changed.
-         *
-         * @param value scene mode.
-         * @see #getSceneMode()
+         * @hide
+         * @return the step get the best focus
+         * get the step of doing the best focus
          */
-        public void setSceneMode(String value) {
-            set(KEY_SCENE_MODE, value);
+        public int getBestFocusStep() {
+            return getInt(KEY_FOCUS_ENG_BEST_STEP, 0);
         }
 
         /**
-         * Gets the supported scene modes.
-         *
-         * @return a list of supported scene modes. null if scene mode setting
-         *         is not supported.
-         * @see #getSceneMode()
+         * @hide
          */
-        public List<String> getSupportedSceneModes() {
-            String str = get(KEY_SCENE_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public void setRawDumpFlag(boolean toggle) {
+            Log.d(TAG, "setRawDumpFlag=" + toggle);
+            set(KEY_RAW_DUMP_FLAG, toggle ? TRUE : FALSE);
         }
 
         /**
-         * Gets the current flash mode setting.
-         *
-         * @return current flash mode. null if flash mode setting is not
-         *         supported.
-         * @see #FLASH_MODE_OFF
-         * @see #FLASH_MODE_AUTO
-         * @see #FLASH_MODE_ON
-         * @see #FLASH_MODE_RED_EYE
-         * @see #FLASH_MODE_TORCH
+         * @hide
          */
-        public String getFlashMode() {
-            return get(KEY_FLASH_MODE);
+        public void setPreviewRawDumpResolution(int value) {
+            Log.d(TAG, "setPreviewRawDumpResolution=" + value);
+            set(KEY_PREVIEW_DUMP_RESOLUTION, value);
         }
 
         /**
-         * Sets the flash mode.
+         * @hide
+         * Gets the maximum focus step.
          *
-         * @param value flash mode.
-         * @see #getFlashMode()
+         * @return maximum focus step.
          */
-        public void setFlashMode(String value) {
-            set(KEY_FLASH_MODE, value);
+        public int getMaxFocusStep() {
+            return getInt(KEY_FOCUS_ENG_MAX_STEP , 0);
         }
 
         /**
-         * Gets the supported flash modes.
+         * @hide
+         * Gets the minimum focus step.
          *
-         * @return a list of supported flash modes. null if flash mode setting
-         *         is not supported.
-         * @see #getFlashMode()
+         * @return minimum focus step.
          */
-        public List<String> getSupportedFlashModes() {
-            String str = get(KEY_FLASH_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public int getMinFocusStep() {
+            return getInt(KEY_FOCUS_ENG_STEP, 0);
         }
 
+
         /**
-         * Gets the current focus mode setting.
+         * @hide
          *
-         * @return current focus mode. This method will always return a non-null
-         *         value. Applications should call {@link
-         *         #autoFocus(AutoFocusCallback)} to start the focus if focus
-         *         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
-         * @see #FOCUS_MODE_AUTO
-         * @see #FOCUS_MODE_INFINITY
-         * @see #FOCUS_MODE_MACRO
-         * @see #FOCUS_MODE_FIXED
-         * @see #FOCUS_MODE_EDOF
-         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         * Sets the focus step for BRACKET / FULLSCAN mode
          */
-        public String getFocusMode() {
-            return get(KEY_FOCUS_MODE);
+        public void setFocusEngStep(int step) {
+            set(KEY_FOCUS_ENG_STEP, step);
         }
 
         /**
-         * Sets the focus mode.
+         * @hide
          *
-         * @param value focus mode.
-         * @see #getFocusMode()
+         * Sets the Exposure Meter mode for Obejct Tracking
          */
-        public void setFocusMode(String value) {
-            set(KEY_FOCUS_MODE, value);
+        public void setExposureMeterMode(String mode) {
+            set(KEY_EXPOSURE_METER_MODE, mode);
         }
 
         /**
-         * Gets the supported focus modes.
+         * @hide
          *
-         * @return a list of supported focus modes. This method will always
-         *         return a list with at least one element.
-         * @see #getFocusMode()
+         * Gets the Exposure Meter mode for Obejct Tracking
          */
-        public List<String> getSupportedFocusModes() {
-            String str = get(KEY_FOCUS_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public String getExposureMeterMode() {
+            return get(KEY_EXPOSURE_METER_MODE);
         }
 
         /**
-         * Gets the focal length (in millimeter) of the camera.
+         * @hide
+         * Gets types of sensors.
          *
-         * @return the focal length. This method will always return a valid
-         *         value.
+         * @return sensor type.
          */
-        public float getFocalLength() {
-            return Float.parseFloat(get(KEY_FOCAL_LENGTH));
+        public int getSensorType() {
+            return getInt(KEY_SENSOR_TYPE, 0);
         }
 
         /**
-         * Gets the horizontal angle of view in degrees.
+         * @hide
          *
-         * @return horizontal angle of view. This method will always return a
-         *         valid value.
+         * Set AE enable/disable in engineer mode
          */
-        public float getHorizontalViewAngle() {
-            return Float.parseFloat(get(KEY_HORIZONTAL_VIEW_ANGLE));
+        public void setEngAEEnable(int enable) {
+            set(KEY_ENG_AE_ENABLE, enable);
         }
 
+
         /**
-         * Gets the vertical angle of view in degrees.
+         * @hide
          *
-         * @return vertical angle of view. This method will always return a
-         *         valid value.
+         * Set Flash duty value in engineer mode
          */
-        public float getVerticalViewAngle() {
-            return Float.parseFloat(get(KEY_VERTICAL_VIEW_ANGLE));
+        public void setEngFlashDuty(int duty) {
+            set(KEY_ENG_FLASH_DUTY_VALUE, duty);
         }
 
+
         /**
-         * Gets the current exposure compensation index.
+         * @hide
          *
-         * @return current exposure compensation index. The range is {@link
-         *         #getMinExposureCompensation} to {@link
-         *         #getMaxExposureCompensation}. 0 means exposure is not
-         *         adjusted.
+         * Set ZSD mode in engineer mode
          */
-        public int getExposureCompensation() {
-            return getInt(KEY_EXPOSURE_COMPENSATION, 0);
+        public void setEngZSDEnable(int enable) {
+            set(KEY_ENG_ZSD_ENABLE, enable);
         }
 
         /**
-         * Sets the exposure compensation index.
+         * @hide
+         *
+         * Get preview shutter speed
          *
-         * @param value exposure compensation index. The valid value range is
-         *        from {@link #getMinExposureCompensation} (inclusive) to {@link
-         *        #getMaxExposureCompensation} (inclusive). 0 means exposure is
-         *        not adjusted. Application should call
-         *        getMinExposureCompensation and getMaxExposureCompensation to
-         *        know if exposure compensation is supported.
          */
-        public void setExposureCompensation(int value) {
-            set(KEY_EXPOSURE_COMPENSATION, value);
+        public int getEngPreviewShutterSpeed() {
+            return getInt(KEY_ENG_PREVIEW_SHUTTER_SPEED, 0);
         }
 
         /**
-         * Gets the maximum exposure compensation index.
+         * @hide
+         *
+         * Get preview sensor gain
          *
-         * @return maximum exposure compensation index (>=0). If both this
-         *         method and {@link #getMinExposureCompensation} return 0,
-         *         exposure compensation is not supported.
          */
-        public int getMaxExposureCompensation() {
-            return getInt(KEY_MAX_EXPOSURE_COMPENSATION, 0);
+        public int getEngPreviewSensorGain() {
+            return getInt(KEY_ENG_PREVIEW_SENSOR_GAIN, 0);
         }
 
         /**
-         * Gets the minimum exposure compensation index.
+         * @hide
+         *
+         * Get preview isp gain
          *
-         * @return minimum exposure compensation index (<=0). If both this
-         *         method and {@link #getMaxExposureCompensation} return 0,
-         *         exposure compensation is not supported.
          */
-        public int getMinExposureCompensation() {
-            return getInt(KEY_MIN_EXPOSURE_COMPENSATION, 0);
+        public int getEngPreviewISPGain() {
+            return getInt(KEY_ENG_PREVIEW_ISP_GAIN, 0);
         }
 
         /**
-         * Gets the exposure compensation step.
+         * @hide
+         *
+         * Get preview AE PLine index
          *
-         * @return exposure compensation step. Applications can get EV by
-         *         multiplying the exposure compensation index and step. Ex: if
-         *         exposure compensation index is -6 and step is 0.333333333, EV
-         *         is -2.
          */
-        public float getExposureCompensationStep() {
-            return getFloat(KEY_EXPOSURE_COMPENSATION_STEP, 0);
+        public int getEngPreviewAEIndex() {
+            return getInt(KEY_ENG_PREVIEW_AE_INDEX, 0);
         }
 
         /**
-         * <p>Sets the auto-exposure lock state. Applications should check
-         * {@link #isAutoExposureLockSupported} before using this method.</p>
-         *
-         * <p>If set to true, the camera auto-exposure routine will immediately
-         * pause until the lock is set to false. Exposure compensation settings
-         * changes will still take effect while auto-exposure is locked.</p>
+         * @hide
          *
-         * <p>If auto-exposure is already locked, setting this to true again has
-         * no effect (the driver will not recalculate exposure values).</p>
+         * Get capture sensor gain in preview
          *
-         * <p>Stopping preview with {@link #stopPreview()}, or triggering still
-         * image capture with {@link #takePicture(Camera.ShutterCallback,
-         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the
-         * lock.</p>
+         */
+        public int getEngCaptureSensorGain() {
+            return getInt(KEY_ENG_CAPTURE_SENSOR_GAIN, 0);
+        }
+
+        /**
+         * @hide
          *
-         * <p>Exposure compensation, auto-exposure lock, and auto-white balance
-         * lock can be used to capture an exposure-bracketed burst of images,
-         * for example.</p>
+         * Get capture isp gain in preview
          *
-         * <p>Auto-exposure state, including the lock state, will not be
-         * maintained after camera {@link #release()} is called.  Locking
-         * auto-exposure after {@link #open()} but before the first call to
-         * {@link #startPreview()} will not allow the auto-exposure routine to
-         * run at all, and may result in severely over- or under-exposed
-         * images.</p>
+         */
+        public int getEngCaptureISPGain() {
+            return getInt(KEY_ENG_CAPTURE_ISP_GAIN, 0);
+        }
+
+        /**
+         * @hide
          *
-         * @param toggle new state of the auto-exposure lock. True means that
-         *        auto-exposure is locked, false means that the auto-exposure
-         *        routine is free to run normally.
+         * Get capture shutter speed in preview
          *
-         * @see #getAutoExposureLock()
          */
-        public void setAutoExposureLock(boolean toggle) {
-            set(KEY_AUTO_EXPOSURE_LOCK, toggle ? TRUE : FALSE);
+        public int getEngCaptureShutterSpeed() {
+            return getInt(KEY_ENG_CAPTURE_SHUTTER_SPEED, 0);
         }
 
         /**
-         * Gets the state of the auto-exposure lock. Applications should check
-         * {@link #isAutoExposureLockSupported} before using this method. See
-         * {@link #setAutoExposureLock} for details about the lock.
-         *
-         * @return State of the auto-exposure lock. Returns true if
-         *         auto-exposure is currently locked, and false otherwise.
+         * @hide
          *
-         * @see #setAutoExposureLock(boolean)
+         * Get capture iso after capture
          *
          */
-        public boolean getAutoExposureLock() {
-            String str = get(KEY_AUTO_EXPOSURE_LOCK);
-            return TRUE.equals(str);
+        public int getEngCaptureISO() {
+            return getInt(KEY_ENG_CAPTURE_ISO, 0);
         }
 
         /**
-         * Returns true if auto-exposure locking is supported. Applications
-         * should call this before trying to lock auto-exposure. See
-         * {@link #setAutoExposureLock} for details about the lock.
+         * @hide
          *
-         * @return true if auto-exposure lock is supported.
-         * @see #setAutoExposureLock(boolean)
+         * Get flash duty minimax value
          *
          */
-        public boolean isAutoExposureLockSupported() {
-            String str = get(KEY_AUTO_EXPOSURE_LOCK_SUPPORTED);
-            return TRUE.equals(str);
+        public int getEngFlashDutyMin() {
+            return getInt(KEY_ENG_FLASH_DUTY_MIN, 0);
         }
 
         /**
-         * <p>Sets the auto-white balance lock state. Applications should check
-         * {@link #isAutoWhiteBalanceLockSupported} before using this
-         * method.</p>
-         *
-         * <p>If set to true, the camera auto-white balance routine will
-         * immediately pause until the lock is set to false.</p>
+         * @hide
          *
-         * <p>If auto-white balance is already locked, setting this to true
-         * again has no effect (the driver will not recalculate white balance
-         * values).</p>
+         * Get flash duty maximum value
          *
-         * <p>Stopping preview with {@link #stopPreview()}, or triggering still
-         * image capture with {@link #takePicture(Camera.ShutterCallback,
-         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the
-         * the lock.</p>
+         */
+        public int getEngFlashDutyMax() {
+            return getInt(KEY_ENG_FLASH_DUTY_MAX, 0);
+        }
+
+        /**
+         * @hide
          *
-         * <p> Changing the white balance mode with {@link #setWhiteBalance}
-         * will release the auto-white balance lock if it is set.</p>
+         * Get preview FPS
          *
-         * <p>Exposure compensation, AE lock, and AWB lock can be used to
-         * capture an exposure-bracketed burst of images, for example.
-         * Auto-white balance state, including the lock state, will not be
-         * maintained after camera {@link #release()} is called.  Locking
-         * auto-white balance after {@link #open()} but before the first call to
-         * {@link #startPreview()} will not allow the auto-white balance routine
-         * to run at all, and may result in severely incorrect color in captured
-         * images.</p>
+         */
+        public int getEngPreviewFPS() {
+            return getInt(KEY_ENG_PREVIEW_FPS, 0);
+        }
+
+        /**
+         * @hide
          *
-         * @param toggle new state of the auto-white balance lock. True means
-         *        that auto-white balance is locked, false means that the
-         *        auto-white balance routine is free to run normally.
+         * Get flash duty maximum value
          *
-         * @see #getAutoWhiteBalanceLock()
-         * @see #setWhiteBalance(String)
          */
-        public void setAutoWhiteBalanceLock(boolean toggle) {
-            set(KEY_AUTO_WHITEBALANCE_LOCK, toggle ? TRUE : FALSE);
+        public String getEngEngMSG() {
+            return get(KEY_ENG_MSG);
         }
 
         /**
-         * Gets the state of the auto-white balance lock. Applications should
-         * check {@link #isAutoWhiteBalanceLockSupported} before using this
-         * method. See {@link #setAutoWhiteBalanceLock} for details about the
-         * lock.
-         *
-         * @return State of the auto-white balance lock. Returns true if
-         *         auto-white balance is currently locked, and false
-         *         otherwise.
+         * @hide
          *
-         * @see #setAutoWhiteBalanceLock(boolean)
+         * Set frame interval in focus full scan in engineer mode
+         */
+        public void setEngFocusFullScanFrameInterval(int n) {
+            set(KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL, n);
+        }
+
+        /**
+         * @hide
          *
+         * Get max frame interval in focus full scan in engineer mode
          */
-        public boolean getAutoWhiteBalanceLock() {
-            String str = get(KEY_AUTO_WHITEBALANCE_LOCK);
-            return TRUE.equals(str);
+        public int getEngFocusFullScanFrameIntervalMax() {
+            return getInt(KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX, 0);
         }
 
         /**
-         * Returns true if auto-white balance locking is supported. Applications
-         * should call this before trying to lock auto-white balance. See
-         * {@link #setAutoWhiteBalanceLock} for details about the lock.
+         * @hide
          *
-         * @return true if auto-white balance lock is supported.
-         * @see #setAutoWhiteBalanceLock(boolean)
+         * Get min frame interval in focus full scan in engineer mode
+         */
+        public int getEngFocusFullScanFrameIntervalMin() {
+            return getInt(KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN, 0);
+        }
+
+        /**
+         * @hide
          *
+         * Get preview frame interval in us in engineer mode
          */
-        public boolean isAutoWhiteBalanceLockSupported() {
-            String str = get(KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED);
-            return TRUE.equals(str);
+        public int getEngPreviewFrameIntervalInUS() {
+            return getInt(KEY_ENG_PREVIEW_FRAME_INTERVAL_IN_US, 0);
         }
 
         /**
-         * Gets current zoom value. This also works when smooth zoom is in
-         * progress. Applications should check {@link #isZoomSupported} before
-         * using this method.
+         * @hide
          *
-         * @return the current zoom value. The range is 0 to {@link
-         *         #getMaxZoom}. 0 means the camera is not zoomed.
+         * Set parameter 1 in engineer mode
          */
-        public int getZoom() {
-            return getInt(KEY_ZOOM, 0);
+        public void setEngParameter1(String value) {
+            set(KEY_ENG_PARAMETER1, value);
         }
 
         /**
-         * Sets current zoom value. If the camera is zoomed (value > 0), the
-         * actual picture size may be smaller than picture size setting.
-         * Applications can check the actual picture size after picture is
-         * returned from {@link PictureCallback}. The preview size remains the
-         * same in zoom. Applications should check {@link #isZoomSupported}
-         * before using this method.
+         * @hide
          *
-         * @param value zoom value. The valid range is 0 to {@link #getMaxZoom}.
+         * Set parameter 2 in engineer mode
          */
-        public void setZoom(int value) {
-            set(KEY_ZOOM, value);
+        public void setEngParameter2(String value) {
+            set(KEY_ENG_PARAMETER2, value);
         }
 
         /**
-         * Returns true if zoom is supported. Applications should call this
-         * before using other zoom methods.
+         * @hide
          *
-         * @return true if zoom is supported.
+         * Set parameter 3 in engineer mode
          */
-        public boolean isZoomSupported() {
-            String str = get(KEY_ZOOM_SUPPORTED);
-            return TRUE.equals(str);
+        public void setEngParameter3(String value) {
+            set(KEY_ENG_PARAMETER3, value);
         }
 
         /**
-         * Gets the maximum zoom value allowed for snapshot. This is the maximum
-         * value that applications can set to {@link #setZoom(int)}.
-         * Applications should call {@link #isZoomSupported} before using this
-         * method. This value may change in different preview size. Applications
-         * should call this again after setting preview size.
+         * @hide
          *
-         * @return the maximum zoom value supported by the camera.
+         * Save shading table or not in engineer mode
          */
-        public int getMaxZoom() {
-            return getInt(KEY_MAX_ZOOM, 0);
+        public void setEngSaveShadingTable(int save) {
+            set(KEY_ENG_SAVE_SHADING_TABLE, save);
         }
 
         /**
-         * Gets the zoom ratios of all zoom values. Applications should check
-         * {@link #isZoomSupported} before using this method.
+         * @hide
          *
-         * @return the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
-         *         returned as 320. The number of elements is {@link
-         *         #getMaxZoom} + 1. The list is sorted from small to large. The
-         *         first element is always 100. The last element is the zoom
-         *         ratio of the maximum zoom value.
+         * Specify shading table in engineer mode
          */
-        public List<Integer> getZoomRatios() {
-            return splitInt(get(KEY_ZOOM_RATIOS));
+        public void setEngShadingTable(int shading_table) {
+            set(KEY_ENG_SHADING_TABLE, shading_table);
+        }
+
+         /**
+         * @hide
+         *
+         * Get in engineer mode
+         */
+        public int getEngEVCalOffset() {
+            return getInt(KEY_ENG_EV_CALBRATION_OFFSET_VALUE, 0);
         }
 
         /**
-         * Returns true if smooth zoom is supported. Applications should call
-         * this before using other smooth zoom methods.
+         * @hide
          *
-         * @return true if smooth zoom is supported.
+         * Sets the MATV preview delay time (ms)
          */
-        public boolean isSmoothZoomSupported() {
-            String str = get(KEY_SMOOTH_ZOOM_SUPPORTED);
-            return TRUE.equals(str);
+        public void setMATVDelay(int ms) {
+            set(KEY_MATV_PREVIEW_DELAY, ms);
+        }
+
+        // Add for Stereo3D Start
+        /**
+         * @hide
+         */
+        public String getStereo3DType() {
+            return get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_STEREO3D_TYPE);
+        }
+        /**
+         * @hide
+         * @param value: stereo3d_mode:true or false
+         */
+        public void setStereo3DMode(boolean enable) {
+            mStereo3DMode = enable;
+        }
+        // Add for Stereo3D End
+        /**
+         * @hide
+         */
+        public void setContinuousSpeedMode(String value) {
+            set(KEY_CONTINUOUS_SPEED_MODE, value);
+        }
+        //!--
+        /**
+         * @hide
+         * @return the ZSD mode
+         * get the ZSD mode
+         */
+        public String getZSDMode() {
+            return get(KEY_ZSD_MODE);
+        }
+        /**
+         * @hide
+         * Sets ZSD mode on/off
+         * @param value "on" or "off"
+         */
+        public void setZSDMode(String value) {
+            set(KEY_ZSD_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported ZSD mode
+         * get all supported ZSD mode
+         */
+        public List<String> getSupportedZSDMode() {
+            String str = get(KEY_ZSD_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
@@ -4313,6 +6583,28 @@ public class Camera {
             return TRUE.equals(str);
         }
 
+        /**
+         * <p>Returns true if pdaf is supported.</p>
+         *
+         * @hide
+         * @return true if pdaf is supported.
+         */
+        public boolean isPdafSupported() {
+            String str = get(KEY_PDAF_SUPPORTED);
+            return TRUE.equals(str);
+        }
+
+    /**
+         * <p>Whether the recording sound can be disabled.</p>
+         *
+         * @hide
+         */
+        public void enableRecordingSound(String value) {
+            if (value.equals("1") || value.equals("0")) {
+                set(KEY_MUTE_RECORDING_SOUND, value);
+            }
+        }
+
         /**
          * <p>Enables and disables video stabilization. Use
          * {@link #isVideoStabilizationSupported} to determine if calling this
@@ -4362,6 +6654,108 @@ public class Camera {
             String str = get(KEY_VIDEO_STABILIZATION_SUPPORTED);
             return TRUE.equals(str);
         }
+    /**
+         * <p>Get pip max frame rate when zsd on.</p>
+         *
+         * @hide
+         */
+        public List<Integer> getPIPFrameRateZSDOn() {
+            String str = get(KEY_MAX_FRAME_RATE_ZSD_ON);
+            return splitInt(str);
+        }
+       /**
+         * <p>Get pip max frame rate when zsd off.</p>
+         *
+         * @hide
+         */
+        public List<Integer> getPIPFrameRateZSDOff() {
+            String str = get(KEY_MAX_FRAME_RATE_ZSD_OFF);
+            return splitInt(str);
+        }
+       /**
+         * Get the dynamic frame rate. return true or false
+         * @hide
+         */
+        public boolean getDynamicFrameRate() {
+            String str = get(KEY_DYNAMIC_FRAME_RATE);
+            return TRUE.equals(str);
+        }
+       /**
+         * set the dynamic frame rate.
+         * @hide
+         */
+        public void setDynamicFrameRate(boolean toggle) {
+            set(KEY_DYNAMIC_FRAME_RATE, toggle ? TRUE : FALSE);
+        }
+        /**
+         * Returns true if dynamic frame rate is supported
+         * @hide
+         */
+        public boolean isDynamicFrameRateSupported() {
+            String str = get(KEY_DYNAMIC_FRAME_RATE_SUPPORTED);
+            return TRUE.equals(str);
+        }
+       /**
+         * <p>set image reforcus jps's fine name.</p>
+         *
+         * @hide
+         */
+        public void setRefocusJpsFileName(String fineName) {
+            set(KEY_REFOCUS_JPS_FILE_NAME, fineName);
+        }
+
+        /**
+         * set image reforcus switch.</p>
+         *
+         * @hide
+         */
+        public void setRefocusMode(boolean toggle) {
+            set(KEY_STEREO_REFOCUS_MODE, toggle ? ON : OFF);
+        }
+
+        /**
+         * get image reforcus switch.</p>
+         *
+         * @hide
+         */
+        public String getRefocusMode() {
+            return get(KEY_STEREO_REFOCUS_MODE);
+        }
+
+        /**
+         * set Depth AF switch.</p>
+         *
+         * @hide
+         */
+        public void setDepthAFMode(boolean toggle) {
+            set(KEY_STEREO_DEPTHAF_MODE, toggle ? ON : OFF);
+        }
+        /**
+         * get Depth AF switch.</p>
+         *@hide
+         *
+         */
+        public String getDepthAFMode() {
+            return get(KEY_STEREO_DEPTHAF_MODE);
+        }
+
+        /**
+         * set Distance Info.</p>
+         *@hide
+         *
+         */
+        public void setDistanceMode(boolean toggle) {
+            set(KEY_STEREO_DISTANCE_MODE, toggle ? ON : OFF);
+        }
+
+        /**
+         * get Distance Info.</p>
+         *@hide
+         * @hide
+         */
+        public String getDistanceMode() {
+            return get(KEY_STEREO_DISTANCE_MODE);
+        }
 
         // Splits a comma delimited string to an ArrayList of String.
         // Return null if the passing string is null or the size is 0.
diff --git a/core/java/com/mediatek/common/mom/BootReceiverPolicy.java b/core/java/com/mediatek/common/mom/BootReceiverPolicy.java
new file mode 100755
index 0000000..b9a6d41
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/BootReceiverPolicy.java
@@ -0,0 +1,67 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.content.Intent;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/** @hide */
+public final class BootReceiverPolicy {
+    private static List<String> mBootIntentFilter = new ArrayList<String>();
+
+    /**
+     * Customized boot related intent here. MoMS will monitors
+     * applications which receives these intents.
+     */
+    static  {
+        // Must handle this intent, don't removed.
+        mBootIntentFilter.add(Intent.ACTION_BOOT_COMPLETED);
+        mBootIntentFilter.add("android.intent.action.ACTION_BOOT_IPO");
+    }
+
+    public static List<String> getBootPolicy() {
+        return mBootIntentFilter;
+    }
+
+    public static boolean match(String intent) {
+        return mBootIntentFilter.contains(intent);
+    }
+}
diff --git a/core/java/com/mediatek/common/mom/ICallInterceptionListener.aidl b/core/java/com/mediatek/common/mom/ICallInterceptionListener.aidl
new file mode 100755
index 0000000..6e223b4
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/ICallInterceptionListener.aidl
@@ -0,0 +1,54 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.os.Bundle;
+
+/** @hide */
+interface ICallInterceptionListener {
+    /**
+    * To check if the incoming call can be accepted or not.
+    *
+    *  @param callInformation Contains phone number(String), call type(integer) and slot id(integer).
+    *  @return   Return true if the call can be accepted, else return false.
+    */
+    boolean onIncomingCallCheck(in Bundle callInformation);
+}
+
+
diff --git a/core/java/com/mediatek/common/mom/IMessageInterceptListener.aidl b/core/java/com/mediatek/common/mom/IMessageInterceptListener.aidl
new file mode 100755
index 0000000..0ad0f5a
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/IMessageInterceptListener.aidl
@@ -0,0 +1,58 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.os.Bundle;
+
+/**
+ * The interface is designed for message interception.
+ * The callback fucntion is set through
+ * registerMessageInterceptListener() in MobileManagerService.
+ * @hide
+ */
+interface IMessageInterceptListener {
+    /**
+     * The callback will be triggered when new message arrived completed.
+     * 
+     * @param packageName The package notifies the monitored notification.
+     * @param notification The information of the nogification.
+     */
+    boolean onNewSMSCheck(in Bundle intent);
+}
+
diff --git a/core/java/com/mediatek/common/mom/IMobileConnectionCallback.aidl b/core/java/com/mediatek/common/mom/IMobileConnectionCallback.aidl
new file mode 100755
index 0000000..2bc4ae3
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/IMobileConnectionCallback.aidl
@@ -0,0 +1,62 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+/**
+ * The interface is designed for handling the case that manager app has been changed.
+ * MobileManagerService only support one management app at the same time, and each
+ * management app are asigned with a prority to decide who can attach successfully.
+ * The callback fucntion is set through attach() in MobileManagerService.
+ * @hide
+ */
+interface IMobileConnectionCallback {
+    /**
+     * The callback will be triggered when the connection between
+     * Manager app and MobileManagerService has been terminated. 
+     */
+    void onConnectionEnded();
+
+    /**
+     * The callback will be triggered when current connection has been terminated,
+     * and each management app had been invoked attach() will have chance to
+     * attach again.
+     */
+    void onConnectionResume();
+}
+
diff --git a/core/java/com/mediatek/common/mom/IMobileManager.java b/core/java/com/mediatek/common/mom/IMobileManager.java
new file mode 100755
index 0000000..58892be
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/IMobileManager.java
@@ -0,0 +1,435 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.content.pm.PackageInfo;
+import android.net.Uri;
+
+import java.util.List;
+
+/**
+  * All of the APIs in IMobileManager will be protected by license checking.
+  * Total 2 protection level for each API:
+  * - License checking:    Only specified authorized certificate in the application will be accepted.
+  * - Attachment checking: Based on LICENSE checking, this kind of APIs can only be accessed
+  *                        after attaching successfully.
+  * Protection level of each APIs can be found in comment with Tag "Protection Level".
+  * @hide
+  */
+public interface IMobileManager {
+
+    // This version name should match the result returned by getVersionName().
+    public static final String VERSION_NAME = "MoMS.5.0.0";
+
+    /**
+     * The status(mode) for for checkPermission API.
+     */
+    /** It's ok to use the permission. */
+    public static final int PERMISSION_STATUS_GRANTED = 0;
+    /** Forbidden to use the permission, be care for the error handling. */
+    public static final int PERMISSION_STATUS_DENIED = 1;
+    /** Ask user to grant the permission or not. */
+    public static final int PERMISSION_STATUS_CHECK = 2;
+    /** init status for error handling. */
+    public static final int PERMISSION_STATUS_NONE = 0;
+
+    /**
+     * The attribute for each permissions.
+     */
+    /** For permissions defined by android. */
+    public static final int PERMISSION_FLAG_NORMAL = 1;
+    /** For permissions defined by MoMS. */
+    public static final int PERMISSION_FLAG_SUB = 1 << 1;
+    /** for permission must checked by user for each time. */
+    public static final int PERMISSION_FLAG_USERCONFIRM = 1 << 2;
+    // For permission can be accessed with system authority.
+    public static final int PERMISSION_FLAG_SYSTEM = 1 << 3;
+    public static final int PERMISSION_FLAG_NONE = 0;
+    public static final int PERMISSION_FLAG_ALL = PERMISSION_FLAG_NORMAL |
+                                                  PERMISSION_FLAG_SUB |
+                                                  PERMISSION_FLAG_USERCONFIRM |
+                                                  PERMISSION_FLAG_SYSTEM;
+
+    /**
+     * The bundle extra definitions
+     */
+    // The bundle extra definition for Notification
+    public static final String OPTION_NOTIFICATION_PKG = "notificationPkg";
+    public static final String OPTION_NOTIFICATION_ID = "notificationID";
+    public static final String OPTION_NOTIFICATION_TITLE = "notificationTitle";
+    public static final String OPTION_NOTIFICATION_CONTENT = "notificationContent";
+
+    //The bundle extra definition for Call Interception
+    public static final String PARAMETER_PHONENUMBER = "phoneNumber";
+    public static final String PARAMETER_CALLTYPE = "callType";
+    public static final String PARAMETER_SLOTID = "slotId";
+
+    // The bundle extra definition for Message Intercept
+    public static final String SMS_MESSAGE_INTENT = "intent";
+    public static final String SMS_MESSAGE_SIMID = "simId";
+    public static final String SMS_MESSAGE_SUBID = "subId";
+    public static final String SMS_MESSAGE_FORMAT = "format";
+    public static final String SMS_MESSAGE_RECIPIENT = "recipient";
+    public static final String SMS_MESSAGE_TEXT = "text";
+    public static final String SMS_MESSAGE_MULTIPARTTEXT = "multiparttext";
+    public static final String SMS_MESSAGE_DATA = "data";
+    public static final String SMS_MESSAGE_MULTIPARTDATA = "multipartdata";
+
+    /**
+     * Broadcast of MoMS
+     * MoMS monitors system events and updates to it's chche, so MoMA gets notify
+     * and is able to query to MoMS after the intent.
+     */
+    /** Event for package status changed. */
+    public static final String ACTION_PACKAGE_CHANGE = "mom.action.PACKAGE_CHANGE";
+    /** Event for user status changed. */
+    public static final String ACTION_USER_CHANGE = "mom.action.USER_CHANGE";
+    /** Event for MoMA status changed. */
+    public static final String ACTION_MGR_CHANGE = "mom.action.MGR_CHANGE";
+
+    /**
+     * Extra Keys for MoMS's Broadcast
+     */
+    /** Extra to indicate specify status for the action. */
+    public static final String ACTION_EXTRA_STATUS = "mom.action.extra.status";
+    /** Extra to indicate effected user id. */
+    public static final String ACTION_EXTRA_USER = "mom.action.extra.user";
+    /** Extra to indicate effected package. */
+    public static final String ACTION_EXTRA_PACKAGE = "mom.action.extra.package";
+    /** Extra to indicate effected packages on external storage. */
+    public static final String ACTION_EXTRA_PACKAGE_LIST = "mom.action.extra.package.list";
+    /** Extra to indicate effected uid. */
+    public static final String ACTION_EXTRA_UID = "mom.action.extra.uid";
+
+    /**
+     * Package Change Status for ACTION_PACKAGE_CHANGE
+     * the data in service will get ready after this intent.
+     */
+    /** Status for a packaged is being installed. */
+    public static final int PACKAGE_ADDED = 0;
+    /** Status for a packaged is being uninstalled. */
+    public static final int PACKAGE_REMOVED = 1;
+    /** Status for a packaged is being updated. */
+    public static final int PACKAGE_UPDATED = 2;
+    /** Status for a packaged is available on external storage. */
+    public static final int PACKAGE_EXT_AVAILABLE = 3;
+    /** Status for a packaged is unavailable on external storage. */
+    public static final int PACKAGE_EXT_UNAVAILABLE = 4;
+
+    // User Status for ACTION_EXTRA_USER
+    /** An user is being added. */
+    public static final int USER_ADDED = 0;
+    /** An existing user is being removed. */
+    public static final int USER_REMOVED = 1;
+    /** Switch to another user. */
+    public static final int USER_SWITCHED = 2;
+
+    // MoMA Status for ACTION_PERM_MGR_CHANGE
+    /** Status for MoMA attachs successfully. */
+    public static final int MGR_ATTACHED = 0;
+    /** Status for MoMA was being detached. */
+    public static final int MGR_DETACHED = 1;
+
+    // Controller ID
+    public static final int CONTROLLER_PERMISSION = 0;
+    public static final int CONTROLLER_PACKAGE = 1;
+    public static final int CONTROLLER_RECEIVER = 2;
+    public static final int CONTROLLER_NOTIFICATION = 3;
+    public static final int CONTROLLER_FIREWALL = 4;
+    public static final int CONTROLLER_MESSAGE_INTERCEPT = 5;
+    public static final int CONTROLLER_CALL = 6;
+    public static final int CONTROLLER_LICENSE = 7;
+    public static final int CONTROLLER_INTERCEPTION = 8;
+
+    // Timeout for triggering a callback
+    public static final int TRIGGER_LISTENER_TIMEOUT = 35 * 1000; // 35 sec
+
+    // =============[Utility Functions]==============
+    /**
+     * Get the version name of MoMS, the value should
+     * match the value of IMobileManager.VERSION_NAME.
+     * Protection Level: License
+     *
+     *
+     * @return Returns version name of MoMS.
+     */
+    public String getVersionName();
+
+    /**
+     * Clear all settings to MoMS except permission controller.
+     * Protection Level: License
+     *
+     *
+     */
+    public void clearAllSettings();
+
+    /**
+     * Clear settings to MoMS for a specified package
+     * except Permission Controller.
+     * Protection Level: License
+     *
+     *
+     * @param packageName The package to be cleared.
+     */
+    public void clearPackageSettings(String packageName);
+
+
+    // =============[Permission Controller Functions]==============
+    /**
+     * For each app wants to use the APIs in permission controller must
+     * attach to MoMS at first, otherwise, SecurityException will be thrown.
+     * Protection Level: License
+     *
+     *
+     * @param callback The callback functions handle the connection events.
+     *                 Please reference to IMobileConnectionCallback.aidl.
+     * @return         Returns true when attached successfully.
+     */
+    public boolean attach(IMobileConnectionCallback callback);
+
+    /**
+     * Invoke this function if there is no need to use APIs in permission controller.
+     * Protection Level: Attachment
+     *
+     */
+    public void detach();
+
+    /**
+     * Register a listener to monitor permission checking.
+     * Protection Level: Attachment
+     *
+     *
+     * @param listener The callback function will be triggered during checking.
+     */
+    public void registerPermissionListener(IPermissionListener listener);
+
+    /**
+     * To enable/disable the permission controller.
+     * Protection Level: Attachment
+     *
+     *
+     * @param enable To enable it or not.
+     */
+    public void enablePermissionController(boolean enable);
+
+    /**
+     * To get all the packages installed except "system" applications.
+     * Protection Level: License
+     *
+     *
+     * @return Returns a list of PackageInfo.
+     */
+    public List<PackageInfo> getInstalledPackages();
+
+    /**
+     * To get all "granted" permissions of a given package.
+     * Protection Level: License
+     *
+     *
+     * @param packageName The name of the package to be checked.
+     * @return            Returns a list of PackageInfo.
+     */
+    public List<Permission> getPackageGrantedPermissions(String packageName);
+
+    /**
+     * Set the status to the permission with a given record.
+     * Protection Level: Attachment
+     *
+     *
+     * @param record The setting data, please refers to PermissionRecord.java.
+     */
+    public void setPermissionRecord(PermissionRecord record);
+
+    /**
+     * Set the status to the permissions with a list of given records.
+     * Protection Level: Attachment
+     *
+     *
+     * @param record The setting list.
+     */
+    public void setPermissionRecords(List<PermissionRecord> records);
+
+    /**
+     * Set the status to the permissions with a list of given records
+     * with reseting all data to GRANTED at first.
+     * Protection Level: Attachment
+     *
+     *
+     * @param cache The setting list.
+     */
+    public void setPermissionCache(List<PermissionRecord> cache);
+
+    /**
+     * [Receiver Controller Functions]
+     * Protection Level: License
+     */
+    /**
+     * Set the enabled setting for a package to receive BOOT_COMPLETED
+     * Protection Level: License
+     *
+     *
+     * @param packageName The package to enable
+     * @param enable The new enabled state for the package.
+     */
+    public void setBootReceiverEnabledSetting(String packageName, boolean enable);
+    /** batch version. */
+    public void setBootReceiverEnabledSettings(List<ReceiverRecord> list);
+
+    /** Get packages that receiver BOOT_COMPLETED. */
+    public List<ReceiverRecord> getBootReceiverList();
+
+    /**
+     * Return the the enabled setting for a package that receives BOOT_COMPLETED
+     * Protection Level: License
+     *
+     *
+     * @param packageName The package to retrieve.
+     * @return enable Returns the current enabled state for the package.
+     */
+    public boolean getBootReceiverEnabledSetting(String packageName);
+
+    /**
+     * [Package Controller Functions]
+     * Protection Level: License
+     */
+    /**
+     * Forcestop the specified package.
+     * Protection Level: License
+     *
+     *
+     * @param packageName The name of the package to be forcestoped.
+     */
+    public void forceStopPackage(String packageName);
+
+    /**
+     * Install a package. Since this may take a little while, the result will
+     * be posted back to the given callback.
+     * Protection Level: License
+     *
+     *
+     * @param packageURI The location of the package file to install.  This can be a 'file:' or a 'content:' URI.
+     * @param callback An callback to get notified when the package installation is complete.
+     */
+    public void installPackage(Uri packageURI, IPackageInstallCallback callback);
+
+    /**
+     * Attempts to delete a package.  Since this may take a little while, the result will
+     * be posted back to the given callback.
+     * Protection Level: License
+     *
+     *
+     * @param packageName The name of the package to delete
+     */
+    public void deletePackage(String packageName);
+
+    // =============[Notification Controller Functions]==============
+    /**
+     * Clear notifications for a specified package.
+     * Protection Level: License
+     *
+     *
+     * @param packageName The name of the package to be cleared.
+     */
+    public void cancelNotification(String packageName);
+
+    /**
+     * To enable/disable the notification for a specified package.
+     * Protection Level: License
+     *
+     *
+     * @param packageName The name of the package to be set.
+     * @param enable To enable it or not.
+     */
+    public void setNotificationEnabledSetting(String packageName, boolean enable);
+
+    /**
+     * Get the notification enabled status for a specified package.
+     * Protection Level: License
+     *
+     *
+     * @param packageName The package to be cleared.
+     * @return         Return true when notification is enabled, otherwise false.
+     */
+    public boolean getNotificationEnabledSetting(String packageName);
+
+    /**
+     * Register a listener to monitor notification checking.
+     * Protection Level: License
+     *
+     *
+     * @param listener The callback function will be triggered during checking.
+     */
+    public void registerNotificationListener(INotificationListener listener);
+
+    /**
+     * Set the notification enable/disable cache status with a list of given records.
+     * Protection Level: License
+     *
+     *
+     * @param cache The setting list.
+     */
+    public void setNotificationCache(List<NotificationCacheRecord> cache);
+
+    /**
+     * [Interception Controller Functions]
+     *
+     */
+    public void enableInterceptionController(boolean enable);
+
+    public void registerCallInterceptionListener(ICallInterceptionListener listener);
+
+
+
+    /**
+     * Sets the firewall rule for application over mobile or Wi-Fi data connection.
+     * Protection Level: License
+     *
+     *
+     * @param appUid Specify one application by UID
+     * @param networkType Specify over mobile or Wi-Fi data connection
+     * @param enable Enable or disable firewall rule to restrict application data usage
+     */
+    public void setFirewallPolicy(int appUid, int networkType, boolean enable);
+
+    /**
+     * [Message Intercept Controller Functions]
+     *
+     */
+    public void registerMessageInterceptListener(IMessageInterceptListener listener);
+}
diff --git a/core/java/com/mediatek/common/mom/IMobileManagerService.aidl b/core/java/com/mediatek/common/mom/IMobileManagerService.aidl
new file mode 100755
index 0000000..dac8087
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/IMobileManagerService.aidl
@@ -0,0 +1,190 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/**
+ * aidl file : src/com/mediatek/common/mom/IMobileManagerService.aidl
+ * This file contains definitions of functions which are exposed by service
+ */
+package com.mediatek.common.mom;
+
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.IBinder;
+
+import com.mediatek.common.mom.IPermissionListener;
+import com.mediatek.common.mom.IRequestedPermissionCallback;
+import com.mediatek.common.mom.IPackageInstallCallback;
+import com.mediatek.common.mom.INotificationListener;
+import com.mediatek.common.mom.IMobileConnectionCallback;
+import com.mediatek.common.mom.NotificationCacheRecord;
+import com.mediatek.common.mom.Permission;
+import com.mediatek.common.mom.PermissionRecord;
+import com.mediatek.common.mom.ReceiverRecord;
+
+/** @hide */
+interface IMobileManagerService {
+    void systemReady();
+
+    /**
+     * Get the version of MobileManagerService
+     *
+     * @return Returns version name of MobileManagerService.
+     *
+     */
+    String getVersionName();
+
+    /**
+     * Attach to MobileManagerService
+     *
+     * @param callback The callback will be triggered when the connection terminated or resumed.
+     * @return Returns the result of attachment.
+     */
+    boolean attach(in IMobileConnectionCallback callback);
+
+    /**
+     * Detach from MobileManagerService
+     *
+     */
+    void detach();
+
+    /**
+     * Clear all settings
+     *
+     */
+    void clearAllSettings();
+
+    /**
+     * Clear setting for package
+     *
+     * @param packageName The specific package that setting will be erased.
+     */
+    void clearPackageSettings(String packageName);
+
+    void registerManagerApListener(int controllerID, in IBinder listener);
+    int triggerManagerApListener(int ControllerID, in Bundle params, int defaultResult);
+    void triggerManagerApListenerAsync(int ControllerID, in Bundle params, int defaultResult, in IBinder callback);
+
+    /**
+     * [Permission Controller Functions]
+     */
+    void enablePermissionController(boolean enable);
+    List<PackageInfo> getInstalledPackages();
+    List<Permission> getPackageGrantedPermissions(String packageName);
+    void setPermissionRecord(in PermissionRecord record);
+    void setPermissionRecords(in List<PermissionRecord> records);
+    void setPermissionCache(in List<PermissionRecord> cache);
+    int checkPermission(String permissionName, int uid);
+    void checkPermissionAsync(String permissionName, int uid, in IRequestedPermissionCallback callback);
+    int checkPermissionWithData(String permissionName, int uid, in Bundle data);
+    void checkPermissionAsyncWithData(String permissionName, int uid, in Bundle data, in IRequestedPermissionCallback callback);
+    String getParentPermission(String subPermissionName);
+    long getUserConfirmTime(int userId, long timeBound);
+
+
+    /**
+     * [Receiver Controller Functions]
+     */
+    List<ReceiverRecord> getBootReceiverList();
+    void setBootReceiverEnabledSettings(in List<ReceiverRecord> list);
+    void setBootReceiverEnabledSetting(String packageName, boolean enable);
+    boolean getBootReceiverEnabledSetting(String packageName);
+    void filterReceiver(in Intent intent, inout List<ResolveInfo> resolveList, int userId);
+    void startMonitorBootReceiver(String cause);
+    void stopMonitorBootReceiver(String cause);
+
+    /**
+     * [Package Controller Functions]
+     */
+    /**
+     * Forcestop the specified package.
+     * Protection Level: License
+     *
+     * @param packageName The name of the package to be forcestoped.
+     */
+    void forceStopPackage(String packageName);
+
+    /**
+     * Install a package. Since this may take a little while, the result will
+     * be posted back to the given callback.
+     * Protection Level: License
+     *
+     * @param packageURI The location of the package file to install.  This can be a 'file:' or a 'content:' URI.
+     * @param callback An callback to get notified when the package installation is complete.
+     */
+    void installPackage(in Uri packageURI, in IPackageInstallCallback callback);
+
+    /**
+     * Attempts to delete a package.  Since this may take a little while, the result will
+     * be posted back to the given callback.
+     * Protection Level: License
+     *
+     * @param packageName The name of the package to delete
+     */
+    void deletePackage(String packageName);
+
+    /**
+     * [Notification Controller Functions]
+     */
+    void cancelNotification(String packageName);
+    void setNotificationEnabledSetting(String packageName, boolean enable);
+    boolean getNotificationEnabledSetting(String packageName);
+    void setNotificationCache(in List<NotificationCacheRecord> cache);
+
+    /**
+     * [Interception Controller Functions]
+     */
+    void enableInterceptionController(boolean enable);
+    boolean getInterceptionEnabledSetting();
+
+    /**
+     * Sets the firewall rule for application over mobile or Wi-Fi data connection.
+     *
+     * @param appUid The user id of application
+     * @param networkType Specify over mobile or Wi-Fi data connection
+     * @param enable Enable or disable firewall rule to restrict application data usage
+     */
+    void setFirewallPolicy(int appUid, int networkType, boolean enable);
+
+    /**
+     * [Radio Controller Functions]
+     */
+
+}
+
diff --git a/core/java/com/mediatek/common/mom/INotificationListener.aidl b/core/java/com/mediatek/common/mom/INotificationListener.aidl
new file mode 100755
index 0000000..fb1c507
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/INotificationListener.aidl
@@ -0,0 +1,58 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.os.Bundle;
+
+/**
+ * The interface is designed for notification interception.
+ * The callback fucntion is set through
+ * registerNotificationListener() in MobileManagerService.
+ * @hide
+ */
+interface INotificationListener {
+    /**
+     * The callback will be triggered when notification blocking has done.
+     * 
+     * @param packageName The package invokes the API.
+     * @param notification The information of the notification.
+     */
+    void onNotificationBlocked(String packageName, in Bundle notification);
+}
+
diff --git a/core/java/com/mediatek/common/mom/IPackageInstallCallback.aidl b/core/java/com/mediatek/common/mom/IPackageInstallCallback.aidl
new file mode 100755
index 0000000..c7f8514
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/IPackageInstallCallback.aidl
@@ -0,0 +1,55 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+/**
+ * Callbacks for package installation from MobileManagerService.
+ * @hide
+ */
+oneway interface IPackageInstallCallback {
+    /**
+     * The callback will be triggered when package installed.
+     *
+     * @param packageName The installed package name.
+     * @param returnCode Installation return code: this is passed to the {@link IPackageInstallCallback} by
+     *                   {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}.
+     *
+     */
+    void onPackageInstalled(in String packageName, int returnCode);
+}
diff --git a/core/java/com/mediatek/common/mom/IPermissionListener.aidl b/core/java/com/mediatek/common/mom/IPermissionListener.aidl
new file mode 100755
index 0000000..1d123c9
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/IPermissionListener.aidl
@@ -0,0 +1,82 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.os.Bundle;
+
+import com.mediatek.common.mom.PermissionRecord;
+
+/**
+ * The interface is designed for listening permission related events,
+ * and can register callback function through
+ * registerPermissionListener(IPermissionListener listener) in MobileManagerService.
+ * @hide
+ */
+interface IPermissionListener {
+    /**
+     * The callback will be triggered when monitored API is invoked.
+     * 
+     * @param record The permission record for this checking.
+     *               mPackageName: The package invokes the API.
+     *               mPermissionName: The permission binding to the API.
+     *               mStatus: The status of permission when checking.
+     *                        MobileManager.PERMISSION_STATUS_CHECK: The checking requires user's confirmation.
+     *                        MobileManager.PERMISSION_STATUS_DENIED: The API is revoked for this package.
+     *                        MobileManager.PERMISSION_STATUS_GRANTED won't trigger this function.
+     * @param flag The attributes of the permission.
+     *             MobileManager.PERMISSION_FLAG_USERCONFIRM: This permission always requires user's confirmation.
+     * 
+     * @param uid The user id of the package.
+     * @param data The addition information for checking
+     * @return Returns true when user allows this operation,
+     *         otherwise, false should be returned.
+     */
+    boolean onPermissionCheck(in PermissionRecord record, int flag, int uid, in Bundle data);
+    
+    /**
+     * The callback will be triggered when a permission had been revoked/granted
+     * to a package. This will be triggered only by "system" authority user.
+     * 
+     * @param record The permission record for this checking.
+     *               mPackageName: The package invokes the API.
+     *               mPermissionName: The permission binding to the API.
+     */
+    void onPermissionChange(in PermissionRecord record);
+}
+
diff --git a/core/java/com/mediatek/common/mom/IRequestedPermissionCallback.aidl b/core/java/com/mediatek/common/mom/IRequestedPermissionCallback.aidl
new file mode 100755
index 0000000..2334e1c
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/IRequestedPermissionCallback.aidl
@@ -0,0 +1,59 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+/**
+ * The interface is designed for listening permission related events,
+ * and can register callback function through
+ * registerPermissionCallback(IPermissionCallback callback) in MobileManagerService.
+ * @hide
+ */
+interface IRequestedPermissionCallback {
+    /**
+     * The callback will be triggered when permission checking has done.
+     * Set the callback
+     * 
+     * @param permissionName The permission binding to the API.
+     * @param uid The user id of the package while checking.
+     * @param result Returns MobileManager.PERMISSION_GRANTED when user allows this operation,
+     *               otherwise, MobileManager.PERMISSION_DENIED should be returned.
+     */
+    void onPermissionCheckResult(String permissionName, int uid, int result);
+}
+
diff --git a/core/java/com/mediatek/common/mom/MobileManager.java b/core/java/com/mediatek/common/mom/MobileManager.java
new file mode 100755
index 0000000..fe07c80
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/MobileManager.java
@@ -0,0 +1,351 @@
+package com.mediatek.common.mom;
+
+import java.util.List;
+
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.net.Uri;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Log;
+
+/**
+ * This manager provides an interface for application to operate with MobileManagerService.
+ */
+public class MobileManager implements IMobileManager {
+    private static final String TAG = "MobileManager";
+    private Context mContext;
+    private IMobileManagerService mService;
+    MobileManager mInstance = null;
+
+    private MobileManager() {};
+
+    private boolean checkLicense(String packageName) {
+        return true;
+    }
+
+    public MobileManager(Context context, IMobileManagerService service) {
+        super();
+        mContext = context;
+        mService = service;
+        if (mService == null) {
+            throw new RuntimeException("null MobileManagerService!");
+        }
+    }
+
+    /**
+     * [Utility Functions]
+     */
+    public String getVersionName() {
+        try {
+            return mService.getVersionName();
+        } catch (RemoteException e) {
+            Log.e(TAG, "getVersionName() failed: ", e);
+            return null;
+        }
+    }
+
+    public boolean attach(IMobileConnectionCallback callback) {
+        try {
+            return mService.attach(callback);
+        } catch (RemoteException e) {
+            Log.e(TAG, "attach() failed: ", e);
+            return false;
+        }
+    }
+
+    public void detach() {
+        try {
+            mService.detach();
+        } catch (RemoteException e) {
+            Log.e(TAG, "detach() failed: ", e);
+        }
+    }
+
+    public void clearAllSettings() {
+        try {
+            mService.clearAllSettings();
+        } catch (RemoteException e) {
+            Log.e(TAG, "clearAllSettings() failed: ", e);
+        }
+    }
+
+    public void clearPackageSettings(String packageName) {
+        try {
+            mService.clearPackageSettings(packageName);
+        } catch (RemoteException e) {
+            Log.e(TAG, "clearPackageSettings() " + packageName + " failed: ", e);
+        }
+    }
+
+    /**
+     * [Permission Controller Functions]
+     */
+    public void enablePermissionController(boolean enable) {
+        try {
+            mService.enablePermissionController(enable);
+        } catch (RemoteException e) {
+            Log.e(TAG, "enablePermissionController() " + enable + " failed: ", e);
+        }
+    }
+
+    public List<PackageInfo> getInstalledPackages() {
+        try {
+            return mService.getInstalledPackages();
+        } catch (RemoteException e) {
+            Log.e(TAG, "getInstalledPackages() failed: ", e);
+            return null;
+        }
+    }
+
+    public List<Permission> getPackageGrantedPermissions(String packageName) {
+        try {
+            return mService.getPackageGrantedPermissions(packageName);
+        } catch (RemoteException e) {
+            Log.e(TAG, "getPackageGrantedPermissions() " +
+                  packageName + " failed: ", e);
+            return null;
+        }
+    }
+
+    public void registerPermissionListener(IPermissionListener listener) {
+        try {
+            mService.registerManagerApListener(IMobileManager.CONTROLLER_PERMISSION, (IBinder) listener);
+        } catch (RemoteException e) {
+            Log.e(TAG, "registerPermissionListener() " + listener + " failed: ", e);
+        }
+    }
+
+    public void setPermissionRecord(PermissionRecord record) {
+        try {
+            mService.setPermissionRecord(record);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setPermissionRecord() " + record.toString() + " failed: ", e);
+        }
+    }
+
+    public void setPermissionRecords(List<PermissionRecord> records) {
+        try {
+            mService.setPermissionRecords(records);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setPermissionRecord() " + records + " failed: ", e);
+        }
+    }
+
+    public void setPermissionCache(List<PermissionRecord> cache) {
+        try {
+            mService.setPermissionCache(cache);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setPermissionCache() " + cache + " failed: ", e);
+        }
+    }
+
+    /**
+     * [Receiver Controller Functions]
+     */
+    /**
+     * Set the enabled setting for a package to receive BOOT_COMPLETED
+     * Protection Level: License
+     *
+     * @param packageName The package to enable
+     * @param enable The new enabled state for the package.
+     */
+    public void setBootReceiverEnabledSetting(String packageName, boolean enable) {
+        try {
+            mService.setBootReceiverEnabledSetting(packageName, enable);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setBootReceiverEnabledSetting() " +
+                  packageName + " enable: " + enable + " failed: ", e);
+        }
+    }
+
+    /**
+     * Return the the enabled setting for a package that receives BOOT_COMPLETED
+     * Protection Level: License
+     *
+     * @param packageName The package to retrieve.
+     * @return enable Returns the current enabled state for the package.
+     */
+    public boolean getBootReceiverEnabledSetting(String packageName) {
+        try {
+            return mService.getBootReceiverEnabledSetting(packageName);
+        } catch (RemoteException e) {
+            Log.e(TAG, "getBootReceiverEnabledSetting() " + packageName + " failed: ", e);
+            return false;
+        }
+    }
+
+    public void setBootReceiverEnabledSettings(List<ReceiverRecord> list) {
+        try {
+            mService.setBootReceiverEnabledSettings(list);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setBootReceiverEnabledSettings()", e);
+        }
+    }
+
+    public List<ReceiverRecord> getBootReceiverList() {
+        try {
+            return mService.getBootReceiverList();
+        } catch (RemoteException e) {
+            Log.e(TAG, "getBootReceiverList()", e);
+        }
+        return null;
+    }
+
+    /**
+     * [Package Controller Functions]
+     */
+    /**
+     * Forcestop the specified package.
+     * Protection Level: License
+     *
+     * @param packageName The name of the package to be forcestoped.
+     */
+    public void forceStopPackage(String packageName) {
+        try {
+            mService.forceStopPackage(packageName);
+        } catch (RemoteException e) {
+            Log.e(TAG, "forceStopPackage() " + packageName + " failed: ", e);
+        }
+    }
+
+    /**
+     * Install a package. Since this may take a little while, the result will
+     * be posted back to the given callback.
+     * Protection Level: License
+     *
+     * @param packageURI The location of the package file to install.  This can be a 'file:' or a 'content:' URI.
+     * @param callback An callback to get notified when the package installation is complete.
+     */
+    public void installPackage(Uri packageURI, IPackageInstallCallback callback) {
+        try {
+            mService.installPackage(packageURI, callback);
+        } catch (RemoteException e) {
+            Log.e(TAG, "installPackage() " + packageURI + " failed: ", e);
+        }
+    }
+
+    /**
+     * Attempts to delete a package.  Since this may take a little while, the result will
+     * be posted back to the given callback.
+     * Protection Level: License
+     *
+     * @param packageName The name of the package to delete
+     */
+    public void deletePackage(String packageName) {
+        try {
+            mService.deletePackage(packageName);
+        } catch (RemoteException e) {
+            Log.e(TAG, "deletePackage() " + packageName + " failed: ", e);
+        }
+    }
+
+    /**
+     * [Notification Controller Functions]
+     */
+    public void cancelNotification(String packageName) {
+        try {
+            mService.cancelNotification(packageName);
+        } catch (RemoteException e) {
+            Log.e(TAG, "cancelNotification() " + packageName + " failed: ", e);
+        }
+    }
+
+    public void setNotificationEnabledSetting(String packageName, boolean enable) {
+        try {
+            mService.setNotificationEnabledSetting(packageName, enable);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setNotificationEnabledSetting() " +
+                  packageName + " enable: " + enable + " failed: ", e);
+        }
+    }
+
+    public boolean getNotificationEnabledSetting(String packageName) {
+        try {
+            return mService.getNotificationEnabledSetting(packageName);
+        } catch (RemoteException e) {
+            Log.e(TAG, "getNotificationEnabledSetting() " + packageName + " failed: ", e);
+            return false;
+        }
+    }
+
+    public void registerNotificationListener(INotificationListener listener) {
+        try {
+            mService.registerManagerApListener(IMobileManager.CONTROLLER_NOTIFICATION, (IBinder) listener);
+        } catch (RemoteException e) {
+            Log.e(TAG, "registerNotificationListener() " + listener + " failed: ", e);
+        }
+    }
+
+    public void setNotificationCache(List<NotificationCacheRecord> cache) {
+        try {
+            mService.setNotificationCache(cache);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setNotificationCache()", e);
+        }
+    }
+
+    /**
+     * [Interception Controller Functions]
+     * To enable or disable interception controller function.
+     *
+     * @param enable true to enable and false to disable.
+     *
+     */
+    public void enableInterceptionController(boolean enable) {
+        try {
+            mService.enableInterceptionController(enable);
+        } catch (RemoteException e) {
+            Log.e(TAG, "enableInterceptionController() " + enable + " failed: ", e);
+        }
+    }
+
+    /**
+     * To register call interception controller listener(call back function).
+     *
+     * @param listener interface(call back function) to handle incoming call.
+     *
+     */
+    public void registerCallInterceptionListener(ICallInterceptionListener listener) {
+        try {
+            mService.registerManagerApListener(IMobileManager.CONTROLLER_CALL, (IBinder) listener);
+            /* Interception controller contains Call and Message controllers, so need to retister
+               common interception listener */
+            mService.registerManagerApListener(IMobileManager.CONTROLLER_INTERCEPTION, (IBinder) listener);
+        } catch (RemoteException e) {
+            Log.e(TAG, "registerCallInterceptionListener() " + listener + " failed: ", e);
+        }
+    }
+
+
+    /**
+     * [Firewall Controller Functions]
+     */
+    public void setFirewallPolicy(int appUid, int networkType, boolean enable) {
+        try {
+            mService.setFirewallPolicy(appUid, networkType, enable);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setFirewallPolicy() " +
+                  appUid + " networkType: " + networkType +
+                  " enable: " + enable + " failed: ", e);
+        }
+    }
+
+    /**
+     * [Radio Controller Functions]
+     */
+
+
+    /**
+     * [Message Intercept Controller Functions]
+     */
+    public void registerMessageInterceptListener(IMessageInterceptListener listener) {
+        try {
+            mService.registerManagerApListener(IMobileManager.CONTROLLER_MESSAGE_INTERCEPT,
+                (IBinder) listener);
+        } catch (RemoteException e) {
+            Log.e(TAG, "registerMessageInterceptListener() " + listener + " failed: ", e);
+        }
+    }
+
+}
diff --git a/core/java/com/mediatek/common/mom/MobileManagerUtils.java b/core/java/com/mediatek/common/mom/MobileManagerUtils.java
new file mode 100755
index 0000000..465d47c
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/MobileManagerUtils.java
@@ -0,0 +1,157 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.telephony.PhoneNumberUtils;
+import android.util.Log;
+
+/**
+  * Utility for mobile management.
+  * @hide
+  */
+public class MobileManagerUtils {
+    private static final String TAG = "MobileManager";
+    private static final boolean FEATURE_SUPPORTED =
+            SystemProperties.get("ro.mtk_mobile_management").equals("1");
+    private static IMobileManagerService sMomInstance = null;
+
+    /**
+      * To check whether MoMS feature is supported or not.
+      * @return true if supported.
+      *
+      */
+    public static boolean isSupported() {
+        return FEATURE_SUPPORTED;
+    }
+
+    public static boolean checkPermission(String permissionName, int callingUid) {
+        return checkPermission(permissionName, callingUid, null);
+    }
+
+    public static void checkPermissionAsync(String permissionName, int callingUid, IRequestedPermissionCallback callback) {
+        checkPermissionAsync(permissionName, callingUid, callback, null);
+    }
+
+    public static boolean checkPermission(String permissionName, int callingUid, Bundle data) {
+        if (FEATURE_SUPPORTED) {
+            try {
+                IMobileManagerService mom = getServiceInstance();
+                if (mom.checkPermissionWithData(permissionName, callingUid, data) != PackageManager.PERMISSION_GRANTED) {
+                    return false;
+                }
+            } catch (RemoteException e) {
+                Log.e(TAG, "checkPermission failed!", e);
+            }
+        }
+        return true;
+    }
+
+    public static void checkPermissionAsync(String permissionName, int callingUid, IRequestedPermissionCallback callback, Bundle data) {
+        if (FEATURE_SUPPORTED) {
+            try {
+                IMobileManagerService mom = getServiceInstance();
+                mom.checkPermissionAsyncWithData(permissionName, callingUid, data, callback);
+            } catch (RemoteException e) {
+                Log.e(TAG, "checkPermissionAsync failed!", e);
+            }
+        }
+    }
+
+    public static long getUserConfirmTime(int userId, long anrTime) {
+        long time = 0;
+        if (FEATURE_SUPPORTED) {
+            try {
+                IMobileManagerService mom = getServiceInstance();
+                time = mom.getUserConfirmTime(userId, anrTime);
+            } catch (RemoteException e) {
+                Log.e(TAG, "getUserConfirmTime() failed!", e);
+            }
+        }
+        return time;
+    }
+
+    public static boolean checkIntentPermission(Intent intent, ActivityInfo aInfo, Context context, int callingUid) {
+        if (FEATURE_SUPPORTED) {
+            Bundle data = new Bundle();
+            if (aInfo != null) {
+                String permission = decidePermissionAndData(aInfo.permission, intent, context, data);
+                if (permission != null) {
+                    if (!checkPermission(permission, callingUid, data)) {
+                        return false;
+                    }
+                }
+            }
+        }
+        return true;
+    }
+
+    private static String decidePermissionAndData(String intentPermission, Intent intent, Context context, Bundle data) {
+        String newPermission = null;
+        if ("android.permission.CALL_PHONE".equals(intentPermission)) {
+            newPermission = SubPermissions.MAKE_CALL;
+            if (intent != null) {
+                String phoneNumber = PhoneNumberUtils.getNumberFromIntent(intent, context);
+                data.putString(IMobileManager.PARAMETER_PHONENUMBER, phoneNumber);
+            }
+        }
+        return newPermission;
+    }
+
+    /**
+      * mobile service runs on system server and will never die,
+      * and permission checking may be executed frequently,
+      * so cache the binder instance here for performance.
+      */
+    private static IMobileManagerService getServiceInstance() {
+        if (sMomInstance == null) {
+            IBinder binder = ServiceManager.getService(Context.MOBILE_SERVICE);
+            sMomInstance = (IMobileManagerService) IMobileManagerService.Stub.asInterface(binder);
+        }
+        return sMomInstance;
+    }
+}
diff --git a/core/java/com/mediatek/common/mom/NotificationCacheRecord.aidl b/core/java/com/mediatek/common/mom/NotificationCacheRecord.aidl
new file mode 100755
index 0000000..1c7f1c3
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/NotificationCacheRecord.aidl
@@ -0,0 +1,41 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+parcelable NotificationCacheRecord;
diff --git a/core/java/com/mediatek/common/mom/NotificationCacheRecord.java b/core/java/com/mediatek/common/mom/NotificationCacheRecord.java
new file mode 100755
index 0000000..df94486
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/NotificationCacheRecord.java
@@ -0,0 +1,111 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+
+/** @hide */
+public class NotificationCacheRecord implements Parcelable {
+    private static final String TAG = "NotificationCacheRecord";
+    public String packageName = null;
+    public boolean enable = false;
+
+    public NotificationCacheRecord(String packageName, boolean enable) {
+        this.packageName = packageName;
+        this.enable = enable;
+    }
+
+    private NotificationCacheRecord(Parcel in) {
+        this.packageName = in.readString();
+        this.enable = in.readInt() == 1;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int parcelableFlags) {
+        out.writeString(this.packageName);
+        out.writeInt(this.enable ? 1 : 0);
+    }
+
+    @Override
+    public String toString() {
+        return "NotificationCacheRecord {"
+            + this.packageName + ", " + this.enable + "}";
+    }
+
+    @Override
+    public int hashCode() {
+        return ((packageName == null ? 0 : packageName.hashCode()) + (enable ? 31 : 0));
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        // Return true if the objects are identical.
+        if (this == o) {
+            return true;
+        }
+        // Return false if the other object has the wrong type.
+        if (!(o instanceof NotificationCacheRecord)) {
+            return false;
+        }
+        // Cast to the appropriate type.
+        NotificationCacheRecord record = (NotificationCacheRecord) o;
+        // Check each field.
+        return this.packageName.equals(record.packageName) &&
+                (this.enable == record.enable);
+    }
+
+    public static final Parcelable.Creator<NotificationCacheRecord> CREATOR
+            = new Parcelable.Creator<NotificationCacheRecord>() {
+        public NotificationCacheRecord createFromParcel(Parcel in) {
+            return new NotificationCacheRecord(in);
+        }
+
+        public NotificationCacheRecord[] newArray(int size) {
+            return new NotificationCacheRecord[size];
+        }
+    };
+}
+
diff --git a/core/java/com/mediatek/common/mom/Permission.aidl b/core/java/com/mediatek/common/mom/Permission.aidl
new file mode 100755
index 0000000..46d3332
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/Permission.aidl
@@ -0,0 +1,41 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+parcelable Permission;
diff --git a/core/java/com/mediatek/common/mom/Permission.java b/core/java/com/mediatek/common/mom/Permission.java
new file mode 100755
index 0000000..4d605f8
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/Permission.java
@@ -0,0 +1,179 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/** @hide */
+public class Permission implements Parcelable {
+    private static final String TAG = "Permission";
+    /** The name of the Android permission. */
+    public String mPermissionName = null;
+    /** The MOMS defined permissions belong to Android. */
+    public List<Permission> mSubPermissions = null;
+    private int mStatus = IMobileManager.PERMISSION_STATUS_GRANTED;
+    private int mFlag = IMobileManager.PERMISSION_FLAG_NONE;
+    private int mHashCode = 0;
+    private static final int ODD_PRIME_NUMBER = 13;
+
+    public Permission(String permissionName, List<Permission> subPermissions, int status, int flag) {
+        mPermissionName = permissionName;
+        mSubPermissions = subPermissions;
+        mStatus = status;
+        mFlag = flag;
+        mHashCode = makeHashCode();
+    }
+
+    private Permission(Parcel in) {
+        mPermissionName = in.readString();
+        boolean isPresent = (in.readByte() == 1);
+        if (isPresent == true) {
+            mSubPermissions = new ArrayList<Permission>();
+            in.readTypedList(mSubPermissions, Permission.CREATOR);
+        } else {
+            mSubPermissions = null;
+        }
+        mStatus = in.readInt();
+        mFlag = in.readInt();
+        mHashCode = makeHashCode();
+    }
+
+    private int makeHashCode() {
+        int hashCode = 23;
+        hashCode = (ODD_PRIME_NUMBER * hashCode) + mStatus;
+        hashCode = (ODD_PRIME_NUMBER * hashCode) + mFlag;
+        if (mPermissionName != null) {
+            hashCode = (ODD_PRIME_NUMBER * hashCode) + mPermissionName.hashCode();
+        }
+        if (mSubPermissions != null && mSubPermissions.size() > 0) {
+            for (int i = 0; i < mSubPermissions.size(); i++) {
+                Permission p = mSubPermissions.get(i);
+                if (p != null) {
+                    hashCode = (ODD_PRIME_NUMBER * hashCode) + mPermissionName.hashCode();
+                }
+            }
+        }
+        return hashCode;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int parcelableFlags) {
+        out.writeString(mPermissionName);
+        int isPresent = (mSubPermissions != null) ? 1 : 0;
+        out.writeByte((byte) isPresent);
+        if (isPresent == 1) {
+            out.writeTypedList(mSubPermissions);
+        }
+        out.writeInt(mStatus);
+        out.writeInt(mFlag);
+    }
+
+    @Override
+    public String toString() {
+        return "Permission {"
+            + mPermissionName + ", " + mStatus + ", " + mFlag + "}";
+    }
+
+    @Override
+    public int hashCode() {
+        return mHashCode;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        // Return true if the objects are identical.
+        if (this == o) {
+            return true;
+        }
+        // Return false if the other object has the wrong type.
+        if (!(o instanceof Permission)) {
+            return false;
+        }
+        // Cast to the appropriate type.
+        Permission record = (Permission) o;
+        // Check each field.
+        if (!mPermissionName.equals(record.mPermissionName) ||
+           mStatus != record.mStatus ||
+           mFlag != record.mFlag ||
+           !mSubPermissions.equals(record.mSubPermissions)) {
+            return false;
+        }
+        return true;
+    }
+
+    public static final Parcelable.Creator<Permission> CREATOR
+            = new Parcelable.Creator<Permission>() {
+        public Permission createFromParcel(Parcel in) {
+            return new Permission(in);
+        }
+
+        public Permission[] newArray(int size) {
+            return new Permission[size];
+        }
+    };
+
+    public void setStatus(int status) {
+        if (status == IMobileManager.PERMISSION_STATUS_GRANTED ||
+            status == IMobileManager.PERMISSION_STATUS_DENIED ||
+            status == IMobileManager.PERMISSION_STATUS_CHECK) {
+            mStatus = status;
+        } else {
+            Log.e(TAG, "Invalid permission status: " + status);
+        }
+    }
+
+    public int getStatus() {
+        return mStatus;
+    }
+
+    public int getFlag() {
+        return mFlag;
+    }
+}
+
diff --git a/core/java/com/mediatek/common/mom/PermissionRecord.aidl b/core/java/com/mediatek/common/mom/PermissionRecord.aidl
new file mode 100755
index 0000000..e0555d3
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/PermissionRecord.aidl
@@ -0,0 +1,41 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+parcelable PermissionRecord;
diff --git a/core/java/com/mediatek/common/mom/PermissionRecord.java b/core/java/com/mediatek/common/mom/PermissionRecord.java
new file mode 100755
index 0000000..656d207
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/PermissionRecord.java
@@ -0,0 +1,144 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+/**
+  * The data structure to set permission record.
+  * @hide
+  */
+public class PermissionRecord implements Parcelable {
+    private static final String TAG = "PermissionRecord";
+    /** The name to be updated. */
+    public String mPackageName = null;
+    /** The name of the permission to be updated. */
+    public String mPermissionName = null;
+    private int mStatus = IMobileManager.PERMISSION_STATUS_GRANTED;
+    static final private int PRIM_NUMBER = 17;
+
+    public PermissionRecord(String packageName, String permissionName, int status) {
+        mPackageName = packageName;
+        mPermissionName = permissionName;
+        mStatus = status;
+    }
+
+    private PermissionRecord(Parcel in) {
+        mPackageName = in.readString();
+        mPermissionName = in.readString();
+        mStatus = in.readInt();
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int parcelableFlags) {
+        out.writeString(mPackageName);
+        out.writeString(mPermissionName);
+        out.writeInt(mStatus);
+    }
+
+    @Override
+    public String toString() {
+        return "PermissionRecord {"
+            + mPackageName + ", " + mPermissionName + ", " + mStatus + "}";
+    }
+
+    @Override
+    public int hashCode() {
+        int hashCode = 23;
+        hashCode = (hashCode * PRIM_NUMBER) + mStatus;
+        if (mPackageName != null) {
+            hashCode = (hashCode * PRIM_NUMBER) + mPackageName.hashCode();
+        }
+        if (mPermissionName != null) {
+            hashCode = (hashCode * PRIM_NUMBER) + mPermissionName.hashCode();
+        }
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        // Return true if the objects are identical.
+        if (this == o) {
+            return true;
+        }
+        // Return false if the other object has the wrong type.
+        if (!(o instanceof PermissionRecord)) {
+            return false;
+        }
+        // Cast to the appropriate type.
+        PermissionRecord record = (PermissionRecord) o;
+        // Check each field.
+        return mPackageName.equals(record.mPackageName) &&
+             mPermissionName.equals(record.mPermissionName) &&
+             (mStatus == record.mStatus);
+    }
+
+    public static final Parcelable.Creator<PermissionRecord> CREATOR
+            = new Parcelable.Creator<PermissionRecord>() {
+        public PermissionRecord createFromParcel(Parcel in) {
+            return new PermissionRecord(in);
+        }
+
+        public PermissionRecord[] newArray(int size) {
+            return new PermissionRecord[size];
+        }
+    };
+
+    public void setStatus(int status) {
+        if (status == IMobileManager.PERMISSION_STATUS_GRANTED ||
+            status == IMobileManager.PERMISSION_STATUS_DENIED ||
+            status == IMobileManager.PERMISSION_STATUS_CHECK) {
+            mStatus = status;
+        } else {
+            Log.e(TAG, "Invalid permission status: " + status);
+        }
+    }
+
+    public int getStatus() {
+        return mStatus;
+    }
+}
+
diff --git a/core/java/com/mediatek/common/mom/ReceiverRecord.aidl b/core/java/com/mediatek/common/mom/ReceiverRecord.aidl
new file mode 100755
index 0000000..abd18c0
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/ReceiverRecord.aidl
@@ -0,0 +1,41 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+parcelable ReceiverRecord;
diff --git a/core/java/com/mediatek/common/mom/ReceiverRecord.java b/core/java/com/mediatek/common/mom/ReceiverRecord.java
new file mode 100755
index 0000000..287e23d
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/ReceiverRecord.java
@@ -0,0 +1,121 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/** @hide */
+public class ReceiverRecord implements Parcelable {
+    /** The name to be updated. */
+    public final String packageName;
+    /** Enabled or not. */
+    public boolean enabled = true;
+
+    public ReceiverRecord(String _packageName) {
+        packageName = _packageName;
+        enabled = true;
+    }
+
+    public ReceiverRecord(String _packageName, boolean _enable) {
+        packageName = _packageName;
+        enabled = _enable;
+    }
+
+    public ReceiverRecord(ReceiverRecord data) {
+        packageName = data.packageName;
+        enabled = data.enabled;
+    }
+
+    private ReceiverRecord(Parcel in) {
+        this.packageName = in.readString();
+        this.enabled = in.readInt() == 1;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int parcelableFlags) {
+        out.writeString(this.packageName);
+        out.writeInt(this.enabled ? 1 : 0);
+    }
+
+    @Override
+    public String toString() {
+        return "ReceiverRecord {"
+                + this.packageName + ", " + this.enabled + "}";
+    }
+
+    @Override
+    public int hashCode() {
+        return ((packageName == null ? 0 : packageName.hashCode()) + (enabled ? 31 : 0));
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        // Return true if the objects are identical.
+        if (this == o) {
+            return true;
+        }
+        // Return false if the other object has the wrong type.
+        if (!(o instanceof ReceiverRecord)) {
+            return false;
+        }
+        // Cast to the appropriate type.
+        ReceiverRecord record = (ReceiverRecord) o;
+        // Check each field.
+        return this.packageName.equals(record.packageName) &&
+                (this.enabled == record.enabled);
+    }
+
+    public static final Parcelable.Creator<ReceiverRecord> CREATOR
+            = new Parcelable.Creator<ReceiverRecord>() {
+        public ReceiverRecord createFromParcel(Parcel in) {
+            return new ReceiverRecord(in);
+        }
+
+        public ReceiverRecord[] newArray(int size) {
+            return new ReceiverRecord[size];
+        }
+    };
+}
+
diff --git a/core/java/com/mediatek/common/mom/SubPermissions.java b/core/java/com/mediatek/common/mom/SubPermissions.java
new file mode 100755
index 0000000..1b57977
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/SubPermissions.java
@@ -0,0 +1,54 @@
+package com.mediatek.common.mom;
+
+/**
+ * This class defined permissions to be monitored.
+ * Each sub-permission has an parent permission defined by android,
+ * and the operation can be executed only with all of the
+ * corresponding permissions are granted.
+ * To add a item here should sync to PermissionRecordHelper.java, too.
+ * @hide
+ */
+public class SubPermissions {
+    /** READ_SMS. */
+    public static final String QUERY_SMS = "sub-permission.QUERY_SMS";
+    /** READ_SMS. */
+    public static final String QUERY_MMS = "sub-permission.QUERY_MMS";
+    /** WRITE_SMS. */
+    public static final String MODIFY_SMS = "sub-permission.MODIFY_SMS";
+    /** WRITE_SMS. */
+    public static final String MODIFY_MMS = "sub-permission.MODIFY_MMS";
+    /** READ_CONTACTS. */
+    public static final String QUERY_CONTACTS = "sub-permission.QUERY_CONTACTS";
+    /** WRITE_CONTACTS. */
+    public static final String MODIFY_CONTACTS = "sub-permission.MODIFY_CONTACTS";
+    /** READ_CALL_LOG. */
+    public static final String QUERY_CALL_LOG = "sub-permission.QUERY_CALL_LOG";
+    /** WRITE_CALL_LOG. */
+    public static final String MODIFY_CALL_LOG = "sub-permission.MODIFY_CALL_LOG";
+    /** SEND_SMS. */
+    public static final String SEND_SMS = "sub-permission.SEND_SMS";
+    /** SEND_EMAIL. */
+    public static final String SEND_EMAIL = "sub-permission.SEND_EMAIL";
+    /** INTERNET. */
+    public static final String SEND_MMS = "sub-permission.SEND_MMS";
+    /** ACCESS_FINE_LOCATION. */
+    public static final String ACCESS_LOCATION = "sub-permission.ACCESS_LOCATION";
+    /** RECORD_AUDIO. */
+    public static final String RECORD_MIC = "sub-permission.RECORD_MIC";
+    /** CAMERA. */
+    public static final String OPEN_CAMERA = "sub-permission.OPEN_CAMERA";
+    /** CALL_PHONE. */
+    public static final String MAKE_CALL = "sub-permission.MAKE_CALL";
+    /** CALL_PHONE. */
+    public static final String MAKE_CONFERENCE_CALL = "sub-permission.MAKE_CONFERENCE_CALL";
+    /** CHANGE_NETWORK_STATE. */
+    public static final String CHANGE_NETWORK_STATE_ON = "sub-permission.CHANGE_NETWORK_STATE_ON";
+    /** CHANGE_WIFI_STATE. */
+    public static final String CHANGE_WIFI_STATE_ON = "sub-permission.CHANGE_WIFI_STATE_ON";
+    /** BLUETOOTH_ADMIM. */
+    public static final String CHANGE_BT_STATE_ON = "sub-permission.CHANGE_BT_STATE_ON";
+    /** READ_PHONE_STATE. */
+    public static final String READ_PHONE_IMEI = "sub-permission.READ_PHONE_IMEI";
+    /** HOTKNOT. */
+    public static final String ACCESS_HOTKNOT = "sub-permission.ACCESS_HOTKNOT";
+}
diff --git a/core/java/com/mediatek/common/mom/UserSecurityException.java b/core/java/com/mediatek/common/mom/UserSecurityException.java
new file mode 100755
index 0000000..11b3500
--- /dev/null
+++ b/core/java/com/mediatek/common/mom/UserSecurityException.java
@@ -0,0 +1,50 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.common.mom;
+
+
+/** @hide */
+public class UserSecurityException extends SecurityException {
+     public UserSecurityException() {
+     }
+
+     public UserSecurityException(String message) {
+         super(message);
+     }
+}
diff --git a/core/java/com/mediatek/hdmi/HdmiDef.java b/core/java/com/mediatek/hdmi/HdmiDef.java
new file mode 100644
index 0000000..ac7f59f
--- /dev/null
+++ b/core/java/com/mediatek/hdmi/HdmiDef.java
@@ -0,0 +1,229 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.hdmi;
+
+/**
+ * @hide
+ */
+public class HdmiDef {
+
+    /**
+     * HDMI resolution define AUTO mode offset value
+     * Ex. 102, UI show AUTO, output resolution is 720p_60Hz
+     * 
+     * @internal
+     */
+    public static final int AUTO = 100;
+    
+    /**
+     * HDMI resolution definition
+     */
+    public static final int RESOLUTION_720X480P_60HZ = 0;
+    public static final int RESOLUTION_720X576P_50HZ = 1;
+    public static final int RESOLUTION_1280X720P_60HZ = 2;
+    public static final int RESOLUTION_1280X720P_50HZ = 3;
+    public static final int RESOLUTION_1920X1080I_60HZ = 4;
+    public static final int RESOLUTION_1920X1080I_50HZ = 5;
+    public static final int RESOLUTION_1920X1080P_30HZ = 6;
+    public static final int RESOLUTION_1920X1080P_25HZ = 7;
+    public static final int RESOLUTION_1920X1080P_24HZ = 8;
+    public static final int RESOLUTION_1920X1080P_23HZ = 9;
+    public static final int RESOLUTION_1920X1080P_29HZ = 10;
+    public static final int RESOLUTION_1920X1080P_60HZ = 11;
+    public static final int RESOLUTION_1920X1080P_50HZ = 12;
+    public static final int RESOLUTION_1280X720P3D_60HZ = 13;
+    public static final int RESOLUTION_1280X720P3D_50HZ = 14;
+    public static final int RESOLUTION_1920X1080I3D_60HZ = 15;
+    public static final int RESOLUTION_1920X1080I3D_50HZ = 16;
+    public static final int RESOLUTION_1920X1080P3D_24HZ = 17;
+    public static final int RESOLUTION_1920X1080P3D_23HZ = 18;
+
+    /**
+     * HDMI resolution EDID mask
+     */
+    public static final int SINK_480P = (1 << 0);
+    public static final int SINK_720P60 = (1 << 1);
+    public static final int SINK_1080I60 = (1 << 2);
+    public static final int SINK_1080P60 = (1 << 3);
+    public static final int SINK_480P_1440 = (1 << 4);
+    public static final int SINK_480P_2880 = (1 << 5);
+    public static final int SINK_480I = (1 << 6);
+    public static final int SINK_480I_1440 = (1 << 7);
+    public static final int SINK_480I_2880 = (1 << 8);
+    public static final int SINK_1080P30 = (1 << 9);
+    public static final int SINK_576P = (1 << 10);
+    public static final int SINK_720P50 = (1 << 11);
+    public static final int SINK_1080I50 = (1 << 12);
+    public static final int SINK_1080P50 = (1 << 13);
+    public static final int SINK_576P_1440 = (1 << 14);
+    public static final int SINK_576P_2880 = (1 << 15);
+    public static final int SINK_576I = (1 << 16);
+    public static final int SINK_576I_1440 = (1 << 17);
+    public static final int SINK_576I_2880 = (1 << 18);
+    public static final int SINK_1080P25 = (1 << 19);
+    public static final int SINK_1080P24 = (1 << 20);
+    public static final int SINK_1080P23976 = (1 << 21);
+    public static final int SINK_1080P2997 = (1 << 22);
+
+    public static int[] sResolutionMask = new int[] { SINK_480P, SINK_576P,
+            SINK_720P60, SINK_720P50, SINK_1080I60, SINK_1080I50, SINK_1080P30,
+            SINK_1080P25, SINK_1080P24, SINK_1080P23976, SINK_1080P2997,
+            SINK_1080P60, SINK_1080P50 };
+
+    public static int[] getAllResolutions() {
+        int[] resolutions = new int[] { RESOLUTION_1920X1080P_60HZ,
+                RESOLUTION_1920X1080P_50HZ, RESOLUTION_1920X1080P_30HZ,
+                RESOLUTION_1920X1080P_25HZ, RESOLUTION_1920X1080P_24HZ,
+                RESOLUTION_1920X1080P_23HZ, RESOLUTION_1920X1080I_60HZ,
+                RESOLUTION_1920X1080I_50HZ, RESOLUTION_1280X720P_60HZ,
+                RESOLUTION_1280X720P_50HZ, RESOLUTION_720X480P_60HZ,
+                RESOLUTION_720X576P_50HZ };
+        return resolutions;
+    }
+
+    public static int[] getDefaultResolutions(int index) {
+        int[] resolutions;
+        if (0 == index) {
+            resolutions = new int[] { RESOLUTION_1280X720P_60HZ,
+                    RESOLUTION_1280X720P_50HZ, RESOLUTION_1920X1080P_24HZ,
+                    RESOLUTION_1920X1080P_23HZ };
+        } else if (1 == index) {
+            resolutions = getAllResolutions();
+        } else if (2 == index){
+            resolutions = new int[] { RESOLUTION_1920X1080P_30HZ,
+                    RESOLUTION_1280X720P_60HZ, RESOLUTION_720X480P_60HZ };
+        }else {
+            resolutions = new int[] { RESOLUTION_1920X1080P_30HZ,
+                    RESOLUTION_1920X1080P_60HZ,
+                    RESOLUTION_1280X720P_60HZ, RESOLUTION_720X480P_60HZ };
+        }
+        return resolutions;
+    }
+
+    public static int[] getPreferedResolutions(int index) {
+        int[] prefered = null;
+        if (0 == index) {
+            prefered = new int[] { AUTO + RESOLUTION_1280X720P_60HZ,
+                    AUTO + RESOLUTION_1280X720P_50HZ,
+                    AUTO + RESOLUTION_720X480P_60HZ,
+                    AUTO + RESOLUTION_720X576P_50HZ };
+        } else if (1 == index) {
+            prefered = new int[] { AUTO + RESOLUTION_1920X1080P_60HZ,
+                    AUTO + RESOLUTION_1920X1080P_50HZ,
+                    AUTO + RESOLUTION_1920X1080P_30HZ,
+                    AUTO + RESOLUTION_1920X1080P_25HZ,
+                    AUTO + RESOLUTION_1920X1080P_24HZ,
+                    AUTO + RESOLUTION_1920X1080P_23HZ,
+                    AUTO + RESOLUTION_1920X1080I_60HZ,
+                    AUTO + RESOLUTION_1920X1080I_50HZ,
+                    AUTO + RESOLUTION_1280X720P_60HZ,
+                    AUTO + RESOLUTION_1280X720P_50HZ,
+                    AUTO + RESOLUTION_720X480P_60HZ,
+                    AUTO + RESOLUTION_720X576P_50HZ };
+        } else if (2 == index) {
+            prefered = new int[] { AUTO + RESOLUTION_1280X720P_60HZ,
+                    AUTO + RESOLUTION_1920X1080P_30HZ,
+                    AUTO + RESOLUTION_720X480P_60HZ };
+        } else {
+            prefered = new int[] { AUTO + RESOLUTION_1920X1080P_60HZ,
+                    AUTO + RESOLUTION_1920X1080P_50HZ,
+                    AUTO + RESOLUTION_1920X1080P_30HZ,
+                    AUTO + RESOLUTION_1920X1080P_25HZ,
+                    AUTO + RESOLUTION_1920X1080P_24HZ,
+                    AUTO + RESOLUTION_1920X1080P_23HZ,
+                    AUTO + RESOLUTION_1920X1080I_60HZ,
+                    AUTO + RESOLUTION_1920X1080I_50HZ,
+                    AUTO + RESOLUTION_1280X720P_60HZ,
+                    AUTO + RESOLUTION_1280X720P_50HZ,
+                    AUTO + RESOLUTION_720X576P_50HZ,
+                    AUTO + RESOLUTION_720X480P_60HZ };
+        }
+        return prefered;
+    }
+
+    /**
+     * HDMI display type definition: HDMI
+     * 
+     * @internal
+     */
+    public static final int DISPLAY_TYPE_HDMI = 0;
+
+    /**
+     * HDMI display type definition: smartbook
+     * 
+     * @internal
+     */
+    public static final int DISPLAY_TYPE_SMB = 1;
+
+    /**
+     * HDMI display type definition: MHL
+     * 
+     * @internal
+     */
+    public static final int DISPLAY_TYPE_MHL = 2;
+
+    /**
+     * HDMI capability definition: adjust scale setting
+     * 
+     * @internal
+     */
+    public static final int CAPABILITY_SCALE_ADJUST = 0x01;
+
+    /**
+     * HDMI capability definition: HDMI and main display mutex
+     * 
+     * @internal
+     */
+    public static final int CAPABILITY_RDMA_LIMIT = 0x02;
+
+    /**
+     * HDMI capability definition: HDMI and call mutex
+     * 
+     * @internal
+     */
+    public static final int CAPABILITY_MUTEX_CALL = 0x04;
+
+    public static final int HDMI_MAX_CHANNEL = 0x78; // 1111000
+    public static final int HDMI_MAX_SAMPLERATE= 0x380; // 1110000000
+    public static final int HDMI_MAX_BITWIDTH = 0xc00; // 110000000000
+    public static final int HDMI_MAX_CHANNEL_OFFSETS = 3;
+    public static final int HDMI_MAX_SAMPLERATE_OFFSETS = 7;
+    public static final int HDMI_MAX_BITWIDTH_OFFSETS = 10;
+
+    public static final int AUDIO_OUTPUT_STEREO = 2;
+    public static final int AUDIO_OUTPUT_MULTICHANNEL= 6;
+
+}
diff --git a/core/java/com/mediatek/hdmi/IMtkHdmiManager.aidl b/core/java/com/mediatek/hdmi/IMtkHdmiManager.aidl
new file mode 100755
index 0000000..451f2cc
--- /dev/null
+++ b/core/java/com/mediatek/hdmi/IMtkHdmiManager.aidl
@@ -0,0 +1,56 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.hdmi;
+
+/**
+ * @hide
+ */
+interface IMtkHdmiManager {
+
+    boolean enableHdmi(boolean enabled);
+    boolean enableHdmiPower(boolean enabled);
+    boolean setVideoResolution(int resolution);
+    boolean setVideoScale(int scale);
+    boolean setColorAndDeep(int color, int deep);
+    int[] getResolutionMask();
+    boolean isSignalOutputting();
+    int[] getSupportedResolutions();
+    int getDisplayType();
+    void notifyHdVideoState(boolean playing);
+    boolean needSwDrmProtect();
+    boolean hasCapability(int mask);
+    int getAudioParameter(int mask, int offsets);
+}
diff --git a/core/java/com/mediatek/perfservice/IPerfService.aidl b/core/java/com/mediatek/perfservice/IPerfService.aidl
new file mode 100755
index 0000000..5dd1dbc
--- /dev/null
+++ b/core/java/com/mediatek/perfservice/IPerfService.aidl
@@ -0,0 +1,37 @@
+package com.mediatek.perfservice;
+
+/** @hide */
+interface IPerfService {
+
+    void boostEnable(int scenario);
+    void boostDisable(int scenario);
+    void boostEnableTimeout(int scenario, int timeout);
+    void boostEnableTimeoutMs(int scenario, int timeout_ms);
+    void notifyAppState(String packName, String className, int state);
+
+    int  userReg(int scn_core, int scn_freq, int pid, int tid);
+    int  userRegBigLittle(int scn_core_big, int scn_freq_big, int scn_core_little, int scn_freq_little, int pid, int tid);
+    void userUnreg(int handle);
+
+    int  userGetCapability(int cmd);
+
+    int  userRegScn(int pid, int tid);
+    void userRegScnConfig(int handle, int cmd, int param_1, int param_2, int param_3, int param_4);
+    void userUnregScn(int handle);
+
+    void userEnable(int handle);
+    void userEnableTimeout(int handle, int timeout);
+    void userEnableTimeoutMs(int handle, int timeout_ms);
+    void userDisable(int handle);
+
+    void userResetAll();
+    void userDisableAll();
+    void userRestoreAll();
+
+    void dumpAll();
+
+    void setFavorPid(int pid);
+    oneway void notifyFrameUpdate(int level);
+    oneway void notifyDisplayType(int type);
+    oneway void notifyUserStatus(int type, int status);
+}
diff --git a/core/java/com/mediatek/perfservice/IPerfServiceManager.java b/core/java/com/mediatek/perfservice/IPerfServiceManager.java
new file mode 100755
index 0000000..c5568b5
--- /dev/null
+++ b/core/java/com/mediatek/perfservice/IPerfServiceManager.java
@@ -0,0 +1,118 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.perfservice;
+
+//import java.io.File;
+//import java.io.OutputStreamWriter;
+//import java.io.InputStream;
+//import java.io.InputStreamReader;
+//import java.io.FileInputStream;
+//import java.io.BufferedReader;
+//import java.io.IOException;
+//import java.util.*;
+
+//import android.content.Context;
+//import android.content.Intent;
+//import android.content.IntentFilter;
+//import android.content.BroadcastReceiver;
+//import android.os.Handler;
+//import android.os.HandlerThread;
+//import android.os.Looper;
+//import android.os.Message;
+//import android.os.Process;
+//import android.util.Log;
+//import static junit.framework.Assert.*;
+
+public interface IPerfServiceManager {
+    public static final int SCN_NONE            = 0;
+    public static final int SCN_APP_SWITCH      = 1; /* apply for both launch/exit */
+    public static final int SCN_APP_ROTATE      = 2;
+    public static final int SCN_SW_CODEC        = 3;
+    public static final int SCN_SW_CODEC_BOOST  = 4;
+    public static final int SCN_APP_TOUCH       = 5;
+    public static final int SCN_DONT_USE1       = 6;
+    public static final int SCN_SW_FRAME_UPDATE = 7;
+
+    public static final int STATE_PAUSED    = 0;
+    public static final int STATE_RESUMED   = 1;
+    public static final int STATE_DESTROYED = 2;
+    public static final int STATE_DEAD      = 3;
+    public static final int STATE_STOPPED   = 4;
+
+    public static final int DISPLAY_TYPE_GAME   = 0;
+    public static final int DISPLAY_TYPE_OTHERS = 1;
+
+    public static final int NOTIFY_USER_TYPE_PID = 0;
+    public static final int NOTIFY_USER_TYPE_FRAME_UPDATE = 1;
+    public static final int NOTIFY_USER_TYPE_DISPLAY_TYPE = 2;
+
+    public void systemReady();
+
+    public void boostEnable(int scenario);
+    public void boostDisable(int scenario);
+    public void boostEnableTimeout(int scenario, int timeout);
+    public void boostEnableTimeoutMs(int scenario, int timeout_ms);
+    public void notifyAppState(String packName, String className, int state);
+
+    public int  userReg(int scn_core, int scn_freq, int pid, int tid);
+    public int  userRegBigLittle(int scn_core_big, int scn_freq_big, int scn_core_little, int scn_freq_little, int pid, int tid);
+    public void userUnreg(int handle);
+
+    public int  userGetCapability(int cmd);
+
+    public int  userRegScn(int pid, int tid);
+    public void userRegScnConfig(int handle, int cmd, int param_1, int param_2, int param_3, int param_4);
+    public void userUnregScn(int handle);
+
+    public void userEnable(int handle);
+    public void userEnableTimeout(int handle, int timeout);
+    public void userEnableTimeoutMs(int handle, int timeout_ms);
+    public void userDisable(int handle);
+
+    public void userResetAll();
+    public void userDisableAll();
+    public void userRestoreAll();
+
+    public void dumpAll();
+
+    public void setFavorPid(int pid);
+    public void notifyFrameUpdate(int level);
+    public void notifyDisplayType(int type);
+    public void notifyUserStatus(int type, int status);
+}
+
diff --git a/core/java/com/mediatek/perfservice/IPerfServiceWrapper.java b/core/java/com/mediatek/perfservice/IPerfServiceWrapper.java
new file mode 100755
index 0000000..4839337
--- /dev/null
+++ b/core/java/com/mediatek/perfservice/IPerfServiceWrapper.java
@@ -0,0 +1,80 @@
+package com.mediatek.perfservice;
+
+//import android.os.Bundle;
+
+public interface IPerfServiceWrapper {
+
+    public static final int SCN_NONE       = 0;
+    public static final int SCN_APP_SWITCH = 1; /* apply for both launch/exit */
+    public static final int SCN_APP_ROTATE = 2;
+    public static final int SCN_SW_CODEC   = 3;
+    public static final int SCN_SW_CODEC_BOOST  = 4;
+    public static final int SCN_APP_TOUCH       = 5;
+    public static final int SCN_DONT_USE1       = 6;
+    public static final int SCN_SW_FRAME_UPDATE = 7;
+
+    public static final int STATE_PAUSED    = 0;
+    public static final int STATE_RESUMED   = 1;
+    public static final int STATE_DESTROYED = 2;
+    public static final int STATE_DEAD      = 3;
+    public static final int STATE_STOPPED   = 4;
+
+    public static final int DISPLAY_TYPE_GAME   = 0;
+    public static final int DISPLAY_TYPE_OTHERS = 1;
+
+    public static final int NOTIFY_USER_TYPE_PID = 0;
+    public static final int NOTIFY_USER_TYPE_FRAME_UPDATE = 1;
+    public static final int NOTIFY_USER_TYPE_DISPLAY_TYPE = 2;
+
+    public static final int CMD_GET_CPU_FREQ_LEVEL_COUNT        = 0;
+    public static final int CMD_GET_CPU_FREQ_LITTLE_LEVEL_COUNT = 1;
+    public static final int CMD_GET_CPU_FREQ_BIG_LEVEL_COUNT    = 2;
+    public static final int CMD_GET_GPU_FREQ_LEVEL_COUNT        = 3;
+    public static final int CMD_GET_MEM_FREQ_LEVEL_COUNT        = 4;
+
+    public static final int CMD_SET_CPU_CORE_MIN            = 0;
+    public static final int CMD_SET_CPU_CORE_MAX            = 1;
+    public static final int CMD_SET_CPU_CORE_BIG_LITTLE_MIN = 2;
+    public static final int CMD_SET_CPU_CORE_BIG_LITTLE_MAX = 3;
+    public static final int CMD_SET_CPU_FREQ_MIN            = 4;
+    public static final int CMD_SET_CPU_FREQ_MAX            = 5;
+    public static final int CMD_SET_CPU_FREQ_BIG_LITTLE_MIN = 6;
+    public static final int CMD_SET_CPU_FREQ_BIG_LITTLE_MAX = 7;
+    public static final int CMD_SET_GPU_FREQ_MIN            = 8;
+    public static final int CMD_SET_GPU_FREQ_MAX            = 9;
+    public static final int CMD_SET_MEM_FREQ_MIN            = 10;
+    public static final int CMD_SET_MEM_FREQ_MAX            = 11;
+    public static final int CMD_SET_SCREEN_OFF_STATE        = 12;
+
+    public void boostEnable(int scenario);
+    public void boostDisable(int scenario);
+    public void boostEnableTimeout(int scenario, int timeout);
+    public void boostEnableTimeoutMs(int scenario, int timeout_ms);
+    public void notifyAppState(String packName, String className, int state);
+
+    public int  userReg(int scn_core, int scn_freq);
+    public int  userRegBigLittle(int scn_core_big, int scn_freq_big, int scn_core_little, int scn_freq_little);
+    public void userUnreg(int handle);
+
+    public int  userGetCapability(int cmd);
+
+    public int  userRegScn();
+    public void userRegScnConfig(int handle, int cmd, int param_1, int param_2, int param_3, int param_4);
+    public void userUnregScn(int handle);
+
+    public void userEnable(int handle);
+    public void userEnableTimeout(int handle, int timeout);
+    public void userEnableTimeoutMs(int handle, int timeout_ms);
+    public void userDisable(int handle);
+
+    public void userResetAll();
+    public void userDisableAll();
+    public void userRestoreAll();
+
+    public void dumpAll();
+
+    public void setFavorPid(int pid);
+    public void notifyFrameUpdate(int level);
+    public void notifyDisplayType(int type);
+    public void notifyUserStatus(int type, int status);
+}
diff --git a/core/java/com/mediatek/perfservice/PerfServiceWrapper.java b/core/java/com/mediatek/perfservice/PerfServiceWrapper.java
new file mode 100755
index 0000000..b197e9f
--- /dev/null
+++ b/core/java/com/mediatek/perfservice/PerfServiceWrapper.java
@@ -0,0 +1,383 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.perfservice;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+import com.mediatek.xlog.Xlog;
+
+
+public class PerfServiceWrapper implements IPerfServiceWrapper {
+
+    private static final String TAG = "PerfServiceWrapper";
+
+    private IPerfService sService = null;
+    private Context mContext;
+
+    private int inited = 0;
+
+    private int setTid = 0;
+    private long mPreviousTime = 0;
+    private static final int RENDER_THREAD_UPDATE_DURATION = 400;
+
+    public static native int nativeGetPid();
+    public static native int nativeGetTid();
+
+    private void init() {
+        if(inited == 0) {
+            IBinder b = ServiceManager.checkService(Context.MTK_PERF_SERVICE);
+            if(b != null) {
+                sService = IPerfService.Stub.asInterface(b);
+                if (sService != null)
+                    inited = 1;
+                else
+                    log("ERR: getService() sService is still null..");
+            }
+        }
+    }
+
+    public PerfServiceWrapper(Context context) {
+        mContext = context;
+        init();
+    }
+
+    public void boostEnable(int scenario) {
+        //log("boostEnable");
+        try {
+            init();
+            if(sService != null)
+                sService.boostEnable(scenario);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in boostEnable:" + e);
+        }
+    }
+
+    public void boostDisable(int scenario) {
+        //log("boostEnable");
+        try {
+            init();
+            if(sService != null)
+                sService.boostDisable(scenario);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in boostDisable:" + e);
+        }
+    }
+
+    public void boostEnableTimeout(int scenario, int timeout) {
+        //log("boostEnable");
+        try {
+            init();
+            if(sService != null)
+                sService.boostEnableTimeout(scenario, timeout);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in boostEnableTimeout:" + e);
+        }
+    }
+
+    public void boostEnableTimeoutMs(int scenario, int timeout_ms) {
+        //log("boostEnableTimeoutMs");
+        try {
+            init();
+            if(sService != null)
+                sService.boostEnableTimeoutMs(scenario, timeout_ms);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in boostEnableTimeoutMs:" + e);
+        }
+    }
+
+    public void notifyAppState(String packName, String className, int state) {
+        //log("boostEnable");
+        try {
+            init();
+            if(sService != null)
+                sService.notifyAppState(packName, className, state);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in notifyAppState:" + e);
+        }
+    }
+
+    public int userReg(int scn_core, int scn_freq) {
+        int handle = -1;
+        //log("[userReg] - "+scn_core+", "+scn_freq);
+        try {
+            init();
+            int pid = nativeGetPid();
+            int tid = nativeGetTid();
+            if(sService != null)
+                handle = sService.userReg(scn_core, scn_freq, pid, tid);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userReg:" + e);
+        }
+        //log("[userReg] - handle:"+handle);
+        return handle;
+    }
+
+    public int userRegBigLittle(int scn_core_big, int scn_freq_big, int scn_core_little, int scn_freq_little) {
+        int handle = -1;
+        //log("[userRegBigLittle] - "+scn_core_big+", "+scn_freq_big+", "+scn_core_little+", "+scn_freq_little);
+        try {
+            init();
+            int pid = nativeGetPid();
+            int tid = nativeGetTid();
+            if(sService != null)
+                handle = sService.userRegBigLittle(scn_core_big, scn_freq_big, scn_core_little, scn_freq_little, pid, tid);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userRegBigLittle:" + e);
+        }
+        //log("[userRegBigLittle] - handle:"+handle);
+        return handle;
+    }
+
+    public void userUnreg(int handle) {
+        //log("[userUnreg] - "+handle);
+        try {
+            init();
+            if(sService != null)
+                sService.userUnreg(handle);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userUnreg:" + e);
+        }
+    }
+
+    public int userGetCapability(int cmd) {
+        int value = -1;
+        //log("[userGetCapability] - "+cmd);
+        try {
+            init();
+            if(sService != null)
+                value = sService.userGetCapability(cmd);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userGetCapability:" + e);
+        }
+        //log("[userGetCapability] - value:"+value);
+        return value;
+    }
+
+    public int userRegScn() {
+        int handle = -1;
+        //log("[userRegScn]");
+        try {
+            init();
+            int pid = nativeGetPid();
+            int tid = nativeGetTid();
+            if(sService != null)
+                handle = sService.userRegScn(pid, tid);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userRegScn:" + e);
+        }
+        //log("[userRegScn] - handle:"+handle);
+        return handle;
+    }
+
+    public void userRegScnConfig(int handle, int cmd, int param_1, int param_2, int param_3, int param_4) {
+        //log("userRegScnConfig");
+        try {
+            init();
+            if(sService != null)
+                sService.userRegScnConfig(handle, cmd, param_1, param_2, param_3, param_4);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userRegScnConfig:" + e);
+        }
+    }
+
+    public void userUnregScn(int handle) {
+        //log("userUnregScn");
+        try {
+            init();
+            if(sService != null)
+                sService.userUnregScn(handle);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userUnregScn:" + e);
+        }
+    }
+
+    public void userEnable(int handle) {
+        //log("[userEnable] - "+handle);
+        try {
+            init();
+            if(sService != null)
+                sService.userEnable(handle);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userEnable:" + e);
+        }
+    }
+
+    public void userDisable(int handle) {
+        //log("[userDisable] - "+handle);
+        try {
+            init();
+            if(sService != null)
+                sService.userDisable(handle);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userDisable:" + e);
+        }
+    }
+
+    public void userEnableTimeout(int handle, int timeout) {
+        //log("[userEnableTimeout] - "+handle+", "+timeout);
+        try {
+            init();
+            if(sService != null)
+                sService.userEnableTimeout(handle, timeout);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userEnableTimeout:" + e);
+        }
+    }
+
+    public void userEnableTimeoutMs(int handle, int timeout_ms) {
+        //log("[userEnableTimeoutMs] - "+handle+", "+timeout);
+        try {
+            init();
+            if(sService != null)
+                sService.userEnableTimeoutMs(handle, timeout_ms);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userEnableTimeoutMs:" + e);
+        }
+    }
+
+    public void userResetAll() {
+        try {
+            init();
+            if(sService != null)
+                sService.userResetAll();
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userResetAll:" + e);
+        }
+    }
+
+    public void userDisableAll() {
+        try {
+            init();
+            if(sService != null)
+                sService.userDisableAll();
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userDisableAll:" + e);
+        }
+    }
+
+    public void userRestoreAll() {
+        try {
+            init();
+            if(sService != null)
+                sService.userRestoreAll();
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in userRestoreAll:" + e);
+        }
+    }
+
+    public void dumpAll() {
+        try {
+            init();
+            if(sService != null)
+                sService.dumpAll();
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in dumpAll:" + e);
+        }
+    }
+
+    public void setFavorPid(int pid) {
+        //log("userUnregScn");
+        try {
+            init();
+            if(sService != null)
+                sService.setFavorPid(pid);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in setFavorPid:" + e);
+        }
+    }
+
+    public void notifyFrameUpdate(int level) {
+        //log("notifyFrameUpdate");
+        final long nowTime = System.currentTimeMillis();
+
+        try {
+            init();
+
+            if(setTid == 0) {
+                level = nativeGetTid();
+                setTid = 1;
+            }
+
+            if(mPreviousTime == 0 || (nowTime - mPreviousTime) > RENDER_THREAD_UPDATE_DURATION) {
+                //log("notifyFrameUpdate - mPreviousTime:" + mPreviousTime + ", nowTime:" + nowTime);
+                if(sService != null)
+                    sService.notifyFrameUpdate(level);
+                mPreviousTime = nowTime;
+            }
+
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in notifyFrameUpdate:" + e);
+        }
+    }
+
+    public void notifyDisplayType(int type) {
+        //log("notifyDisplayType");
+        try {
+            init();
+
+            if(sService != null)
+                sService.notifyDisplayType(type);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in notifyDisplayType:" + e);
+        }
+    }
+
+    public void notifyUserStatus(int type, int status) {
+        //log("notifyDisplayType");
+        try {
+            init();
+
+            if(sService != null)
+                sService.notifyUserStatus(type, status);
+        } catch (RemoteException e) {
+            loge("ERR: RemoteException in notifyUserStatus:" + e);
+        }
+    }
+
+    private void log(String info) {
+        Xlog.d(TAG, "[PerfServiceWrapper] " + info + " ");
+    }
+
+    private void loge(String info) {
+        Xlog.e(TAG, "[PerfServiceWrapper] ERR: " + info + " ");
+    }
+}
+
-- 
2.9.0

